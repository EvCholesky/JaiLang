#import "Basic"
#import "Font"
#import "GL"
#import "Math"

g_dXWindow :: 1280
g_dYWindow :: 720
g_cTickPerSecond: s64 = 1

FHandleEvents proc () -> bool
{
	a : int = 1	
	b : int = 1	

	event : SEvent
	while FGetNextEvent(&event)
	{
		printf("Event: keycode=%d, edges = %d\n", event.m_keycode, event.m_edges)
		if event.m_keycode == KEYCODE.Escape && event.m_edges == EDGES.Press
		{
			return false
		}
	}

	return true
}

DrawTestTriangle proc (gRadians:float)
{
	dRad :: g_Pi * 2.0 / 3.0
	vecCenter := Vec2Create(g_dXWindow / 2.0, g_dYWindow / 2.0)
	vecRadius := Vec2Create(300, 0)
	vecA := VecRotate(gRadians, vecRadius)
	vecB := VecRotate(gRadians + dRad, vecRadius)
	vecC := VecRotate(gRadians + (2.0 * dRad), vecRadius)
	z := 0.0

	vecA = VecAdd(vecA, vecCenter)
	vecB = VecAdd(vecB, vecCenter)
	vecC = VecAdd(vecC, vecCenter)

    glBegin(GL_TRIANGLES)
    glColor3f(1, 0, 0)
    glVertex3f(vecA.m_x, vecA.m_y, z)
    glColor3f(0, 1, 0)
    glVertex3f(vecB.m_x, vecB.m_y, z)
    glColor3f(0, 0, 1)
    glVertex3f(vecC.m_x, vecC.m_y, z)
    glEnd()
}

DTElapsed proc (cTickStart: s64, cTickEnd: s64) -> f32 inline
{
    return cast (f32)(cTickEnd - cTickStart) / cast(f32)g_cTickPerSecond
}

main proc () -> int
{
	pWindow : HWND
	CreateWindow(g_dXWindow, g_dYWindow, "Puck", &pWindow)

	pDrac := PDracStaticInit(PVAllocDefault)
	if !pDrac
	{
		return 0
	}

	pDrac.m_pDras.m_fontd.m_gCharSize = 20

	SetupOrthoViewport(0, 0, g_dXWindow, g_dYWindow)

    dRadSpin :: 0.01
    gRadSpin: float

    // Make sure sleep has 1ms granularity
    s_cMsDesiredGranularity :: 1
    fIsSleepGranular := FTrySetTimerResolution(s_cMsDesiredGranularity)
    g_cTickPerSecond = CTickPerSecond() 

    nHzMonitorRefresh : s32 = GetMonitorRefresh(pWindow)
    nHzTarget := cast (f32)(nHzMonitorRefresh)
  	printf("%d %f\n", nHzMonitorRefresh, nHzTarget)

    dTFrameTarget := 1.0 / nHzTarget
	aChStatus: [512] u8

	cTickLast := CTickWallClock()
	fShouldClose := false
	while fShouldClose == false
	{
		fShouldClose |= !FHandleEvents()

		gRadSpin += dRadSpin
		DrawTestTriangle(gRadSpin)

        SwapBuffers(pWindow)
		ClearWindow(0, 0.5, 1, 1)

        UpdateWindowEvents()

// 		if !s_fIsPaused
	    {
	    	cTickWork := CTickWallClock()
	    	dTWorkElapsed := DTElapsed(cTickLast, cTickWork)

	        dTElapsedFrame := dTWorkElapsed
	        if dTElapsedFrame < dTFrameTarget
	        {                        
	            if fIsSleepGranular
	            {
	                SleepMS := cast (u32)(1000.0 * (dTFrameTarget - dTElapsedFrame))
	                if SleepMS > 0
	                {
	                    Sleep(SleepMS)
	                }
	            }

	            while dTElapsedFrame < dTFrameTarget
	            {                            
	                dTElapsedFrame = DTElapsed(cTickLast, CTickWallClock())
	            }
	        }
	    }

	    cTickEnd := CTickWallClock()
	    dTFrameActual := DTElapsed(cTickLast, cTickEnd)
	    cTickLast = cTickEnd

	    nHzActual := 1 / dTFrameActual
	    snprintf(aChStatus, aChStatus.count, "%0.1f / %0.1f, %0.2f ms", nHzActual, nHzTarget, dTFrameActual * 1000)
		DrawText(pDrac, Vec2Create(20, g_dYWindow - 35), aChStatus)

	}
	return 1
}