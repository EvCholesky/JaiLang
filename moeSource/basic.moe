#foreign_library "Basic"

PrintFloat proc (g : float) #foreign
PrintInt proc (n : int) #foreign
PrintByte proc (n : s8) #foreign
PrintBool proc (f : bool) #foreign
PrintPointer proc (pB : & u8) #foreign
PrintString proc (pCh : & u8) #foreign
printf proc (pChz : &u8, ..) -> s32 #foreign

snprintf proc (aChz: & u8, cBMax: uSize, pCozFormat: & u8, ..) -> sSize #foreign snprintf_MOE


strlen proc (pChz: &u8) -> int #foreign
tolower proc (ch: int) -> int #foreign

HANDLE typedef int 	// This actually needs to be pointer-sized, so s32 in 32-bit, 
						//  but lots of people use integers too, arrrrgh!!

INVALID_HANDLE :: -1

HWND typedef &void
HDC  typedef HANDLE

SStartupInfo struct 
{
    m_cb : s32
    m_lpReserved : & u8
    m_lpDesktop : & u8
    m_lpTitle : & u8
    m_dwX : s32
    m_dwY : s32
    m_dwXSize : s32
    m_dwYSize : s32
    m_dwXCountChars : s32
    m_dwYCountChars : s32
    m_dwFillAttribute: s32
    m_dwFlags : s32
    m_wShowWindow : s16
    m_cbReserved2 : s16
    m_lpReserved2 : & u8
    m_hStdInput : HANDLE
    m_hStdOutput : HANDLE
    m_hStdError : HANDLE
}

// (JBlow) For some reason in Windows sinf and cosf don't have linkage, probably because
// they always get turned into intrinsics? So I made my own..
cos  proc (theta: float) -> float #foreign cosf_MOE 
sin  proc (theta: float) -> float #foreign sinf_MOE
sqrt proc (theta: float) -> float #foreign sqrtf_MOE

cos64  proc (theta: f64) -> f64 #foreign cos
sin64  proc (theta: f64) -> f64 #foreign sin
sqrt64 proc (theta: f64) -> f64 #foreign sqrt

DebugBreak proc () -> void #foreign
PVMalloc proc (cB : uSize) -> & void #foreign
FreeMalloc proc (pV: &void) #foreign

ProcAlloc typedef (allock: ALLOCK, cB: uSize, cBPrev: uSize, pVPrev: & void, pVAllocator: & void, options: s64) -> & void

memcpy proc (dest: &void, source: &void, count: uSize) -> &void #foreign
memset proc (dest: &void, value: int, count: uSize)    -> &void #foreign

PVAllocSimple proc (pFnAlloc : ProcAlloc, cB: uSize) -> & void inline
{
    // This is just a simple wrapper for allocations that won't be necessary once default args are done.

    return pFnAlloc(ALLOCK.Allocate, cB, 0, null, null, 0)
}

PVAllocDefault proc (allock: ALLOCK, cB: uSize, cBPrev: uSize, pVPrev: & void, pVAllocator: & void, options: s64) -> & void
{
    if allock == ALLOCK.Allocate
    {
        return PVMalloc(cB)
    } 
    else if allock == ALLOCK.Resize
    {
        // For now, we dont even bother with realloc, just allocate, copy, free.
        pVNew := PVMalloc(cB)
        if !pVNew
        {
            return null
        }

        if pVPrev && (cBPrev > 0) 
        {
            memcpy(pVNew, pVPrev, cBPrev)
            FreeMalloc(pVPrev)
        }

        return pVNew
    }
    else if allock == ALLOCK.Free
    {
        FreeMalloc(pVPrev)
    }
    else if allock == ALLOCK.FreeAll 
    {
        assert(false, "ALLOCK.FreeAll is not yet implemented", #file, #line)
    }
    else 
    {
        assert(false, "unhanadled ALLOCK ", #file, #line)
    }

    return null
}

ALLOCK enum 
{
    Allocate,
    Resize,
    Free,
    FreeAll
}

assert proc (fPredicate: bool, pChz: & u8, pChzFile: & u8, nLine: int)
{
	if (!fPredicate)	
	{
		printf("ASSERT FAILED: (%s, %d) %s\n", pChzFile, nLine, pChz)
		DebugBreak()
	}
}

fverify proc (fPredicate: bool, pChz: & u8, pChzFile: & u8, nLine: int) -> bool
{
	if (!fPredicate)	
	{
		printf("ASSERT FAILED: (%s, %d) %s\n", pChzFile, nLine, pChz)
		DebugBreak()
	}
	return fPredicate
}

// for loop Iterators

// int range iterator
SIntIterator struct
{
    m_i: int
    m_nMax: int // one past the end
}

iterMake proc (iBegin: int, nMax: int) -> SIntIterator
{
    iter : SIntIterator
    iter.m_i = iBegin
    iter.m_nMax = nMax
    return iter
}

iterIsDone proc (pIter: &SIntIterator) -> bool
{
    return pIter.m_i >= pIter.m_nMax
}

iterNext proc (pIter: &SIntIterator)
{
    ++pIter.m_i
}

// utf8 null terminated string iterator
iterIsDone proc (ppCoz: &&u8) -> bool
{
    return @ppCoz == null || @@ppCoz == '\0'
}

iterNext proc (ppCoz: &&u8)
{
    pCoz := @ppCoz
    pCozEnd : &u8

    if ((@pCoz & 0xF8) == 0xF0)         { pCozEnd = pCoz + 4 }
    else if ((@pCoz & 0xF0) == 0xE0)    { pCozEnd = pCoz + 3 }
    else if ((@pCoz & 0xE0) == 0xC0)    { pCozEnd = pCoz + 2 }
    else                                { pCozEnd = pCoz + 1 }

    ++pCoz
    while ((@pCoz & 0xC0) == 0x80) && (pCoz != pCozEnd)
    {
        ++pCoz
    }

    @ppCoz = pCoz
}

