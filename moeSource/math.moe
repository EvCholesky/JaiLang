#import "Basic"

g_Pi :: 3.1415926535897932

// limits
F32_MAX :: 3.402823466e+38
F32_MIN :: 1.175494351e-38
F64_MAX :: 1.7976931348623158e+308
F64_MIN :: 2.2250738585072014e-308


f32x2 struct
{
	m_x: float
	m_y: float
}

f32x3 struct
{
	m_x: float
	m_y: float
	m_z: float
}

f32x4 struct
{
	m_x: float
	m_y: float
	m_z: float
	m_w: float
}

F32x2Create proc (x: float, y: float) -> f32x2
{
	vec : f32x2
	vec.m_x = x
	vec.m_y = y
	return vec
}

F32x3Create proc (x: float, y: float, z: float) -> f32x3
{
	vec : f32x3
	vec.m_x = x
	vec.m_y = y
	vec.m_z = z
	return vec
}

F32x4Create proc (x: float, y: float, z: float, w: float) -> f32x4
{
	vec : f32x4
	vec.m_x = x
	vec.m_y = y
	vec.m_z = z
	vec.m_w = w
	return vec
}

VecRotate proc (gRadians: float, vec: f32x2) -> f32x2
{
	gSin := sin(gRadians)
	gCos := cos(gRadians)

	//[c -s][ x ]   [ cx - sy ]
	//[s  c][ y ] = [ cy + sx ]

	return F32x2Create(gCos * vec.m_x - gSin * vec.m_y, gCos * vec.m_y + gSin * vec.m_x)
}

operator+(vecLhs: f32x2, vecRhs: f32x2) -> f32x2 inline
{
	return F32x2Create(vecLhs.m_x + vecRhs.m_x, vecLhs.m_y + vecRhs.m_y)
}

operator+=(pVecLhs: &f32x2, vecRhs: f32x2) 
{
	pVecLhs.m_x += vecRhs.m_x
	pVecLhs.m_y += vecRhs.m_y
}

operator-(vecLhs: f32x2, vecRhs: f32x2) -> f32x2 inline
{
	return F32x2Create(vecLhs.m_x - vecRhs.m_x, vecLhs.m_y - vecRhs.m_y)
}

operator-=(pVecLhs: &f32x2, vecRhs: f32x2) 
{
	pVecLhs.m_x -= vecRhs.m_x
	pVecLhs.m_y -= vecRhs.m_y
}

operator-(vecLhs: f32x2) -> f32x2 inline
{
	return F32x2Create(-vecLhs.m_x, -vecLhs.m_y)
}

operator*(vec: f32x2, r: f32) -> f32x2 inline #commutative
{
	return F32x2Create(vec.m_x * r, vec.m_y * r)
}

operator*=(pVecLhs: &f32x2, r: f32) 
{
	pVecLhs.m_x *= r
	pVecLhs.m_y *= r
}

operator+(vecLhs: f32x3, vecRhs: f32x3) -> f32x3 inline
{
	return F32x3Create(vecLhs.m_x + vecRhs.m_x, vecLhs.m_y + vecRhs.m_y, vecLhs.m_z + vecRhs.m_z)
}

operator-(vecLhs: f32x3, vecRhs: f32x3) -> f32x3 inline
{
	return F32x3Create(vecLhs.m_x - vecRhs.m_x, vecLhs.m_y - vecRhs.m_y, vecLhs.m_z - vecRhs.m_z)
}

operator-(vecLhs: f32x3) -> f32x3 inline
{
	return F32x3Create(-vecLhs.m_x, -vecLhs.m_y, -vecLhs.m_z)
}

operator*(vec: f32x3, r: f32) -> f32x3 inline #commutative
{
	return F32x3Create(vec.m_x * r, vec.m_y * r, vec.m_z * r)
}

operator+(vecLhs: f32x4, vecRhs: f32x4) -> f32x4 inline
{
	return F32x4Create(
			vecLhs.m_x + vecRhs.m_x,
			vecLhs.m_y + vecRhs.m_y,
			vecLhs.m_z + vecRhs.m_z,
			vecLhs.m_w + vecRhs.m_w)
}

operator-(vecLhs: f32x4, vecRhs: f32x4) -> f32x4 inline
{
	return F32x4Create(
			vecLhs.m_x - vecRhs.m_x,
			vecLhs.m_y - vecRhs.m_y,
			vecLhs.m_z - vecRhs.m_z,
			vecLhs.m_w - vecRhs.m_w)
}

operator-(vecLhs: f32x4) -> f32x4 inline
{
	return F32x4Create(-vecLhs.m_x, -vecLhs.m_y, -vecLhs.m_z, -vecLhs.m_w)
}

operator*(vec: f32x4, r: f32) -> f32x4 inline
{
	return F32x4Create(vec.m_x * r, vec.m_y * r, vec.m_z * r, vec.m_w * r)
}

s32x2 struct // tag = ivec
{
	m_x: s32	
	m_y: s32
}

S32x2Create proc (x: s32, y: s32) -> s32x2
{
	ivec: s32x2
	ivec.m_x = x
	ivec.m_y = y
	return ivec
}

operator+(vecLhs: s32x2, vecRhs: s32x2) -> s32x2
{
	vecLhs.m_x += vecRhs.m_x	
	vecLhs.m_y += vecRhs.m_y
	return vecLhs
}

operator-(vecLhs: s32x2, vecRhs: s32x2) -> s32x2
{
	vecLhs.m_x -= vecRhs.m_x	
	vecLhs.m_y -= vecRhs.m_y
	return vecLhs
}

operator-(vecLhs: s32x2) -> s32x2
{
	vecLhs.m_x = -vecLhs.m_x	
	vecLhs.m_y = -vecLhs.m_y
	return vecLhs
}

operator*(vecLhs: s32x2, r: s32) -> s32x2 #commutative
{
	vecLhs.m_x *= r
	vecLhs.m_y *= r
	return vecLhs
}

VecSign proc (vec: f32x2) -> s32x2
{
	vecReturn: s32x2
	if vec.m_x < -gEpsilon
		{ vecReturn.m_x = -1 }
	else if vec.m_x > gEpsilon
		{ vecReturn.m_x = 1 }

	if vec.m_y < -gEpsilon
		{ vecReturn.m_y = -1 }
	else if vec.m_y > gEpsilon
		{ vecReturn.m_y = 1 }
	return vecReturn
}


gEpsilon :: 0.0001
gEpsilonNormalize :: 0.00001
GLengthSqr proc (vec: f32x2) -> f32 inline 					{ return (vec.m_x * vec.m_x + vec.m_y * vec.m_y) }
GLengthSqr proc (vec: f32x3) -> f32 inline 					{ return (vec.m_x * vec.m_x + vec.m_y * vec.m_y + vec.m_z * vec.m_z) }

GLength proc (vec: f32x2) -> f32 inline 					{return GSqrt(vec.m_x * vec.m_x + vec.m_y * vec.m_y) }
GLength proc (vec: f32x3) -> f32 inline 					{return GSqrt(vec.m_x * vec.m_x + vec.m_y * vec.m_y  + vec.m_z * vec.m_z) }

VecNormalize proc (vec: f32x2) -> f32x2 inline 				{ return vec * (1 / GLength(vec)) }
VecNormalize proc (vec: f32x3) -> f32x3 inline 				{ return vec * (1 / GLength(vec)) }

VecNormalizeElse proc (vec: f32x2, vecElse: f32x2) -> f32x2 inline
{ 
	gLength := GLength(vec)
	if gLength < gEpsilonNormalize
	{
		return vecElse
	}
	return vec * (1 / gLength) 
}

VecNormalizeElse proc (vec: f32x3, vecElse: f32x3) -> f32x3 inline
{ 
	gLength := GLength(vec)
	if gLength < gEpsilonNormalize
	{
		return vecElse
	}
	return vec * (1 / gLength) 
}

VecNormalizeAndLength proc (vec: f32x2, pLength: & f32) -> f32x2 inline 
{
	gLength := GLength(vec)
	@pLength = gLength
	return vec * (1 / gLength)
}
	
VecNormalizeAndLength proc (vec: f32x3, pLength: & f32) -> f32x3 inline
{
	gLength := GLength(vec)
	@pLength = gLength
	return vec * (1 / gLength)
}

GMin proc (gA: f32, gB: f32) -> f32 inline						{ if (gA < gB) { return gA } return gB }
GMax proc (gA: f32, gB: f32) -> f32 inline						{ if (gA > gB) { return gA } return gB }
GClamp proc (gValue: f32, gMin: f32, gMax: f32) -> f32 inline	{ return GMin(GMax(gValue, gMin), gMax) }
GLerp proc (gA: f32, gB: f32, uLerp: f32) -> f32 inline			{ return gA + (gB - gA) * uLerp }

NMin proc (nA: int, nB: int) -> int inline						{ if (nA < nB) { return nA } return nB }
NMax proc (nA: int, nB: int) -> int inline						{ if (nA > nB) { return nA } return nB }
NMin proc (nA: s32, nB: s32) -> s32 inline						{ if (nA < nB) { return nA } return nB }
NMax proc (nA: s32, nB: s32) -> s32 inline						{ if (nA > nB) { return nA } return nB }

NSign proc (n: int) -> int inline
{
	if (n < 0)
		{ return -1 }
	return 1
}

GSign proc (g: float) -> float inline
{
	if (g < 0)
		{ return -1 }
	return 1
}

SRandomGenJenkinsSmall struct // tag = rng
{
	m_nA, m_nB, m_nC, m_nD: u32
}

SRandomGen typedef SRandomGenJenkinsSmall

SeedRandom proc (pRng: & SRandomGenJenkinsSmall, nSeed: u32)
{
	pRng.m_nA = 0xf1ea5eed
	pRng.m_nB = nSeed
	pRng.m_nC = nSeed
	pRng.m_nD = nSeed

	i := 0
	while i < 20
	{
		NGenerateRand(pRng)
		++i
	}
}
//#define EWC_RAND_SMALL_ROT(X, K)  (((X)<<(K))|((X)>>(32-(K))))
	
NGenerateRand proc (pRng : & SRandomGenJenkinsSmall) -> u32
{
	//U32 nE = m_nA - EWC_RAND_SMALL_ROT(m_nB, 27);	
	//m_nA = m_nB ^ EWC_RAND_SMALL_ROT(m_nC, 17);
	nE := pRng.m_nA - ((pRng.m_nB << 27) | (pRng.m_nB >> (32 - 27)))
	pRng.m_nA = pRng.m_nB ^ ((pRng.m_nC << 17) | (pRng.m_nC >> (32 - 17)))
	pRng.m_nB = pRng.m_nC + pRng.m_nD
	pRng.m_nC = pRng.m_nD + nE
	pRng.m_nD = nE + pRng.m_nA
	return pRng.m_nD
}

GRandom proc (pRng : & SRandomGenJenkinsSmall, gMin: f32, gMax: f32) -> f32
{
	d := gMax-gMin
	if (d <= 0.000001)
	{
		return gMin
	}

	assert(d >= 0.0, "bad range in GRandom", #file, #line)

	return gMin + ( cast(f32) NGenerateRand(pRng) / cast (f32)0xFFFFFFFF) * d
}


NRandom proc (pRng : & SRandomGenJenkinsSmall, nMin: s32, nMax: s32) -> s32
{ 
	d := cast(u32)(nMax-nMin)
	if (d == 0)
	{
		return nMin
	}

	assert(d > 0, "bad range in NRandom", #file, #line)
	return nMin + cast(s32) (NGenerateRand(pRng) % d)
}

BuildRandomOrderedArray proc (pRng : & SRandomGenJenkinsSmall, aiN: [] s32)
{
	c := aiN.count
	if (c <= 0)
	{
		return
	}

	// build a random ordered array containing all values [0..(c-1)] exactly once.
	//  this is an implementation of the "inside-out" fisher-yates shuffle

	aiN[0] = 0
	//for (int i = 1; i < c; ++i)
	i : s32 = 1
	while (i < c)	
	{
		iNRand := NRandom(pRng, 0, i+1)
		printf("iNRand = %d\n", iNRand)
		if (iNRand != i)
		{
			aiN[i] = aiN[iNRand]
		}
		aiN[iNRand] = i
		++i
	}
}
