
// Permute string format is a nested series of "permute" objects:
//	$perm(foo|bar)   	defines a permutation of the variable $perm with options "foo" and "bar"
//
//						option strings are separated by the '|' character and can be wrapped in quotes
//						option strings can contain substitution variables defined by any ancestor permutation
//						option strings can supply an expected error with "$errid(1234)" meaning this option must cause error #1234
// We test each permutation option against all of the permutation's children's options
// permutations options are added with '+' for a single child or curly braces for multiple comma separated child permutations

// [X] Document permute string format
// [ ] Track and fix unit test memory leaks
// [ ] Finish porting tests and delete old code
// [ ] Add support for named test command line arg
// [ ] Add support for built-in tests
// [X] Finish work on expected errors

// Declaration Tests:
test DeclareAssign
	input "v : $type = $init"
	parse "(decl `v `$type $initp)"
	typecheck "($type `v $type Literal:$littype)"
	permute
	{
		$init(2.200000$errid(2001)) + $initp("$init")
		{
			$type(int) + $littype(Int##),
			$type(s32|u32) + $littype(Int32),
			$type(s64|u64) + $littype(Int64),
		},

		$init(int$errid(2009)) + $initp("`$init") + $type(int) + $littype(Int32),	// make sure we can't assign a type as an RVal

		$littype(Int8) + $type(u8|s8)
		{
			$init(2|1000$errid(2001)) + $initp("$init"),
			$init("'\\0'") + $initp(0),
			$init("'a'") +$initp(97),
		},
	}

test QualDeclareAssign
	input "v : $qual $type = $init"
	parse "(decl `v ($qual `$type) $init)"
	typecheck "($typetc `v ($typetc $type) Literal:$littype)"
	permute
	{
		$qual(const|inarg) + 
 			$init(22|2147483647|2.200000$errid(2001))
			{
				$type(int) + $littype(Int##) + $typetc("$qual.$type"),
				$type(s32|u32) + $littype(Int32) + $typetc("$qual.$type"),
				$type(s64|u64) + $littype(Int64) + $typetc("$qual.$type"),
			},
	}

test BasicAssign
	prereq "lhs: $lhsType; rhs: $rhsType"
	input "lhs = $rvalue"
	permute
	{
		$rhsType(int|float|"&int") + $rvalue(rhs)
		{
			$lhsType("$rhsType"),
			$qual(const|inarg) + $lhsType("$qual $rhsType"$errid(2009))
		},
		$rhsType(int|float|"&int") + $lhsType("$rhsType") + $rvalue("$rhsType"$errid(2009)),
	}


test MultiDeclare
	input "a1, a2: $typeA, b1: $typeB $init"
	parse "(decl (decl `a1 `$typeA) (decl `a2 `$typeA) (decl `b1 `$typeB)$initp)"
	typecheck "(??? ($typeA `a1 $typeA) ($typeA `a2 $typeA) ($typeB `b1 $typeB)$initp)"
	permute
	{
		$typeA(float|bool|int) + $typeB(float|bool|int)
		{ 
			$init("") + $initp(""),
			$init(" = ---") + $initp(" (---)")
		}
	}	

// Operator Tests:

test MathOperators
	prereq "x: int"
	input "x $opA 3 $opB 5"
	parse "($opA `x ($opB 3 5))"
	typecheck "(int int (Literal:Int64 Literal:Int Literal:Int))"
	permute
	{
		$opA(+|-) + $opB(*|%|/)
	}

test OperatorOrder
	prereq "ick, ack, foo: int"
	input "ick $opAdd ack $opMul $opUnary(3 $opMul foo)"
	parse "($opAdd `ick ($opMul `ack (unary[$opUnary] ($opMul 3 `foo))))"
	typecheck "(int int (int int (int (int Literal:Int64 int))))"
	permute
	{
		$opAdd(+|-) + $opUnary(+|-) + $opMul(*|/|%),
	}

test OperatorRepeated
	prereq "ugh, foo, guh, ack: int"
	input "ugh $op foo $op guh $op ack"
	parse "($op ($op ($op `ugh `foo) `guh) `ack)"
	typecheck "($typeRes ($typeRes ($typeRes int int) int) int)"
	permute
	{
		$op(+|-|*|/|%|"|"|&|^|<<|>>) + $typeRes(int),
		$op("||"|&&) + $typeRes(bool)
	}

test OperatorAndOr
	prereq "ugh, foo, guh, ack: int"
	input "ugh $opHigh foo $opLow guh $opHigh ack"
	parse "($opLow ($opHigh `ugh `foo) ($opHigh `guh `ack))"
	typecheck "(bool (bool int int) (bool int int))"
	permute
	{
		$opLow("||"|&&) + $opHigh("=="|"!="),
	//	$opLow("|"|&) + $opHigh("=="|"!="|"<="|<|">="|>)
	}

test ConstantDecl
	input "SomeConst :: $value"
	parse "(const `SomeConst $pvalue)"
	typecheck "(Literal:$lit `SomeConst Literal:$lit)"
	permute
	{
		$value("\"this is a test\"") + $pvalue("\"this is a test\"") + $lit(String),
		$value(255|123123) + $pvalue("$value") + $lit(Int),
		$value(true|false) + $pvalue("$value") + $lit(Bool),
		$value(null) + $pvalue("$value") + $lit(Null),
}

// Pointers:

test PointerDecl
	input "t: $type; pT : & $type = &t"
	parse "(decl `t $ptype) (decl `pT (ptr $ptype) (unary[&] `t))"
	typecheck "($type `t $tctype) (&$type `pT (&$type $tctype) (&$type $type))"
	permute
	{
		$type(int|u8|float|bool) + $ptype("`$type") + $tctype("$type"),
		$type(&int) + $ptype("(ptr `int)") + $tctype("(&int int)")
	}

test PointerDeref
	prereq "pT : & $type"
	input "t := @pT"
	parse "(decl `t (unary[@] `pT))"
	typecheck "($type `t ($type &$type))"
	permute
	{
		$type(int|u8|float|bool|&int|&&int),
	}

// If/Else:
// Initializers:
// Structures:
test StructDecl
	input "SFoo struct { m_n $init } foo : SFoo"
	parse "(struct `SFoo ({} ($decl `m_n $initp))) (decl `foo `SFoo)"
	typecheck "(SFoo `SFoo ({} ($typememb))) (SFoo `foo SFoo)"
	permute
	{
		$init(":= 2") + $initp(2) + $decl(decl) + $typememb("int `m_n Literal:Int64"),
		$init(": int") + $initp("`int") + $decl(decl) + $typememb("int `m_n int"),
		$init(": int = 2") + $initp("`int 2") + $decl(decl) + $typememb("int `m_n int Literal:Int64"),
		$init(" :: 2") + $initp(2) + $decl(const) + $typememb("Literal:Int `m_n Literal:Int"),
	}

test StructMember
	prereq "SFoo struct { m_n : $type }; foo : SFoo; n: $type"
	input "n = foo.m_n; foo.m_n = n"
	parse "(= `n (member `foo `m_n)) (= (member `foo `m_n) `n)"
	typecheck "(= $type ($type SFoo `m_n)) (= ($type SFoo `m_n) $type)"
	permute
	{
		$type(int|"&SFoo")
	}

// Recursion:
// Enumerations:
// Arrays:

test ArrayDecl
	input "paN : & [$count] $type"
	parse "(decl `paN (ptr ([] $count `$type)))"
	typecheck "(&[$count]$type `paN (&[$count]$type ([$count]$type Literal:Int64 $type)))"
	permute
	{
		$type(s32|s8|f32|bool) + $count(1|2|1000)
	}

test ArrayAccess
	prereq "aN : [5] $type"
	input "n := aN[$index]"
	parse "(decl `n (elem `aN $index))"
	typecheck "($type `n ($type [5]$type Literal:Int64))"
	permute
	{
		$type(s32|s8|f32|bool) + $index(0|4)
	}

test ArrayAssign
	prereq "aN : [5] $type; n: $type"
	input "aN[$index] = n"
	parse "(= (elem `aN $index) `n)"
	typecheck "(= ($type [5]$type Literal:Int64) $type)"
	permute
	{
		$type(s32|s8|f32|bool) + $index(0|4)
	}

// Explicit Casts:
// Overloading:
// Operator Overloading:
// Global initialization:
// Procedures:

test ProcDef
	input "AddNums proc (a : $type, b : $type) -> $type { return a + b }"
	parse "(func `AddNums (params (decl `a `$type) (decl `b `$type)) `$type ({} (return (+ `a `b))))"
	typecheck "(AddNums($type, $type)->$type `AddNums (Params ($type `a $type) ($type `b $type)) $type ({} ($type ($type $type $type))))"
	permute
	{
		$type(int|s32|s8|f32)
	}

test ProcDefVoid
	input "DoNothing proc () $ret { }"
	parse "(func `DoNothing `void ({} (return)))"
	typecheck "(DoNothing()->void `DoNothing void ({} (void)))"
	permute
	{
		$ret(""|"-> void")
	}

test ProcCall
	prereq "AddNums proc (a : $type, b : $type) -> $type { return a + b }; i,j: $type"
	input "k := AddNums(i, j)"
	typecheck "($type `k ($type AddNums($type, $type)->$type $type $type))"
	permute
	{
		$type(int|s32|s8|f32)
	}

test ProcForeign
	input "ForeignFunc proc () -> int #foreign; ForeignFunc()"
	parse "(func `ForeignFunc `int) (procCall `ForeignFunc)"
	typecheck "(ForeignFunc()->int `ForeignFunc int) (int ForeignFunc()->int)"

test ProcVararg
	input "VarArgs proc ($args..) $ret #foreign"
	parse "(func `VarArgs (params $pargs(..)) `void)"
	typecheck "(VarArgs($argtype..)->void `VarArgs (Params $tcargs(..)) void)"
	permute
	{
		$args("") + $pargs("") + $argtype("") + $tcargs("") + $ret(""|"-> void"),
		$args("a: int, ") + $argtype("int, ") + $pargs("(decl `a `int) ") + $tcargs("(int `a int) ") + $ret(""|"-> void"),
		$args("a: int, b: int, ") + $argtype("int, int, ") + $pargs("(decl `a `int) (decl `b `int) ") + $tcargs("(int `a int) (int `b int) ") + $ret(""|"-> void"),
	}

// ProcedureRef:
test ProcRefDecl
	prereq "ReturnArg proc(v: $type) -> $type { return v }"
	input "pFn: (v: $type)->$type = ReturnArg"
	parse "(decl `pFn (procref (params (decl `v $ptype)) $ptype) `ReturnArg)"
	permute
	{
		$type(s32|f32) + $ptype("`$type"),
		$type("&u8") + $ptype("(ptr `u8)"),
		$type("const u8") + $ptype("(const `u8)"),
	}

// Casting:
test CastAssignment
	prereq "a: $typeA; b: $typeB"
	input "a = cast($typeA)$bval"
	parse "(= `a (cast $ptypeA `$bval))"	
	typecheck "(= $typeA ($typeA $tctypeA $typeB))"
	permute
	{
		$typeA(s64|f64) + $typeB(u8|s8|int|u32|f32|f64) + $ptypeA("`$typeA") + $tctypeA("$typeA") + $bval(b),
		$typeA(&int) + $typeB("&u8"|"&f32") + $ptypeA("(ptr `int)") + $tctypeA("($typeA int)") + $bval(b),	
		$typeA(s32) + $typeB(s8) + $ptypeA("`$typeA") + $tctypeA("$typeA") + $bval(int$errid(2009)),	// make sure we can't pass non-rvalue
	}

test AutoCast
	prereq "a: $typeA; b: $typeB"
	input "a = acast $bval"
	parse "(= `a (cast `$bval))"	
	typecheck "(= $typeA ($typeA $typeB))"
	permute
	{
		$typeA(s64|f64) + $typeB(u8|s8|int|u32|f32|f64) + $bval(b),
		$typeA(&int) + $typeB("&u8"|"&f32") + $bval(b),	
		$typeA(s32) + $typeB(s8) + $bval(int$errid(2009)),	// make sure we can't pass non-rvalue
	}

// Here Strings:
// For Loops:
// Break & Continue:
// Switch:


