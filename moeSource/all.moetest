
// Permute string format is a nested series of "permute" objects:
//	$perm(foo|bar)   	defines a permutation of the variable $perm with options "foo" and "bar"
//
//						option strings are separated by the '|' character and can be wrapped in quotes
//						option strings can contain substitution variables defined by any ancestor permutation
//						option strings can supply an expected error with "$errid(1234)" meaning this option must cause error #1234
// We test each permutation option against all of the permutation's children's options
// permutations options are added with '+' for a single child or curly braces for multiple comma separated child permutations

// Note: Int## is a stand in for platform specific int sizes (any ## will be replaced with 32 or 64 depending on the platform)

// [X] Document permute string format
// [ ] Finish porting tests and delete old code
// [ ] Add support for named test command line arg
// [X] Add support for built-in tests
// [X] Finish work on expected errors

// Built in tests

test builtin Lexer
test builtin Signed65
test builtin Unicode
test builtin UniqueNames

// Declaration Tests:

test DeclareAssign
	input "v : $type = $init"
	parse "(decl v $type $initp)"
	typecheck "($type v $type Literal:$littype)"
	{
		$init(2.200000$errid(2001)) + $initp("$init")
		{
			$type(int) + $littype(Int##),
			$type(s32|u32) + $littype(Int32),
			$type(s64|u64) + $littype(Int64),
		},

		$init(int$errid(2009)) + $initp("$init") + $type(int) + $littype(Int32),	// make sure we can't assign a type as an RVal

		$littype(Int8) + $type(u8|s8)
		{
			$init(2|1000$errid(2001)) + $initp("$init"),
			$init("'\\0'") + $initp(0),
			$init("'a'") +$initp(97),
		},
	}

test DeclareSigned
	input "n : s$bits = -1"
	parse "(decl n s$bits (unary[-] 1))"
	typecheck "(s$bits n s$bits (Literal:Int$bits Literal:Int))"
	{
		$bits(8|16|32|64)
	}

test DeclareHex
	input "n := $init"
	parse "(decl n $dec)"
	typecheck "(int n Literal:Int64)"
	{
		$init(0x0) + $dec(0),
		$init(0xFFFF) + $dec(65535),
		$init(0xFFFFFFFF) + $dec(4294967295),
		$init(0xFFFFFFFFFFFFFFF) + $dec(1152921504606846975)
	}

test DeclareAssignString
	input "v : $type = \"hello world\""
	parse "(decl v $ptype \"hello world\")"
	typecheck "($tctype v ($tctype ($tcinit u8)) Literal:String)"
	{
		$type(&const u8) + $ptype("(ptr (const u8))") + $tctype("&const.u8") + $tcinit(const.u8),
		$type(const&u8) + $ptype("(const (ptr u8))") + $tctype("const.&const.u8") + $tcinit(&const.u8),
	}


test QualDeclareAssign
	input "v : $qual $type = $init"
	parse "(decl v ($qual $type) $init)"
	typecheck "($typetc v ($typetc $type) Literal:$littype)"
	{
		$qual(const|inarg) + 
 			$init(22|2147483647|2.200000$errid(2001))
			{
				$type(int) + $littype(Int##) + $typetc("$qual.$type"),
				$type(s32|u32) + $littype(Int32) + $typetc("$qual.$type"),
				$type(s64|u64) + $littype(Int64) + $typetc("$qual.$type"),
			},
	}

test DeclareAssignConstExp
	input "n : $type = $exp"
	parse "(decl n $type $pexp)"
	{
		$type(s8) + $exp(2+5) + $pexp("(+ 2 5)"),
		$type(u8) + $exp(2-5) + $pexp("(- 2 5)"$errid(2001)),
		$type(s8) + $exp(200*3) + $pexp("(* 200 3)"$errid(2001)),
		$type(u16) + $exp(200*3) + $pexp("(* 200 3)"),
	}

test BasicAssign
	prereq "lhs: $lhsType; rhs: $rhsType"
	input "$lvalue = $rvalue"
	{
		$rhsType(int|float|"&int") + $lvalue(lhs) + $rvalue(rhs)
		{
			$lhsType("$rhsType"),
			$qual(const|inarg) + $lhsType("$qual $rhsType"$errid(2009))
		},
		$rhsType(int|float|"&int") + $lhsType("$rhsType") + $rvalue("$rhsType"$errid(2009)) + $lvalue(lhs) ,
		$rhsType(int|float|"&int") + $lhsType("$rhsType") + $rvalue(rhs) + $lvalue(10$errid(2009)|true$errid(2009)|null$errid(2009)),
	}


test MultiDeclare
	input "a1, a2: $typeA, b1: $typeB $init"
	parse "(decl (decl a1 $typeA) (decl a2 $typeA) (decl b1 $typeB)$initp)"
	typecheck "(??? ($typeA a1 $typeA) ($typeA a2 $typeA) ($typeB b1 $typeB)$initp)"
	{
		$typeA(float|bool|int) + $typeB(float|bool|int)
		{ 
			$init("") + $initp(""),
			$init(" = ---") + $initp(" (---)")
		}
	}	

test ConstantDecl
	input "SomeConst :: $value$extra"
	parse "(const SomeConst $pvalue)$pextra"
	typecheck "(Literal:$lit SomeConst Literal:$lit)"
	{
		$extra("") + $pextra("")
		{
			$value("\"this is a test\"") + $pvalue("\"this is a test\"") + $lit(String),
			$value(255|123123) + $pvalue("$value") + $lit(Int),
			$value(true|false) + $pvalue("$value") + $lit(Bool),
			$value(null) + $pvalue("$value") + $lit(Null),
		},

		$value(255|123123) + $pvalue("$value") + $lit(Int) + $extra("; SomeConst = 0"$errid(2009)) + $pextra(" (= SomeConst 0)"),
	}

test ConstantTypedDecl
	input "SomeConst : $type : $value"
	parse "(const SomeConst $type $value)"
	typecheck "(Literal:$lit SomeConst $type Literal:$lit)"
	{
		$type(s8) + $value(100|2000$errid(2001)) + $lit(Int8),
		$type(int) + $value(100|2000) + $lit(Int##),
		$type(u8) + $value(100|300$errid(2001)) + $lit(Int8),
	}

test DeclareShadowing
	input "ovr := 2; { ovr: float = 2.2; g := ovr} n := ovr"
	parse "(decl ovr 2) ({} (decl ovr float 2.200000) (decl g ovr)) (decl n ovr)"
	typecheck "(int ovr Literal:Int##) ({} (float ovr float Literal:Float32) (float g float)) (int n int)"
	{
	}

// Operator Tests:

test MathOperators
	prereq "x: int"
	input "x $opA 3 $opB 5"
	parse "($opA x ($opB 3 5))"
	typecheck "(int int (Literal:Int## Literal:Int Literal:Int))"
	{
		$opA(+|-) + $opB(*|%|/)
	}

test OperatorOrder
	prereq "ick, ack, foo: int"
	input "ick $opAdd ack $opMul $opUnary(3 $opMul foo)"
	parse "($opAdd ick ($opMul ack (unary[$opUnary] ($opMul 3 foo))))"
	typecheck "(int int (int int (int (int Literal:Int## int))))"
	{
		$opAdd(+|-) + $opUnary(+|-) + $opMul(*|/|%),
	}

test OperatorCompareOrder
	prereq "ack, ick, guh: int; foo: bool"
	input "f := (ick $opD ack $opC foo) $opA (123 $opB guh)"
	parse "(decl f ($opA ($opC ($opD ick ack) foo) ($opB 123 guh)))"
	typecheck "(bool f (bool (bool (bool int int) bool) (bool Literal:Int## int)))"
	{
		$opA("!="|"==") + $opB(">="|"<="|">"|"<"|"=="|"!=") + $opC("=="|"!=") + $opD(">="|"<="|">"|"<"|"!="|"==")
	}

test OperatorPrePost
	prereq "a: $type"
	input "$op a; a$op"
	parse "(unary[$op] a) (postUnary[$op] a)"
	typecheck "($type $type) ($type $type)"
	{
		$op(++|--) + $type(s8|int|&u8),
	}

test OperatorRepeated
	prereq "ugh, foo, guh, ack: int"
	input "ugh $op foo $op guh $op ack"
	parse "($op ($op ($op ugh foo) guh) ack)"
	typecheck "($typeRes ($typeRes ($typeRes int int) int) int)"
	{
		$op(+|-|*|/|%|"|"|&|^|<<|>>) + $typeRes(int),
		$op("||"|&&) + $typeRes(bool)
	}

test OperatorAndOr
	prereq "ugh, foo, guh, ack: int"
	input "ugh $opHigh foo $opLow guh $opHigh ack"
	parse "($opLow ($opHigh ugh foo) ($opHigh guh ack))"
	typecheck "(bool (bool int int) (bool int int))"
	{
		$opLow("||"|&&) + $opHigh("=="|"!="),
	//	$opLow("|"|&) + $opHigh("=="|"!="|"<="|<|">="|>)
	}

// Pointers:

test PointerDecl
	input "t: $type; pT : & $type = &t"
	parse "(decl t $ptype) (decl pT (ptr $ptype) (unary[&] t))"
	typecheck "($type t $tctype) (&$type pT (&$type $tctype) (&$type $type))"
	{
		$type(int|u8|float|bool) + $ptype("$type") + $tctype("$type"),
		$type(&int) + $ptype("(ptr int)") + $tctype("(&int int)"),
		$type([2]int) + $ptype("([] 2 int)") + $tctype("([2]int Literal:Int## int)"),
	}

test PointerDeref
	prereq "pT : & $type"
	input "t := @pT"
	parse "(decl t (unary[@] pT))"
	typecheck "($type t ($type &$type))"
	{
		$type(int|u8|float|bool|&int|&&int|[2]int),
	}

test PointerInfer
	prereq "pN : & int"
	input "a := @pN; ppN := & pN; b := @@ppN"
	parse "(decl a (unary[@] pN)) (decl ppN (unary[&] pN)) (decl b (unary[@] (unary[@] ppN)))"
	typecheck "(int a (int &int)) (&&int ppN (&&int &int)) (int b (int (&int &&int)))"
	{
	}

test PointerArayAccess
	prereq "pT: & $type"
	input "t := pT[2]"
	parse "(decl t (elem pT 2))"
	typecheck "($type t ($type &$type Literal:Int##))"
	{
		$type(int|u8|bool|&int|&&int|[2]int),
	}

// If/Else:
test IfElse
	prereq "n:s64"
	input "if $cond {n = 5} else {n = 6}"
	parse "(if $pcond ({} (= n 5)) (else ({} (= n 6))))"
	typecheck "(bool $tccond ({} (= s64 Literal:Int64)) (else ({} (= s64 Literal:Int64))))"
	{
		$cond("n") + $pcond(n) + $tccond(s64),
		$cond(0|true) + $pcond("$cond") + $tccond(Literal:Bool8),
		$cond("n == 0") + $pcond("(== n 0)") + $tccond("(bool s64 Literal:Int64)"),
	}

// Initializers:

// Structures:
test StructDecl
	input "SFoo struct { m_n $init } foo : SFoo"
	parse "(struct SFoo ({} ($decl m_n $initp))) (decl foo SFoo)"
	typecheck "(SFoo SFoo ({} ($typememb))) (SFoo foo SFoo)"
	{
		$init(":= 2") + $initp(2) + $decl(decl) + $typememb("int m_n Literal:Int##"),
		$init(": int") + $initp("int") + $decl(decl) + $typememb("int m_n int"),
		$init(": int = 2") + $initp("int 2") + $decl(decl) + $typememb("int m_n int Literal:Int##"),
		$init(": int = ---") + $initp("int (---)") + $decl(decl) + $typememb("int m_n int (---)"),
		$init(" :: 2") + $initp(2) + $decl(const) + $typememb("Literal:Int m_n Literal:Int"),
	}

test StructNesting
	input "SOuter struct { SInner struct { $nested }}"
	parse "(struct SOuter ({} (struct SInner ({} $pnested))))"
	typecheck "(SOuter SOuter ({} (SInner SInner ({} $tcnested))))"
	{
		$nested("m_f: bool") + $pnested("(decl m_f bool)") + $tcnested("(bool m_f bool)"), 
		$nested("ConstTwo :: 2") + $pnested("(const ConstTwo 2)") + $tcnested("(Literal:Int ConstTwo Literal:Int)")
	}

test StructMember
	prereq "SFoo struct { m_n : $type }; foo : SFoo; n: $type"
	input "n = foo.m_n; foo.m_n = n"
	parse "(= n (member foo m_n)) (= (member foo m_n) n)"
	typecheck "(= $type ($type SFoo m_n)) (= ($type SFoo m_n) $type)"
	{
		$type(int|"&SFoo")
	}

test StructMemberPointer
	prereq "SFoo struct { m_n : $type }; pFoo : & SFoo; n: $type"
	input "n = pFoo.m_n; pFoo.m_n = n"
	parse "(= n (member pFoo m_n)) (= (member pFoo m_n) n)"
	typecheck "(= $type ($type &SFoo m_n)) (= ($type &SFoo m_n) $type)"
	{
		$type(int|"&SFoo")
	}

// Enumerations:

test EnumDecl
	input "ENUMK enum $loose { Ick : 1, Foo, Bah : 3 }"
	parse "(enum ENUMK $loose({} (enumConst nil) (enumConst min) (enumConst last) (enumConst max) (arrayLit names) (arrayLit values) (enumConst Ick 1) (enumConst Foo) (enumConst Bah 3)))"
	typecheck "(ENUMK_enum ENUMK $loose({} (ENUMK_enum Literal:Enum nil) (ENUMK_enum Literal:Enum min) (ENUMK_enum Literal:Enum last) (ENUMK_enum Literal:Enum max) (Literal:Array names (Literal:Array Literal:String Literal:String Literal:String)) (Literal:Array values (Literal:Array Literal:$litk Literal:$litk Literal:$litk)) (ENUMK_enum Literal:Enum Ick Literal:Int) (ENUMK_enum Literal:Enum Foo) (ENUMK_enum Literal:Enum Bah Literal:Int)))"
	{
		$loose("") + $litk("Int8"),
		$loose("s32 ") + $litk("Int32"),
		$loose("s8 ") + $litk("Int8"),
	}

test EnumSubtypes
	prereq "ENUMK enum $loose { Ick : 1, Foo, Bah : 3 }"
	input "t: ENUMK.$subtype"
	parse "(decl t (member ENUMK $subtype))"
	typecheck "($tctype t ($tctype ENUMK_enum $tctype))"
	{
		$loose("") + $ltype(u8)
		{
			$subtype(loose) + $tctype("$ltype"),
			$subtype(strict) + $tctype(ENUMK_enum),
		},

		$loose(s32|s64|u32) + $ltype("$loose")
		{
			$subtype(loose) + $tctype("$ltype"),
			$subtype(strict) + $tctype(ENUMK_enum),
		}
	}

test EnumBadInit
	input "ENUMK enum $loose { Ick : 1, Foo, Bah : $init }"
	{
		$loose(u8) + $init(300$errid(2001)),
		$loose(u64) + $init(-3$errid(2001)),
	}

test EnumImplicitMembers
	prereq "ENUMK enum $loose { Ick : 1, Foo, Bah : 3 }"
	input "t := ENUMK.$memb$extra"
	parse "(decl t (member $pmemb))"	
	typecheck "($tctype t ($tcinit))"
	{
		$memb(min|max|nil) + $extra("") + $tctype(ENUMK_enum) + $pmemb("ENUMK $memb")
		{
			$loose(s8) + $lit("Int8") + $tcinit("Literal:$lit ENUMK_enum $memb"),
			$loose(u64) + $lit("Int64") + $tcinit("Literal:$lit ENUMK_enum $memb"),
		},
		$loose(s8)
		{
			$memb(names)
			{
				$extra("") + $tctype("[3]&u8") + $pmemb("ENUMK $memb") + $lit(Array) + $tcinit("Literal:$lit ENUMK_enum $memb"),
				$extra(".count") + $tctype("int") + $pmemb("(member ENUMK $memb) count") + $tcinit("Literal:Int64 (Literal:Array ENUMK_enum $memb) count"),
				$extra(".data") + $tctype("&&u8") + $pmemb("(member ENUMK $memb) data") + $tcinit("$tctype (Literal:Array ENUMK_enum $memb) data"),
			},
			$memb(values)
			{
				$extra("") + $tctype("[3]s8") + $pmemb("ENUMK $memb") + $lit(Array) + $tcinit("Literal:$lit ENUMK_enum $memb"),
				$extra(".count") + $tctype("int") + $pmemb("(member ENUMK $memb) count") + $tcinit("Literal:Int64 (Literal:Array ENUMK_enum $memb) count"),
				$extra(".data") + $tctype("&s8") + $pmemb("(member ENUMK $memb) data") + $tcinit("$tctype (Literal:Array ENUMK_enum $memb) data"),
			},
		},
	}

// Arrays:

test ArrayDecl
	input "paN : & [$count] $type"
	parse "(decl paN (ptr ([] $count $type)))"
	typecheck "(&[$count]$type paN (&[$count]$type ([$count]$type Literal:Int## $type)))"
	{
		$type(s32|s8|f32|bool) + $count(1|2|1000)
	}

test ArrayAccess
	prereq "aN : [5] $type"
	input "n := aN[$index]"
	parse "(decl n (elem aN $index))"
	typecheck "($type n ($type [5]$type Literal:Int##))"
	{
		$type(s32|s8|f32|bool) + $index(0|4),
		$type(s32) + $index(2.200000$errid(2010)),
	}

test ArrayAssign
	prereq "aN : [5] $type; n: $type"
	input "aN[$index] = n"
	parse "(= (elem aN $index) n)"
	typecheck "(= ($type [5]$type Literal:Int##) $type)"
	{
		$type(s32|s8|f32|bool) + $index(0|4)
	}

test ArrayRefAssign
	prereq "aN : [2] int"
	input "aNRef : [] int = aN"
	parse "(decl aNRef ([] int) aN)"
	typecheck "([]int aNRef ([]int int) [2]int)"

test ArrrayConstants
	prereq "aN : [3] int"
	input "n := aN.$arymemb"
	parse "(decl n (member aN $arymemb))"
	typecheck "($tctype n ($tcinit [3]int $arymemb))"
	{
		$arymemb(count) + $tctype(int) + $tcinit(Literal:Int##),
		$arymemb(data) + $tctype(&int) + $tcinit(&int),
	}

test ArrrayConstantsAreConst
	prereq "aN : [3] int"
	input "aN.$arymemb = $init"
	parse "(= (member aN $arymemb) $init)"
	{
		$arymemb(count$errid(2009)) + $init(2),
		// $arymemb(data$errid(2009)) + $init(null),	- TODO: think about what to do here, aN must be mutable because it points at mutable data - inarg maybe?
	}

test ArrayToPointer
	prereq "aT : [3] $type"
	input "pT: & $type = aT"
	parse "(decl pT (ptr $ptype) aT)"
	typecheck "(&$type pT (&$type $tctype) [3]$type)"
	{
		$type(int|bool) + $ptype("$type") + $tctype("$type"),
		$type("&int") + $ptype("(ptr int)") + $tctype("(&int int)"),
	}

test ArrayLiteral
	input "aN $tdecl {$tspec 1, 2, 3}"
	parse "(decl aN $ptdecl(arrayLit $elemspec({} 1 2 3)))"
	typecheck "([3]$elemtype aN $tcdecl(Literal:Array $elemspec({} Literal:$lit Literal:$lit Literal:$lit)))"
	{
		$tdecl(": [3] s16 = ") + $ptdecl("([] 3 s16) ") + $tcdecl("([3]s16 Literal:Int64 s16) ") + $elemtype(s16)
		{
			$tspec(":$elemtype:") + $elemspec("$elemtype ") + $lit(Int16),
		},
		$tdecl(": [3] int = ") + $ptdecl("([] 3 int) ") + $tcdecl("([3]int Literal:Int64 int) ") + $elemtype(int) + $lit("Int64")
		{
			$tspec("") + $elemspec(""),
			$tspec(":$elemtype:") + $elemspec("$elemtype "),
		},
		$tdecl(":=") + $ptdecl("") + $tcdecl("") + $elemtype(int) + $lit("Int64")
		{
			$tspec("") + $elemspec(""),
			$tspec(":$elemtype:") + $elemspec("$elemtype "),
		},
	}

test ArrayLiteralConst
	input "aN :: {$tspec 1, 2, 3}"
	parse "(const aN (arrayLit $elemspec({} 1 2 3)))"
	typecheck "(Literal:Array aN (Literal:Array $elemspec({} Literal:Int Literal:Int Literal:Int)))"
	{
		$elemtype(int|s8) + $lit("Int")
		{
			$tspec("") + $elemspec(""),
			$tspec(":$elemtype:") + $elemspec("$elemtype "),
		},
	}

// Casting:

test CastAssignment
	prereq "a: $typeA; b: $typeB"
	input "a = cast($typeA)$bval"
	parse "(= a (cast $ptypeA $bval))"	
	typecheck "(= $typeA ($typeA $tctypeA $typeB))"
	{
		$typeA(s64|f64) + $typeB(u8|s8|int|u32|f32|f64) + $ptypeA("$typeA") + $tctypeA("$typeA") + $bval(b),
		$typeA(&int) + $typeB("&u8"|"&f32") + $ptypeA("(ptr int)") + $tctypeA("($typeA int)") + $bval(b),	
		$typeA(s32) + $typeB(s8) + $ptypeA("$typeA") + $tctypeA("$typeA") + $bval(int$errid(2009)),	// make sure we can't pass non-rvalue
	}

test AutoCast
	prereq "a: $typeA; b: $typeB"
	input "a = acast $bval"
	parse "(= a (cast $bval))"	
	typecheck "(= $typeA ($typeA $typeB))"
	{
		$typeA(s64|f64) + $typeB(u8|s8|int|u32|f32|f64) + $bval(b),
		$typeA(&int) + $typeB("&u8"|"&f32") + $bval(b),	
		$typeA(s32) + $typeB(s8) + $bval(int$errid(2009)),	// make sure we can't pass non-rvalue
	}

// Overloading:
test Overloading
	prereq "Ovr proc(a: $typeA)->$typeA { return a } Ovr proc(b: $typeB)->$typeB { return b }"
	input "a: $typeA, b: $typeB; Ovr(a); Ovr(b)"
	typecheck "(??? ($typeA a $typeA) ($typeB b $typeBInit)) ($typeA Ovr($typeA)->$typeA $typeA) ($typeB Ovr($typeB)->$typeB $typeB)"
	{
		$typeA(int|s8) + $typeB(float|double) + $typeBInit("$typeB"),
		$typeA(int|s8|float) + $typeBRef(int|float) + $typeB("&$typeBRef") + $typeBInit("($typeB $typeBRef)"),
	}

test OverloadLiteral
	prereq "Ovr proc(a: $typeA)->$typeA { return a } Ovr proc(b: $typeB)->$typeB { return b }"
	input "Ovr($argA); Ovr($argB)"
	typecheck "($typeA Ovr($typeA)->$typeA $litA) ($tctypeB Ovr($tctypeB)->$tctypeB $litB)"
	{
		$typeA(int) + $argA(245) + $litA("Literal:Int64") + $typeB(float) + $argB("2.45") + $litB("Literal:Float32") + $tctypeB("$typeB"),
		$typeA(int) + $argA(245) + $litA("Literal:Int64") + $typeB(bool) + $argB("true") + $litB("Literal:Bool8") + $tctypeB("$typeB"),
		$typeA(bool) + $argA(true) + $litA("Literal:Bool8") + $typeB("&const u8") + $argB("\"hello\"") + $litB("Literal:String") + $tctypeB("&const.u8"),

		// ambiguous overloads
		$typeA(s8) + $argA(18) + $litA("Literal:Int8") + $typeB(s16) + $argB("-322") + $litB("Literal:Int16") + $tctypeB("$typeB"$errid(2012)),
		$typeA(s16) + $argA(245) + $litA("Literal:Int16") + $typeB(double) + $argB("2.45") + $litB("Literal:Float64")+ $tctypeB("$typeB"$errid(2012)),
	}

// Operator Overloading:
test BinaryCommutativeOpOverload
	prereq "SFoo struct { m_n: int } fooA: SFoo; g: float"
	input "operator $op(lhs:SFoo, rhs:float)->int #commutative {return 1} n := fooA $op g; n = g $op fooA"
	typecheck "(operator$op(SFoo, float)->int operator$op (Params (SFoo lhs SFoo) (float rhs float)) int ({} (int Literal:Int64))) (int n (int SFoo float)) (= int (int float SFoo))"
	{
		$op(+|-|*|/|"|"|"&"|"^"),
	}

test BinaryOpNonCommutativeOverload
	prereq "SFoo struct { m_n: int } fooA, fooB: SFoo"
	input "operator $op(lhs:SFoo, rhs:SFoo)->int {return 1} n := fooA $op fooB"
	typecheck "(operator$op(SFoo, SFoo)->int operator$op (Params (SFoo lhs SFoo) (SFoo rhs SFoo)) int ({} (int Literal:Int64))) (int n (int SFoo SFoo))"
	{
		$op(">>"|"<<"),
	}

test BinaryOpOverloadErrors 
	prereq "SFoo struct { m_n: int } fooA, fooB: SFoo"
	input "operator $op(lhs:SFoo, rhs:SFoo)->int {return 1}"
	typecheck "(operator$op(SFoo, SFoo)->int operator$op (Params (SFoo lhs SFoo) (SFoo rhs SFoo)) int ({} (int Literal:Int64)))"
	{
		// seperate error test so we can split errors for defining a bad overload, and errors from calling a non-existent overload

		$op("="$errid(2013)),
		//$op("?"$errid(1003))
	}

test PrefixUnaryOpOverload
	prereq "SFoo struct { m_n: int } fooA: SFoo"
	input "operator $op(lhs:SFoo)->int {return 1} n := $op fooA"
	typecheck "(operator$op(SFoo)->int operator$op (Params (SFoo lhs SFoo)) int ({} (int Literal:Int64))) (int n (int SFoo))"
	{
		$op("-"|"+"|"!"|"~"|"@"|"&")
	}

test PostfixUnaryOpOverload
	prereq "SFoo struct { m_n: int } fooA: SFoo"
	input "operator $op(lhs:&SFoo)->SFoo {return @lhs} fooA $op"
	typecheck "(operator$op(&SFoo)->SFoo operator$op (Params (&SFoo lhs (&SFoo SFoo))) SFoo ({} (SFoo (SFoo &SFoo)))) (SFoo SFoo)"
	{
		$op("++"|"--")
	}

test RelationalOpOverload
	prereq "SFoo struct { m_n: int } fooA, fooB: SFoo"
	input "operator $op(lhs:SFoo, rhs:SFoo)->bool {return true} f := fooA $op fooB"
	typecheck "(operator$op(SFoo, SFoo)->bool operator$op (Params (SFoo lhs SFoo) (SFoo rhs SFoo)) bool ({} (bool Literal:Bool8))) (bool f (bool SFoo SFoo))"
	{
		$op("<"|"<="|">"|">="),
		$op("=="|"!=")
	}

test AssignmentOpOverload
	prereq "SFoo struct { m_n: int } fooA, fooB: SFoo"
	input "operator $op(pLhs:&SFoo, rhs:SFoo) {} fooA $op fooB"
	typecheck "(operator$op(&SFoo, SFoo)->void operator$op (Params (&SFoo pLhs (&SFoo SFoo)) (SFoo rhs SFoo)) void ({} (void))) (= SFoo SFoo)"
	{
		$op("="|"+="|"-="|"*="|"/=")
	}

test DeclOpOverload
	prereq "SFoo struct { m_n: int } fooA: SFoo"
	input "operator $op(pLhs:&SFoo, rhs:SFoo) {} fooB $op fooA"
	typecheck "(operator$op(&SFoo, SFoo)->void operator$op (Params (&SFoo pLhs (&SFoo SFoo)) (SFoo rhs SFoo)) void ({} (void))) (SFoo fooB SFoo)"
	{
		$op(":=")
	}
	
// Procedures:

test ProcDef
	input "AddNums proc (a : $type, b : $type) -> $type { return a + b }"
	parse "(func AddNums (params (decl a $type) (decl b $type)) $type ({} (return (+ a b))))"
	typecheck "(AddNums($type, $type)->$type AddNums (Params ($type a $type) ($type b $type)) $type ({} ($type ($type $type $type))))"
	{
		$type(int|s32|s8|f32)
	}

test ProcArgs
	prereq "SFoo struct { m_n: int }"
	input "ParamFunc proc (a : $typeA, b : $typeB) { a2 := a; b2 := b }"
	parse "(func ParamFunc (params (decl a $typeA) (decl b (ptr $ptypeB))) void ({} (decl a2 a) (decl b2 b) (return)))"
	typecheck "(ParamFunc($typeA, $typeB)->void ParamFunc (Params ($typeA a $typeA) ($typeB b ($typeB $ptypeB))) void ({} ($typeA a2 $typeA) ($typeB b2 $typeB) (void)))"
	
	{
		$typeA(int|s8|float|SFoo) + $ptypeB(int|s8|float|SFoo) + $typeB("&$ptypeB")
	}

test ProcDefVoid
	input "DoNothing proc () $ret { $optRet }"
	parse "(func DoNothing void ({} (return)))"
	typecheck "(DoNothing()->void DoNothing void ({} (void)))"
	{
		$ret(""|"-> void") + $optRet(""|return)
	}

test ProcCall
	prereq "AddNums proc (a : $type, b : $type) -> $type { return a + b }; i,j: $type"
	input "k := AddNums($args)"
	typecheck "($type k ($type AddNums($type, $type)->$type $type $type))"
	{
		$type(int|s32|s8|f32) + $args("i, j"),
		$type(s32) + $args("i"$errid(2002)|"i,i,i"$errid(2003)|"&i, &i"$errid(2006)),
	}

test ProcCallIsRval
	prereq "ReturnInt proc () -> $type { return 2 }"
	input "ReturnInt() = 2"
	{
		$type(int$errid(2009))
	}

test ProcSelfRef
	input "SelfRef proc () { pFn := SelfRef }"
	parse "(func SelfRef void ({} (decl pFn SelfRef) (return)))"
	typecheck "(SelfRef()->void SelfRef void ({} (SelfRef()->void pFn SelfRef()->void) (void)))" 	

test ProcForeign
	input "ForeignFunc proc () -> int #foreign; ForeignFunc()"
	parse "(func ForeignFunc int) (procCall ForeignFunc)"
	typecheck "(ForeignFunc()->int ForeignFunc int) (int ForeignFunc()->int)"

test ProcVararg
	input "VarArgs proc ($args..) $ret #foreign"
	parse "(func VarArgs (params $pargs(..)) void)"
	typecheck "(VarArgs($argtype..)->void VarArgs (Params $tcargs(..)) void)"
	{
		$args("") + $pargs("") + $argtype("") + $tcargs("") + $ret(""|"-> void"),
		$args("a: int, ") + $argtype("int, ") + $pargs("(decl a int) ") + $tcargs("(int a int) ") + $ret(""|"-> void"),
		$args("a: int, b: int, ") + $argtype("int, int, ") + $pargs("(decl a int) (decl b int) ") + $tcargs("(int a int) (int b int) ") + $ret(""|"-> void"),
	}

test ProcRecurse
	input "foo proc () { foo() }"
	parse "(func foo void ({} (procCall foo) (return)))"
	typecheck "(foo()->void foo void ({} (void foo()->void) (void)))"

// ProcedureRef:
test ProcRefDecl
	prereq "ReturnArg proc(v: $type) -> $type { return v }"
	input "pFn: (v: $type)->$type = ReturnArg"
	parse "(decl pFn (procref (params (decl v $ptype)) $ptype) ReturnArg)"
	{
		$type(s32|f32) + $ptype("$type"),
		$type("&u8") + $ptype("(ptr u8)"),
		$type("const u8") + $ptype("(const u8)"),
	}

test ProcRefCall
	prereq "Somefunc proc(n: int) { }"
	input "pFn := Somefunc; pFn(2)"
	parse "(decl pFn Somefunc) (procCall pFn 2)"
	typecheck "(Somefunc(int)->void pFn Somefunc(int)->void) (void Somefunc(int)->void Literal:Int##)"

test ProcRefRefCall
	prereq "Somefunc proc(n: int) { }"
	input "ppFn := &Somefunc; (@ppFn)(2)"
	parse "(decl ppFn (unary[&] Somefunc)) (procCall (unary[@] ppFn) 2)"
	typecheck "(&Somefunc(int)->void ppFn (&Somefunc(int)->void Somefunc(int)->void)) (void (Somefunc(int)->void &Somefunc(int)->void) Literal:Int##)"

test ProcRefArray
	input "apFn: [$atype] (n: s32)$ret;   apFn[1](33)"
	parse "(decl apFn ([] $patype(procref (params (decl n s32)) $type))) (procCall (elem apFn 1) 33)"
	typecheck "([$atype](s32)->$type apFn ([$atype](s32)->$type $tcatype((s32)->$type (Params (s32 n s32)) $type))) ($type ((s32)->$type [$atype](s32)->$type Literal:Int64) Literal:Int32)"
	{
		$ret("") + $type(void)
		{
			$atype(4) + $patype("4 ") + $tcatype("Literal:Int64 "),
			$atype("") + $patype("") + $tcatype(""),
			$atype(..$errid(2011)) + $patype("") + $tcatype(""),
		},
		$ret("->int") + $type(int)
		{
			$atype(4) + $patype("4 ") + $tcatype("Literal:Int64 "),
			$atype("") + $patype("") + $tcatype(""),
			$atype(..$errid(2011)) + $patype("") + $tcatype(""),
		},
	}

// Strings:
test StringLliteral
		input "pChz $decl \"hello\""
		parse "(decl pChz $pdecl\"hello\")"
		typecheck "(&const.u8 pChz $tcdecl)"
		{
			$decl(":=") + $pdecl("") + $tcdecl(Literal:String),
			$decl(": &const u8 =") + $pdecl("(ptr (const u8)) ") + $tcdecl("(&const.u8 (const.u8 u8)) Literal:String")
		}

test HereString
	// UGH! these are so fragile, the first string delimeter needs to end a line and the second delimiter needs to be on it's own line
	input "g_pChz :: #string END\nmultiline\n test string \"with quotes\"\nEND"
	parse "(const g_pChz \"multiline\n test string \"with quotes\"\n\")"
	typecheck "(Literal:String g_pChz Literal:String)"
	{
	}


// For Loops:

test ForLoopBasic
	prereq "cLoop :: 5; n:s64 = 2"
	input "for i:=0; $cond; ++i; { --n }"
	parse "(for (decl i 0) $pcond (unary[++] i) ({} (unary[--] n)))"
	typecheck "(for (int i Literal:Int64) $tccond (int int) ({} (s64 s64)))"
	{
		$cond("i<cLoop") + $pcond("(< i cLoop)") + $tccond("(bool int Literal:Int64)"),
		$cond(i) + $pcond(i) + $tccond(int),
		$cond(true) + $pcond(true) + $tccond("Literal:Bool8")
	}

// Loops:

test WhileLoop
	prereq "n:s64 = 5"
	input "while $cond { --n }"
	parse "(while $pcond ({} (unary[--] n)))"
	typecheck "(bool $tccond ({} (s64 s64)))"
	{
		$cond(n) + $pcond(n) + $tccond(s64),
		$cond(n >= 0) + $pcond("(>= n 0)") + $tccond("(bool s64 Literal:Int64)")
	}

// Break & Continue:

test BreakContinue
	prereq "n:s64 = 5"
	input "while $cond { $jump }"
	parse "(while $cond ({} ($jump)))"
	typecheck "(bool $tccond ({} ($jump)))"
	{
		$cond(true|1) + $jump(break|continue) + $tccond(Literal:Bool8),
		$cond(n) + $jump(break|continue) + $tccond(s64)
	}

test BreakContinueLabel
	prereq "n:s64 = 5"
	input "#label $label while $cond { $jump $label}"
	parse "(while $cond ({} ($jump)))"
	typecheck "(bool $tccond ({} ($jump)))"
	{
		$cond(true|1) + $jump(break|continue) + $tccond(Literal:Bool8) + $label(ack|ick),
		$cond(n) + $jump(break|continue) + $tccond(s64) + $label(ack|ick)
	}

// Switch:

test EmptyCase
	prereq "n: s32"
	input "switch n {$cond: $statement}"
	{
		$cond("case 1"|"case 1, 2"|default)
		{
			$statement(""$errid(1005)),
			$statement("n = 2")
		},
	}

// Unicode
test UnicodeIdent
	input "$name := 5"
	parse "(decl $name 5)"
	{
		$name("😁✂"|"エヌマ"|"Übengrößeren"|"Γαζέες")
	}

//test Typeof
//	prereq "SFoo struct { m_n: int }"
//	input "x: $type; tin := typeof(x)"
//	parse "()"
//	{
//		$type(int|float|bool|SFoo|&int|&sFoo)
//	}

