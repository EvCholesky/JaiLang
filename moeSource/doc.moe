#import "Basic"
#import "Color"
#import "Font"
#import "GL"
#import "Math"
#import "Smooth"

// Ideas:
// Each player has a color
// gems change which player you send garbage to
// garbage queues (with a color indicator) at the top
// Clocks slow down your fall rate, and send a speed up clock to your target - they last until the speed up clock is gone (or either clock?) 
// Need some kind of powerup to deal with vertical walls - a vertical column destroyer? something to push sideways? a magnet?

// orig: 64x128 px, 8x8 cells, 8x16 playspace

kDXWindow :: 1280
kDYWindow :: 720
//kDXWindow :: 1920
//kDYWindow :: 1080

kDXCellBoard :: 8
kDYCellBoard :: 17
kDYCellBoardVisible :: 16 // the last row is only for overflow off the top, shouldn't draw (unless occupied)
kBoardBorderWidth :: 10
kDYBoardBorderBottom :: 54

kCCellPerBoard :: kDXCellBoard * kDYCellBoard
kEntMax :: kCCellPerBoard * kCPlayerMax
kYMaxVirusStart :: 12

kDTStartingSpawn :: 1
kDTNextPill	:: 0.20
kDTShowDead :: 0.2
kDTStabilize :: 0.05

kDTEndgameMin :: 1.5

kDTPulseTotal :: 1.5
kDTPulseBell :: 0.25

kDTPulseBellStabilize :: 0.45

g_fApplyGravity := true	// debug toggle for falling pieces

kCVirusStarting :: 15
//kCVirusStarting :: 2

kCPlayerMax :: 4

g_cTickPerSecond: s64 = 1

Syst typedef f64
g_systCur: f64
g_rng: SRandomGen

PILLCOL enum u8
{
	Red,
	Blue,
	Yellow,
	MaxPills,
	Green 		:= MaxPills,	// extra color to allow for four player backgrounds
}

PILLSPEED enum u8
{
	Slow,
	Medium,
	Fast,
}

DIR enum u8
{
	Left,
	Up,
	Right,
	Down
}

ColFromPillcol proc (pillcol: PILLCOL) -> SColor
{
	switch pillcol
	{
		case PILLCOL.Red:	 	return ColCreate(231, 0, 90, 255)
		case PILLCOL.Blue:		return ColCreate(57, 189, 255, 255)
		case PILLCOL.Yellow:	return ColCreate(255, 189, 0, 255)
		case PILLCOL.Green:		return ColCreate(57, 255, 189, 255)
	}
	return ColCreate (255, 255, 255, 255)
}

STileVertex struct // tag=tilvert
{
	m_x, m_y: f32
	m_u, m_v: f32
	m_r, m_g, m_b, m_a: f32
}

STileVertexBuffer struct // tag=tilbuf
{
	m_aTilvert: [4096] STileVertex
	m_cTilvert: int
}
g_tilbuf: STileVertexBuffer

BUTK enum // button kind
{
	Up,
	Down,
	Left,
	Right,
	RotateClock,
	RotateCClock,
	RotateClockAlt,		// BB - once we have struct literals this should go away, replace mpButkKeycode with a pair map
	RotateCClockAlt,
	Select,
	Cancel,
}

SPlayerInput struct // tag = playinp
{
	m_mpButkEdges: [BUTK.max] EDGES
	m_pPadmap: & SGamepadMap
	m_nDeviceId: s32 = -1
}

SGamepadMapData	struct // tag = padmapd
{
	m_mpButkKeycode: & KEYCODE
	m_pChzJoystickName: & u8		// joystick name reported by GLFW
}

SGamepadMap	struct	// tag = padmap
{
	m_nDeviceId: s32				// gamepad index as reported by Gllib
	m_pPadmapd: & SGamepadMapData
}

GAMRES enum // GAMe RESult
{
	Pending,
	WinMin,
	WinClearedAll		:= WinMin,
	WinLastStanding,
	WinMax,

	LoseMin				:= WinMax,
	LoseOverflow		:= LoseMin,
	LoseTooSlow,
	LoseMax,
}

PLAYS enum s8 // PLAYer State
{
	Inactive,
	PregameOptions,
	PregameReady,
	InGame,
	PostGame,
}

FPLAY enum u8
{
	Autokill		:= 0x1,		// pills are killed as soon as they stabilize, used to test n players. Can't win, can't spawn garbage.
}

GAMS enum s8 // GAMe State
{
	Pregame,
	InGame,
	PostGame,
}

SPlayer struct // tag = play
{
	m_plays := PLAYS.nil
	m_gamres := GAMRES.nil
	m_grfplay: FPLAY.loose
	m_pillcol: PILLCOL
	m_pillcolNextHead: PILLCOL
	m_pillcolNextTail: PILLCOL
	m_iPlayerTarget: int						// player that will receive this player's garbage
	m_iStartingLevel := 5						// starting virus count is (m_iStartingLeve + 1)*4
	m_playinp: SPlayerInput
	m_pillspeed: PILLSPEED

	m_mpIplayCGarbagePending: [kCPlayerMax] int	// how much garbage is pending from each player
	m_cKills: int

	m_dTUntilSpawn : f32 = kDTStartingSpawn 	// nothing was falling last update, spawn a new pill
	m_dTRepeatHold : f32 = -1
	m_dTStepDown : f32
	m_pEntSteer : & SEntity						// falling entity controlled by this player

	m_cKilledCells: int
	m_cGarbageSent: int
	m_cGarbageReceived: int
	m_cErrors: int
	m_dTHoldDown: f32
}

SGame struct // tag = game
{
	m_aEnt : [kEntMax] SEntity
	m_pEntUnusedFirst: & SEntity		// list of unused entities

	m_aBoard: [kCPlayerMax] SBoard	

	m_aPadmapd: [kCPlayerMax] SGamepadMapData
	m_aPadmap: [kCPlayerMax] SGamepadMap
	m_cPadmapd: int
	m_cPadmap: int

	m_gams := GAMS.nil
	m_dTGams : f32 						// Time in this game state
	m_cPlay:= 2
	m_aPlay: [kCPlayerMax] SPlayer
}
g_game: SGame

SBoard struct
{
	m_dXyTile: s32x2	// pixel dims of each tile
	m_dXyBoard: s32x2	// total dims of the map
	m_gTileSpacing: f32
	m_pos: s32x2 		// lower left of the board

	m_iBoard: s32
	m_nRngSeed: u32	= 0x1234BEEF //0xBADDBEEF
	m_rng: SRandomGen
	m_mpIcellPEnt: [kCCellPerBoard] & SEntity
}

ENTK enum s8 // ENTity Kind
{
	None,
	Pill,
	Virus,
	Garbage,
	Gem,
}

ENTS enum s8 // ENTity State
{
	Falling,
	Stable,
	Dead,
}

SEntity struct // tag = ent
{
	m_entk: ENTK
	m_ents: ENTS
	m_dTEnts: f32				// time in this state

	m_pos: f32x2				// pixel position
	m_posSmooth: f32x2
	m_radSmooth: f32
	m_pillcol: PILLCOL
	m_pillcolTail: PILLCOL		// other pill color (cause pills are one entity but two colors)
	m_dir:= DIR.Right 			// direction from pill head to tail
	m_dTPulse := 0.0
	m_dTStabilize := 0.0		// time since landing, before stabilizing (for ground sliding)

	m_iBoard	: s32 = -1
	m_iCellParent : s32 = -1	// board cell this entity is parented to
	m_iCellParentTail : s32 = -1

	m_pEntUnusedNext: & SEntity

	m_fHasTail := true			// NOTE: pills should never have a tail but no head!
}

InitPlayers proc (pGame: & SGame)
{
	for iPlay := 0; iPlay < pGame.m_aPlay.count; ++iPlay
	{
		pPlay := &pGame.m_aPlay[iPlay]
		pBoard := &pGame.m_aBoard[iPlay]
		if pPlay.m_plays == PLAYS.nil
		{
			SetPlays(pPlay, PLAYS.Inactive)
		}

		pPlay.m_pEntSteer = null
		pPlay.m_pillcol = cast(PILLCOL)iPlay
		pPlay.m_iPlayerTarget = (iPlay + 1) % pGame.m_cPlay
		pPlay.m_dTUntilSpawn = kDTStartingSpawn

		pPlay.m_cKilledCells = 0
		pPlay.m_cGarbageSent = 0
		pPlay.m_cGarbageReceived = 0
		pPlay.m_cErrors = 0
		pPlay.m_dTHoldDown = 0

		pPlay.m_pillcolNextHead = cast(PILLCOL)NRandom(&pBoard.m_rng, PILLCOL.min, PILLCOL.MaxPills)
		pPlay.m_pillcolNextTail = cast(PILLCOL)NRandom(&pBoard.m_rng, PILLCOL.min, PILLCOL.MaxPills)

		SetGamres(pPlay, GAMRES.Pending)

		if (pPlay.m_grfplay & FPLAY.Autokill) != 0
		{
	    	SetPlays(pPlay, PLAYS.Inactive)	
		}
    	else if pPlay.m_plays != PLAYS.Inactive
    	{
	    	SetPlays(pPlay, PLAYS.PregameOptions)	
	    }
	}
}

PosFromCell proc (pBoard: & SBoard, xCell: int, yCell: int) -> f32x2 
{
	// should this include board origin?
	return F32x2Create(cast(f32)(xCell * pBoard.m_dXyTile.m_x),  cast(f32)(yCell * pBoard.m_dXyTile.m_y))
}

InitUnusedEntList proc (aEntAll: [] SEntity, ppEntFirst: && SEntity)
{
	ppEntPrev := ppEntFirst
	for iEnt:= 0; iEnt < aEntAll.count; ++iEnt
	{
		pEnt := &aEntAll[iEnt]
		@ppEntPrev = pEnt
		ppEntPrev = &pEnt.m_pEntUnusedNext
	}

	@ppEntPrev = null
}

PEntAllocate proc (ppEntFirst: && SEntity, entk: ENTK) -> & SEntity
{
	if (!ppEntFirst || !@ppEntFirst)
		{ return null }

	pEnt := @ppEntFirst
	pEnt.m_fHasTail = false
	pEnt.m_pillcolTail = PILLCOL.nil
	pEnt.m_dir = DIR.Right
	pEnt.m_dTPulse = 0
	pEnt.m_dTStabilize = 0

	@ppEntFirst = pEnt.m_pEntUnusedNext

	pEnt.m_pEntUnusedNext = null
	pEnt.m_entk = entk
	pEnt.m_ents = ENTS.Stable
	return pEnt
}

FreeEntity proc (pGame: & SGame, ppEntFirst: && SEntity, pEnt: & SEntity)
{
	if !fverify(pEnt.m_pEntUnusedNext == null, "freeing entity that is already unused", #file, #line)
		{ return }

	if fverify(pEnt.m_iBoard >= 0, "bad board", #file, #line)
	{
		assert(pEnt.m_iCellParent >= 0, "partially parented entity", #file, #line)
		pBoard := &pGame.m_aBoard[pEnt.m_iBoard]

		UnparentBoardEntity(pBoard, pEnt)
		//assert(pBoard.m_mpIcellPEnt[pEnt.m_iCellParent] == pEntj, "bad entity parenting")
		//pBoard.m_mpIcellPEnt[pEnt.m_iCellParent] = null
	}

	pEnt.m_iBoard = -1

	pEnt.m_pEntUnusedNext = @ppEntFirst
	@ppEntFirst = pEnt
}

PosCell proc (pBoard: & SBoard, pos: f32x2) -> s32x2
{
	//xCell := NFloor(pos.m_x / cast(f32)pBoard.m_dXyTile.m_x)
	//yCell := NFloor(pos.m_y / cast(f32)pBoard.m_dXyTile.m_y)
	xCell := NRound(pos.m_x) / pBoard.m_dXyTile.m_x
	yCell := NRound(pos.m_y) / pBoard.m_dXyTile.m_y
	return S32x2Create(xCell, yCell)
}

ICellFromPos proc (pBoard: & SBoard, pos: f32x2) -> s32
{
	//xCell := NFloor(pos.m_x / cast(f32)pBoard.m_dXyTile.m_x)
	//yCell := NFloor(pos.m_y / cast(f32)pBoard.m_dXyTile.m_y)
	xCell := NRound(pos.m_x) / pBoard.m_dXyTile.m_x
	yCell := NRound(pos.m_y) / pBoard.m_dXyTile.m_y
	return ICell(xCell, yCell)
}

ICell proc (posCell: s32x2) -> s32
{
	return posCell.m_x + posCell.m_y * kDXCellBoard	
}

ICell proc (xCell: int, yCell: int) -> s32
{
	return cast(s32)(xCell + yCell * kDXCellBoard)
}

CELOOK enum // CEll LOOKup
{
	ExcludeTail,
	IncludeTail,
}

PEntFromCell proc (pBoard: & SBoard, xCell: int, yCell: int, celook: CELOOK) -> & SEntity
{
	pEnt := pBoard.m_mpIcellPEnt[ICell(xCell, yCell)]
	if pEnt
	{
		iCell := ICell(xCell, yCell)
		if iCell == pEnt.m_iCellParentTail && celook == CELOOK.ExcludeTail
			{ return null }

		//iCellPos := ICellFromPos(pBoard, pEnt.m_pos)
		//assert(iCell == iCellPos, "bad cell calculation in lookup", #file, #line)
	}
	return pEnt
}

FIsCellOccupied proc (pBoard: & SBoard, xCell: int, yCell: int) -> bool
{
	if xCell < 0 || xCell >= kDXCellBoard || yCell < 0 || yCell >= kDYCellBoard
		{ return true }

	return PEntFromCell(pBoard, xCell, yCell, CELOOK.IncludeTail) != null
}

FIsCellOccupied proc (pBoard: & SBoard, xCell: int, yCell: int, pEntIgnore: & SEntity) -> bool
{
	if xCell < 0 || xCell >= kDXCellBoard || yCell < 0 || yCell >= kDYCellBoard
		{ return true }

	pEnt := PEntFromCell(pBoard, xCell, yCell, CELOOK.IncludeTail)
	return pEnt != null && pEnt != pEntIgnore
}


PillcolFromCell proc (pBoard: & SBoard, xCell: int, yCell: int) -> PILLCOL
{
	pEnt := PEntFromCell(pBoard, xCell, yCell, CELOOK.IncludeTail)
	if !pEnt || pEnt.m_ents != ENTS.Stable
		{ return PILLCOL.nil }

	iCell := ICell(xCell, yCell)
	if iCell == pEnt.m_iCellParentTail
		{ return pEnt.m_pillcolTail }

	return pEnt.m_pillcol
}

KillCell proc (pPlay: & SPlayer, pBoard: & SBoard, xCell: int, yCell: int)
{
	pEnt := PEntFromCell(pBoard, xCell, yCell, CELOOK.IncludeTail)
	++pPlay.m_cKilledCells

	// Need to handle tails
	if pEnt
	{
		posCell := PosCell(pBoard, pEnt.m_pos)

		if pEnt.m_fHasTail
		{
			pEnt.m_fHasTail = false
			ReparentBoardEntity(pBoard, pEnt)

			pEntTail := PEntAllocate(&g_game.m_pEntUnusedFirst, pEnt.m_entk)
			pEntTail.m_fHasTail = false
			pEntTail.m_pillcol = pEnt.m_pillcolTail

			posCellTail := posCell + DCellFromDir(pEnt.m_dir)
			CutPos(pEntTail, PosFromCell(pBoard, posCellTail.m_x, posCellTail.m_y), pEnt.m_dir)

			ReparentBoardEntity(pBoard, pEntTail)
			if posCellTail.m_x == xCell && posCellTail.m_y == yCell
			{
				SetEnts(pEntTail, ENTS.Dead)
			}
		}

		if posCell.m_x == xCell && posCell.m_y == yCell
		{
			SetEnts(pEnt, ENTS.Dead)
		}
	}
}

SetEnts proc (pEnt: & SEntity, entsNew: ENTS)
{
	if pEnt.m_ents == entsNew
		{ return }

	pEnt.m_ents = entsNew
	pEnt.m_dTEnts = 0
}

DCellFromDir proc (dir: DIR) -> s32x2
{
	switch dir
	{
		case DIR.Left: 	return S32x2Create(-1, 0)
		case DIR.Right: return S32x2Create(1, 0)
		case DIR.Down: 	return S32x2Create(0, -1)
		case DIR.Up: 	return S32x2Create(0, 1)
	}

	assert(false, "unknown dir", #file, #line)
	return S32x2Create(0, 0)
}

UnparentBoardEntity proc (pBoard: & SBoard, pEnt: & SEntity)
{
	if pEnt.m_iCellParent >= 0
	{
		assert(pBoard.m_mpIcellPEnt[pEnt.m_iCellParent] == pEnt, "bad entity parenting", #file, #line)
		pBoard.m_mpIcellPEnt[pEnt.m_iCellParent] = null
		pEnt.m_iCellParent = -1

		if pEnt.m_iCellParentTail >= 0
		{
			assert(pBoard.m_mpIcellPEnt[pEnt.m_iCellParentTail] == pEnt, "bad entity parenting", #file, #line)
			pBoard.m_mpIcellPEnt[pEnt.m_iCellParentTail] = null
			pEnt.m_iCellParentTail = -1
		}
	}
}

ReparentBoardEntity proc (pBoard: & SBoard, pEnt: & SEntity)
{
	//if iCellNew == pEnt.m_iCellParent	
	//	{ return }

	pEnt.m_iBoard = pBoard.m_iBoard
	UnparentBoardEntity(pBoard, pEnt)

	posCell := PosCell(pBoard, pEnt.m_pos)
	pEnt.m_iCellParent = ICell(posCell)
	assert(pBoard.m_mpIcellPEnt[pEnt.m_iCellParent] == null, "trying to parent to occupied cell", #file, #line)
	pBoard.m_mpIcellPEnt[pEnt.m_iCellParent] = pEnt
	
	if (pEnt.m_fHasTail)
	{
		dPosCell := DCellFromDir(pEnt.m_dir)	
		pEnt.m_iCellParentTail = ICell(posCell + dPosCell)
		assert(pBoard.m_mpIcellPEnt[pEnt.m_iCellParentTail] == null, "trying to parent tail to occupied cell", #file, #line)
		pBoard.m_mpIcellPEnt[pEnt.m_iCellParentTail] = pEnt
	}
}

ClearBoard proc (pBoard: & SBoard, pGame: & SGame)
{
	for yCell := 0; yCell < kDYCellBoard; ++yCell
	{	
		for xCell := 0; xCell < kDXCellBoard; ++xCell
		{
			pEnt := PEntFromCell(pBoard, xCell, yCell, CELOOK.ExcludeTail)
			if pEnt
			{
				FreeEntity(pGame, &pGame.m_pEntUnusedFirst, pEnt)
			}
		}
	}
}

InitBoard proc (iPlay: int, cPlay: int,	dXyVport: s32x2, pBoard: & SBoard, cVirus: int)
{
	// 40 x 40
	kDYBorderTop :: 92
	kDYBorderBottom :: 68
	kDXBorderLeft :: 30
	kDXBorderRight :: 30
	kDXBorderMiddle :: 30

	// find our cell size
	dYMax := cast(s32)dXyVport.m_y - (kDYBorderTop + kDYBorderBottom)
	dYCell := dYMax / kDYCellBoardVisible

	dXBoard : s32 = cast(s32)((dXyVport.m_x - (kDXBorderLeft + kDXBorderRight + (cPlay - 1) * kDXBorderMiddle)) / cPlay)
	dXCell := dXBoard / kDXCellBoard

	dXCell = NMin(dXCell, dYCell)	
	dYCell = dXCell

	pBoard.m_dXyTile = S32x2Create(cast(s32)dXCell, cast(s32)dYCell)
	pBoard.m_gTileSpacing = cast(f32)pBoard.m_dXyTile.m_x / 8 

	pBoard.m_dXyBoard = S32x2Create(cast(s32)dXCell * kDXCellBoard, cast(s32)dYCell * kDYCellBoardVisible)

	dXBorderTotal := dXyVport.m_x - pBoard.m_dXyBoard.m_x * cPlay
	dXSeperate := dXBorderTotal / (cPlay + 1)

	pBoard.m_pos = S32x2Create(cast(s32)((pBoard.m_dXyBoard.m_x + dXSeperate) * iPlay + dXSeperate), kDYBorderBottom)

	pBoard.m_iBoard = cast(s32)iPlay

	// BB - there are better ways to do this
	cRetry := 0
	for iVirus:= 0; iVirus < cVirus; ++iVirus
	{
		pEntVirus := PEntAllocate(&g_game.m_pEntUnusedFirst, ENTK.Virus)
		pEntVirus.m_fHasTail = false

		pillcol := cast(PILLCOL)NRandom(&pBoard.m_rng, PILLCOL.min, PILLCOL.MaxPills)
		pEntVirus.m_pillcol = pillcol

		// start each entity at a random spot in the pulse cycle
		pEntVirus.m_dTPulse = GRandom(&pBoard.m_rng, 0, kDTPulseTotal)

		while true
		{
			xCell := NRandom(&pBoard.m_rng, 0, kDXCellBoard)
			yCell := NRandom(&pBoard.m_rng, 0, kYMaxVirusStart)

			if !FIsCellOccupied(pBoard, xCell, yCell)
			{
				CutPos(pEntVirus, PosFromCell(pBoard, xCell, yCell), pEntVirus.m_dir)
				ReparentBoardEntity(pBoard, pEntVirus)
				break
			}
			else
			{
				++cRetry 
			}
		}
	}

	printf("cells are %d x %d. Board is %d x %d\n", dXCell, dYCell, pBoard.m_dXyBoard.m_x, pBoard.m_dXyBoard.m_y)
	printf("%d retries\n", cRetry)
}

DrawOutsideBorder proc (xMin: f32, yMin: f32, xMax: f32, yMax: f32, sWidth: f32, colvec: SColorVec)
{
	AppendTile(xMin - sWidth, yMin - sWidth, xMin, yMax + sWidth, &colvec, &g_tilbuf)	// left
	AppendTile(xMax, yMin - sWidth, xMax + sWidth, yMax + sWidth, &colvec, &g_tilbuf)	// right

	AppendTile(xMin, yMin - sWidth, xMax, yMin, &colvec, &g_tilbuf)	// bottom
	AppendTile(xMin, yMax, xMax, yMax + sWidth, &colvec, &g_tilbuf)	// bottom
}

DrawInsideBorder proc (xMin: f32, yMin: f32, xMax: f32, yMax: f32, sWidth: f32, colvec: SColorVec)
{
	xMinAdj := xMin + sWidth
	yMinAdj := yMin + sWidth
	xMaxAdj := xMax - sWidth
	yMaxAdj := yMax - sWidth
	DrawOutsideBorder(xMinAdj, yMinAdj, xMaxAdj, yMaxAdj, sWidth, colvec)
}

DrawBoardBackground proc (pBoard: & SBoard, pillcolSelf: PILLCOL, pillcolTarget: PILLCOL)
{
	xMin : f32 = cast(f32)pBoard.m_pos.m_x
	yMin : f32 = cast(f32)pBoard.m_pos.m_y
	xMax : f32 = cast(f32)(pBoard.m_pos.m_x + pBoard.m_dXyBoard.m_x) + pBoard.m_gTileSpacing
	yMax : f32 = cast(f32)(pBoard.m_pos.m_y + pBoard.m_dXyBoard.m_y) + pBoard.m_gTileSpacing

	colvecBorder := ColvecFromCol(ColFromPillcol(pillcolSelf))
	DrawOutsideBorder(xMin, yMin, xMax, yMax, kBoardBorderWidth, colvecBorder)

	dYBottom: f32 = kDYBoardBorderBottom  - kBoardBorderWidth
	xMin -= kBoardBorderWidth
	xMax += kBoardBorderWidth
	yMin -= kBoardBorderWidth
	AppendTile(xMin, yMin - dYBottom, xMax, yMin, &colvecBorder, &g_tilbuf)
}

CutPos proc (pEnt: & SEntity, pos: f32x2, dir: DIR)
{
	pEnt.m_pos = pos	
	pEnt.m_posSmooth = pos

	pEnt.m_dir = dir
	pEnt.m_radSmooth = RadFromDir(dir)
}

RadFromDir proc (dir: DIR) -> f32
{
	switch dir
	{
	case DIR.Left: 	return kPi
	case DIR.Up:	return kPiOver2
	case DIR.Right:	return 0
	case DIR.Down:	return kPi + kPiOver2
	}
	assert(false, "unhandled dir?", #file, #line)
	return 0
}

DPosPillFromDir proc (pBoard: & SBoard, dir: DIR) -> f32x2
{
	// returns the offset applied to each piece as it rotates

	switch dir
	{
	case DIR.Left: 	return F32x2Create(cast(f32)pBoard.m_dXyTile.m_x, 0)
	case DIR.Up:	return F32x2Create(cast(f32)pBoard.m_dXyTile.m_x, 0)
	case DIR.Right:	return F32x2Create(0, 0)
	case DIR.Down:	return F32x2Create(0, cast(f32)pBoard.m_dXyTile.m_y)
	}
	assert(false, "unhandled dir?", #file, #line)
	return F32x2Create(0,0)

}

DrawPill proc (pBoard: & SBoard, pos: f32x2, rad: f32, colHead: SColor, fHasTail: bool, colTail: SColor, rOpacity: f32, rXScale: f32)
{
	gHalfSpacing := pBoard.m_gTileSpacing * 0.5

	dXySpacing := F32x2Create(pBoard.m_gTileSpacing, pBoard.m_gTileSpacing)
	posOrigin := pos + dXySpacing
	vecHalfSpace := (F32x2Cast(pBoard.m_dXyTile) - dXySpacing) * 0.5
	posOrigin += vecHalfSpace

	posMin := -vecHalfSpace
	posMax := posMin + F32x2Cast(pBoard.m_dXyTile) - dXySpacing

	posMinTail := posMin
	posMinTail.m_x += cast(f32)pBoard.m_dXyTile.m_x

	posMaxTail := posMinTail + F32x2Cast(pBoard.m_dXyTile) - dXySpacing

	if fHasTail
	{
		posMax.m_x += gHalfSpacing	
		posMinTail.m_x = posMax.m_x
	}

	// xScaling
	{
		xMid := (posMaxTail.m_x - posMin.m_x) * 0.5 + posMin.m_x
		posMin.m_x = (posMin.m_x - xMid) * rXScale + xMid
		posMax.m_x = (posMax.m_x - xMid) * rXScale + xMid
		posMinTail.m_x = (posMinTail.m_x - xMid) * rXScale + xMid
		posMaxTail.m_x = (posMaxTail.m_x - xMid) * rXScale + xMid
	}

	dPosRot := F32x2Create(0,0)
	posOrigin += dPosRot

	colvecEnt := ColvecFromCol(colHead)	
	colvecEnt.m_w *= rOpacity

	AppendTile(posOrigin, rad, posMin.m_x, posMin.m_y, posMax.m_x, posMax.m_y, &colvecEnt, &g_tilbuf)

	// debug marker for primary cell
	colvecLight := ColvecLerp(ColvecFromCol(ColCreate(255,255,255,255)), colvecEnt, 0.5)
	AppendTile(posOrigin, rad, posMin.m_x + 5, posMax.m_y - 10, posMin.m_x + 10, posMax.m_y - 5, &colvecLight, &g_tilbuf)

	if (fHasTail)
	{
		colvecTail := ColvecFromCol(colTail)
		colvecTail.m_w *= rOpacity

		AppendTile(posOrigin, rad, posMinTail.m_x, posMinTail.m_y, posMaxTail.m_x, posMaxTail.m_y, &colvecTail, &g_tilbuf)
	}
}

DrawEntity proc (pEnt: & SEntity, pBoard: & SBoard, pos: f32x2, rOpacity: f32)
{
	kVirusBorderWidth :: 3
	kVirusBorderSeparation :: 2
	kDeadEntWidth :: 3

	posMin := pos + F32x2Cast(pBoard.m_pos)
	posMax := posMin + F32x2Cast(pBoard.m_dXyTile)
	posMin.m_x += cast(f32)pBoard.m_gTileSpacing
	posMin.m_y += cast(f32)pBoard.m_gTileSpacing

	colvecEnt := ColvecFromCol(ColFromPillcol(pEnt.m_pillcol))	
	colvecEnt.m_w *= rOpacity

	kULerpStable :: 1.0 // 0.7
	colvecStable := ColvecFromCol(ColCreate(0, 0, 0, 255))
	uLerpStable := 1.0
	if pEnt.m_ents == ENTS.Stable
	{
		uLerpStable = kULerpStable
		colvecEnt = ColvecLerp(colvecStable, colvecEnt, uLerpStable)
	}

	switch pEnt.m_entk	
	{
		case ENTK.Virus:

			if pEnt.m_ents != ENTS.Dead
			{
				posMin.m_x += kVirusBorderWidth
				posMin.m_y += kVirusBorderWidth
				posMax.m_x -= kVirusBorderWidth
				posMax.m_y -= kVirusBorderWidth

				uPulse := 0.0
				if pEnt.m_dTPulse >= kDTPulseTotal
				{
					pEnt.m_dTPulse = 0
				}
				if pEnt.m_dTPulse < kDTPulseBell 
				{
					u := pEnt.m_dTPulse / kDTPulseBell
					uPulse = GCurveBell(u)
				}

				kPulseWidthShrink :: 3
				kPulseWidthGrow :: 2
				uShrink := uPulse * kPulseWidthShrink
				uGrow := uPulse * kPulseWidthGrow
				AppendTile(posMin.m_x + uShrink, posMin.m_y + uShrink, posMax.m_x - uShrink, posMax.m_y - uShrink, &colvecEnt, &g_tilbuf)

				posMin.m_x -= kVirusBorderSeparation + uGrow
				posMin.m_y -= kVirusBorderSeparation + uGrow
				posMax.m_x += kVirusBorderSeparation + uGrow
				posMax.m_y += kVirusBorderSeparation + uGrow

				DrawOutsideBorder(posMin.m_x, posMin.m_y, posMax.m_x, posMax.m_y, kVirusBorderWidth, colvecEnt)
			}
			else
			{
				DrawInsideBorder(posMin.m_x, posMin.m_y, posMax.m_x, posMax.m_y, kVirusBorderWidth, colvecEnt)
			}

		case ENTK.Pill:

			gHalfSpacing := cast(f32)pBoard.m_gTileSpacing/2
			posMinTail := posMin
			posMaxTail := posMax

			if pEnt.m_fHasTail
			{
				switch pEnt.m_dir
				{
					case DIR.Left: 
						posMinTail.m_x -= cast(f32)pBoard.m_dXyTile.m_x
						posMin.m_x -= gHalfSpacing
						posMaxTail.m_x = posMin.m_x
					case DIR.Right: 
						posMaxTail.m_x += cast(f32)pBoard.m_dXyTile.m_x
						posMax.m_x += gHalfSpacing
						posMinTail.m_x = posMax.m_x
					case DIR.Up: 
						posMaxTail.m_y += cast(f32)pBoard.m_dXyTile.m_y
						posMax.m_y += gHalfSpacing
						posMinTail.m_y = posMax.m_y
					case DIR.Down: 
						posMinTail.m_y -= cast(f32)pBoard.m_dXyTile.m_y
						posMin.m_y -= gHalfSpacing
						posMaxTail.m_y = posMin.m_y
				}
			}

			if (pEnt.m_ents != ENTS.Dead)	
			{
				kRPillPulseScale :: 0.2
				uPulse := 0.0
				if pEnt.m_dTPulse < kDTPulseBellStabilize
				{
					u := pEnt.m_dTPulse / kDTPulseBellStabilize
					uPulse = GCurveBell(u)
				}

				posPill := pos + F32x2Cast(pBoard.m_pos)
				radDir := RadFromDir(pEnt.m_dir)

				colWhite := ColCreate(255, 255, 255, 255)
				colPill := ColLerp(ColFromPillcol(pEnt.m_pillcol), colWhite, uPulse)
				colTail := ColLerp(ColFromPillcol(pEnt.m_pillcolTail), colWhite, uPulse)

				DrawPill(pBoard, posPill, radDir, colPill, pEnt.m_fHasTail, colTail, 0.2, 1)

				posSmoothPill := pEnt.m_posSmooth + F32x2Cast(pBoard.m_pos)
				DrawPill(pBoard, posSmoothPill, pEnt.m_radSmooth, colPill, pEnt.m_fHasTail, colTail, 1, 1)
			}
			else
			{
				DrawInsideBorder(posMin.m_x, posMin.m_y, posMax.m_x, posMax.m_y, kDeadEntWidth, colvecEnt)

				if (pEnt.m_fHasTail)
				{
					colvecTail := ColvecFromCol(ColFromPillcol(pEnt.m_pillcolTail))
					colvecTail = ColvecLerp(colvecStable, colvecTail, uLerpStable)

					DrawInsideBorder(posMinTail.m_x, posMinTail.m_y, posMaxTail.m_x, posMaxTail.m_y, kDeadEntWidth, colvecTail)
				}
			}
		case ENTK.Garbage:
			if pEnt.m_ents != ENTS.Dead
			{
				gHalfSpacing := cast(f32)pBoard.m_gTileSpacing/2
				posHalf := F32x2Create(gHalfSpacing, gHalfSpacing)

				posSplitBegin := posMin + (posMax - posMin) * 0.5
				posSplitEnd := posSplitBegin + posHalf
				posSplitBegin -= posHalf

				AppendTile(posMin.m_x, posMin.m_y, posSplitBegin.m_x, posSplitBegin.m_y, &colvecEnt, &g_tilbuf)
				AppendTile(posMin.m_x, posSplitEnd.m_y, posSplitBegin.m_x, posMax.m_y, &colvecEnt, &g_tilbuf)

				AppendTile(posSplitEnd.m_x, posMin.m_y, posMax.m_x, posSplitBegin.m_y, &colvecEnt, &g_tilbuf)
				AppendTile(posSplitEnd.m_x, posSplitEnd.m_y, posMax.m_x, posMax.m_y, &colvecEnt, &g_tilbuf)
			}
			else
			{
				DrawInsideBorder(posMin.m_x, posMin.m_y, posMax.m_x, posMax.m_y, kVirusBorderWidth, colvecEnt)
			}
	}

}

DrawGarbage proc (pBoard: & SBoard, posMin: f32x2, colvec: SColorVec)
{
	posMax := posMin + F32x2Cast(pBoard.m_dXyTile)

	gHalfSpacing := cast(f32)pBoard.m_gTileSpacing/2
	dPosHalf := F32x2Create(gHalfSpacing, gHalfSpacing)

	posSplitBegin := posMin + (posMax - posMin) * 0.5
	posSplitEnd := posSplitBegin + dPosHalf
	posSplitBegin -= dPosHalf

	AppendTile(posMin.m_x, posMin.m_y, posSplitBegin.m_x, posSplitBegin.m_y, &colvec, &g_tilbuf)
	AppendTile(posMin.m_x, posSplitEnd.m_y, posSplitBegin.m_x, posMax.m_y, &colvec, &g_tilbuf)

	AppendTile(posSplitEnd.m_x, posMin.m_y, posMax.m_x, posSplitBegin.m_y, &colvec, &g_tilbuf)
	AppendTile(posSplitEnd.m_x, posSplitEnd.m_y, posMax.m_x, posMax.m_y, &colvec, &g_tilbuf)
}


DrawBoards proc (pGame : & SGame, pDrac: & SDrawContext)
{
	for iPlay:=0; iPlay < pGame.m_cPlay; ++iPlay
	{
		cVirusLiving: int
		pPlay := pGame.m_aPlay[iPlay]
		iPlayTarget  := iPlay
		if (pPlay.m_iPlayerTarget >= 0)
			{ iPlayTarget = pPlay.m_iPlayerTarget }

		pBoard := &pGame.m_aBoard[iPlay]
		DrawBoardBackground(pBoard, pPlay.m_pillcol, pGame.m_aPlay[iPlayTarget].m_pillcol)

		if pGame.m_gams != GAMS.Pregame
		{
			for yCell := 0; yCell < kDYCellBoard; ++yCell
			{	
				for xCell := 0; xCell < kDXCellBoard; ++xCell
				{
					pEnt := PEntFromCell(pBoard, xCell, yCell, CELOOK.ExcludeTail)
					if pEnt
					{ 
						DrawEntity(pEnt, pBoard, pEnt.m_pos, 1.0)

						if pEnt.m_entk == ENTK.Virus
						{
							++cVirusLiving
						}
					}
				}
			}
		}

		if pGame.m_gams == GAMS.InGame
		{
			kRGarbageTrimBottom :: 0.25
			kRGarbageSpacing :: 1.25

			posGarbage := pBoard.m_pos + S32x2Create(-kBoardBorderWidth, kBoardBorderWidth)
			posGarbage.m_y += pBoard.m_dXyBoard.m_y + cast(s32)(cast(f32)pBoard.m_dXyTile.m_y * kRGarbageTrimBottom)

			pillWidth := cast(f32)pBoard.m_dXyTile.m_x * 2
			posPill := F32x2Create(cast(f32)(pBoard.m_pos.m_x + pBoard.m_dXyBoard.m_x + kBoardBorderWidth) - pillWidth, cast(f32)posGarbage.m_y) 
			DrawPill(pBoard, posPill, 0, ColFromPillcol(pPlay.m_pillcolNextHead), true, ColFromPillcol(pPlay.m_pillcolNextTail), 1, 1)

			for iPlayOther:=0; iPlayOther < pGame.m_cPlay; ++iPlayOther
			{
				pPlayOther := &pGame.m_aPlay[iPlayOther]
				colvec := ColvecFromCol(ColFromPillcol(pPlayOther.m_pillcol))

				cGarbage := pPlay.m_mpIplayCGarbagePending[iPlayOther]
				for iGarbage := 0; iGarbage < cGarbage; ++iGarbage
				{
					DrawGarbage(pBoard, F32x2Cast(posGarbage), colvec)	
					posGarbage.m_x += cast(s32)(cast(f32)pBoard.m_dXyTile.m_x * kRGarbageSpacing)
				}

			}

			posLabel := pBoard.m_pos
			posLabel.m_x += pBoard.m_dXyBoard.m_x / 2
			posLabel.m_y -= kDYBoardBorderBottom - 10

			kGCharSizeVirus :: 50
			pFontd := &pDrac.m_pDras.m_fontd
			gCharSizePrev := pFontd.m_gCharSize
			pFontd.m_gCharSize = kGCharSizeVirus

			aChVirusCount: [16] u8
			snprintf(aChVirusCount, aChVirusCount.count, "%d", cVirusLiving)
			DrawTextCentered(pDrac, F32x2Cast(posLabel), aChVirusCount)

			pFontd.m_gCharSize = gCharSizePrev
		}
	}
}

ClearPlayerInput proc (pPlayinp: & SPlayerInput)
{
	for butk := BUTK.min; butk != BUTK.max; ++butk
	{
		pPlayinp.m_mpButkEdges[butk] = EDGES.Off
	}
}

AdvancePlayerInput proc (pPlayinp: & SPlayerInput)
{
	for butk := BUTK.min; butk != BUTK.max; ++butk
	{
		if pPlayinp.m_mpButkEdges[butk] >= EDGES.Hold
		{
			pPlayinp.m_mpButkEdges[butk] = EDGES.Hold
		}
		else
		{
			pPlayinp.m_mpButkEdges[butk] = EDGES.Off
		}
	}
}

g_mpButkKeycodePs4: [BUTK.max] KEYCODE = 
{
	KEYCODE.JoypadButton15,	//Up,
	KEYCODE.JoypadButton17, //Down,
	KEYCODE.JoypadButton18, //Left,
	KEYCODE.JoypadButton16, //Right,
	KEYCODE.JoypadButton2,	//RotateClock,
	KEYCODE.JoypadButton3,	//RotateCClock,
	KEYCODE.JoypadButton4,	//RotateClockAlt,
	KEYCODE.JoypadButton1,	//RotateCClockAlt,
	KEYCODE.JoypadButton2, 	//Select,
	KEYCODE.JoypadButton3	//Cancel,
}

g_mpButkKeycodeWiredX360: [BUTK.max] KEYCODE = 
{
	KEYCODE.JoypadButton11,	//Up,
	KEYCODE.JoypadButton13, //Down,
	KEYCODE.JoypadButton14, //Left,
	KEYCODE.JoypadButton12, //Right,
	KEYCODE.JoypadButton2,	//RotateClock,
	KEYCODE.JoypadButton1,	//RotateCClock,
	KEYCODE.JoypadButton3,	//RotateClockAlt,
	KEYCODE.JoypadButton4,	//RotateCClockAlt,
	KEYCODE.JoypadButton1, 	//Select,
	KEYCODE.JoypadButton2	//Cancel,
}

InitJoysticks proc (pGame: & SGame) -> void
{
	iPadmapd := 0

	pPadmapd := &pGame.m_aPadmapd[iPadmapd++]
	pPadmapd.m_pChzJoystickName = "Wireless Controller"
	pPadmapd.m_mpButkKeycode = g_mpButkKeycodePs4

	pPadmapd = &pGame.m_aPadmapd[iPadmapd++]
	pPadmapd.m_pChzJoystickName = "Xbox 360 Controller"
	pPadmapd.m_mpButkKeycode = g_mpButkKeycodeWiredX360

	pGame.m_cPadmapd = iPadmapd

	for iDeviceId : s32 = kNDeviceIdJoystickMin; iDeviceId < kNDeviceIdJoystickMax; ++iDeviceId
	{
		if FIsJoystickConnected(iDeviceId)
		{
			OnJoystickConnect(pGame, iDeviceId)
		}
	}
}

FHandleEvents proc (pGame: & SGame) -> bool
{
	mpButkKeycodeKeyboard: [BUTK.max] KEYCODE = 
	{	
		KEYCODE.ArrowUp, 		//Up,
		KEYCODE.ArrowDown, 		//Down,
		KEYCODE.ArrowLeft, 		//Left,
		KEYCODE.ArrowRight, 	//Right
		KEYCODE.KeyA,			//RotateClock,
		KEYCODE.KeyS,			//RotateCClock,
		KEYCODE.KeyA,			//RotateClockAlt,
		KEYCODE.KeyS,			//RotateCClockAlt,
		KEYCODE.Enter, 			//Select,
		KEYCODE.F3				//Cancel,
	}	

	for iPlay := 0; iPlay < pGame.m_aPlay.count; ++iPlay
	{
		pPlayinp := &pGame.m_aPlay[iPlay].m_playinp
		AdvancePlayerInput(pPlayinp)
	}

	event : SEvent
	#label EventLoop
	while FGetNextEvent(&event)
	{
		/*
		if event.m_keycode != KEYCODE.nil
		{
			printf("Event: eventk = %d, nDeviceId = %d, keycode=%d, edges = %d\n", event.m_eventk, event.m_nDeviceId, event.m_keycode, event.m_edges)
		}*/
		if event.m_keycode == KEYCODE.Escape && event.m_edges == EDGES.Press
			{ return false }
		if event.m_keycode == KEYCODE.KeyG && event.m_edges == EDGES.Press
		{
			g_fApplyGravity = !g_fApplyGravity
			continue
		}

		if event.m_keycode == KEYCODE.KeyE && event.m_edges == EDGES.Press
		{
			SetGams(pGame, GAMS.PostGame)

			SetGamres(&pGame.m_aPlay[0], GAMRES.WinLastStanding)
			for iPlay := 1; iPlay < pGame.m_cPlay; ++iPlay
			{
				pPlay := &pGame.m_aPlay[iPlay]
				if (pPlay.m_gamres == GAMRES.Pending)
				{
					SetGamres(pPlay, GAMRES.LoseTooSlow)
				}
			}
			continue
		}

		mpButkKeycode: & KEYCODE 
		iPlay := -1

		switch event.m_eventk
		{
			case EVENTK.Keyboard:
				iPlay = 0
				mpButkKeycode = mpButkKeycodeKeyboard

			case EVENTK.Joystick:
				iPlay = IPlayFromNDeviceId(pGame, event.m_nDeviceId)

				pPlayinp := &pGame.m_aPlay[iPlay].m_playinp
				if pPlayinp && pPlayinp.m_pPadmap
				{
					mpButkKeycode = pPlayinp.m_pPadmap.m_pPadmapd.m_mpButkKeycode
				}

			case EVENTK.JoystickConnected:
				OnJoystickConnect(pGame, event.m_nDeviceId)
				continue EventLoop

			case EVENTK.JoystickDisconnected:
				OnJoystickDisconnect(pGame, event.m_nDeviceId)
				continue EventLoop
		}


		if iPlay < 0 || !mpButkKeycode
		{
			continue
		}
		pPlayinp := &pGame.m_aPlay[iPlay].m_playinp

		for butk := BUTK.min; butk != BUTK.max; ++butk
		{
			if event.m_keycode == mpButkKeycode[butk]
			{
				pPlayinp.m_mpButkEdges[butk] = event.m_edges
			}
		}
	}

	return true

	OnJoystickDisconnect proc (pGame : & SGame, nDeviceId: s32)
	{
		printf("Disconnecting Joystick %d\n", nDeviceId)
		iPlay := IPlayFromNDeviceId(pGame, nDeviceId)
		if iPlay >= 0
		{
			pPlayinp := &pGame.m_aPlay[iPlay].m_playinp
			if pPlayinp.m_pPadmap
			{
				pPlayinp.m_pPadmap.m_nDeviceId = -1
				pPlayinp.m_nDeviceId = -1
			}
			pPlayinp.m_pPadmap = null
		}
	}
}

OnJoystickConnect proc (pGame: & SGame, nDeviceId: s32)
{
	// find the first player without a padmap	

	for iPlay := 0; iPlay < pGame.m_aPlay.count; ++iPlay
	{
		pPlayinp := &pGame.m_aPlay[iPlay].m_playinp	
		if pPlayinp.m_pPadmap == null
		{
			pPlayinp.m_pPadmap = &pGame.m_aPadmap[iPlay]
			pPlayinp.m_nDeviceId = nDeviceId
			assert(pGame.m_aPadmap[iPlay].m_nDeviceId == 0, "", #file, #line)	
			pGame.m_aPadmap[iPlay].m_nDeviceId = nDeviceId

			// find a valid map data
			pChzJoystickName := PChzJoystickName(nDeviceId)
			iPadmapdMatch := 0
			for iPadmapd := 0; iPadmapd < pGame.m_cPadmapd; ++iPadmapd
			{
				pPadmapd := &pGame.m_aPadmapd[iPadmapd]
				if FAreCozEqual(pChzJoystickName, pPadmapd.m_pChzJoystickName)
				{
					iPadmapdMatch = iPadmapd
					break
				}
			}

			printf("Connecting Joystick(%d) %s, %p\n", nDeviceId, pChzJoystickName, pPlayinp.m_pPadmap)
			pGame.m_aPadmap[iPlay].m_pPadmapd = &pGame.m_aPadmapd[iPadmapdMatch]
			return
		}
	}

	// all players have joysticks
}


IPlayFromNDeviceId proc (pGame: & SGame, nDeviceId: s32) -> int
{
	for iPlay := 0; iPlay < g_game.m_aPlay.count; ++iPlay
	{
		if g_game.m_aPlay[iPlay].m_playinp.m_nDeviceId == nDeviceId
		{
			return iPlay
		}
	}

	return 0
}

DTElapsed proc (cTickStart: s64, cTickEnd: s64) -> f32 inline
{
    return cast (f32)(cTickEnd - cTickStart) / cast(f32)g_cTickPerSecond
}

AppendTile proc (
			pos: f32x2, rad: f32,
			xMin: f32, yMin: f32,
			xMax: f32, yMax: f32,
			colvec: & SColorVec,
			pTilbuf: & STileVertexBuffer)
{
	if pTilbuf.m_aTilvert.count < pTilbuf.m_cTilvert + 4
		{ return }

	mat := Mat33FromPosRad(pos, rad)

	pos0 := F32x2Create(xMin, yMax)
	pos0 = PosMul(mat, pos0)
	AppendTilvert(
		pos0.m_x, pos0.m_y,
		0,	0,	// u, v
		colvec.m_x, colvec.m_y, colvec.m_z, colvec.m_w,
		pTilbuf)

	pos1 := F32x2Create(xMax, yMax)
	pos1 = PosMul(mat, pos1)
	AppendTilvert(
		pos1.m_x, pos1.m_y,
		0,	0,	// u, v
		colvec.m_x, colvec.m_y, colvec.m_z, colvec.m_w,
		pTilbuf)

	pos2 := F32x2Create(xMax, yMin)
	pos2 = PosMul(mat, pos2)
	AppendTilvert(
		pos2.m_x, pos2.m_y,
		0,	0,	// u, v
		colvec.m_x, colvec.m_y, colvec.m_z, colvec.m_w,
		pTilbuf)

	pos3 := F32x2Create(xMin, yMin)
	pos3 = PosMul(mat, pos3)
	AppendTilvert(
		pos3.m_x, pos3.m_y,
		0,	0,	// u, v
		colvec.m_x, colvec.m_y, colvec.m_z, colvec.m_w,
		pTilbuf)
}

AppendTile proc (
			xMin: float, yMin: float,
			xMax: float, yMax: float,
			colvec: & SColorVec,
			pTilbuf: & STileVertexBuffer)
{
	if pTilbuf.m_aTilvert.count < pTilbuf.m_cTilvert + 4
		{ return }

	AppendTilvert(
		xMin, yMax,
		0,	0,	// u, v
		colvec.m_x, colvec.m_y, colvec.m_z, colvec.m_w,
		pTilbuf)

	AppendTilvert(
		xMax, yMax,
		0,	0,	// u, v
		colvec.m_x, colvec.m_y, colvec.m_z, colvec.m_w,
		pTilbuf)

	AppendTilvert(
		xMax, yMin,
		0,	0,	// u, v
		colvec.m_x, colvec.m_y, colvec.m_z, colvec.m_w,
		pTilbuf)

	AppendTilvert(
		xMin, yMin,
		0,	0,	// u, v
		colvec.m_x, colvec.m_y, colvec.m_z, colvec.m_w,
		pTilbuf)
}

AppendTilvert proc (
				x: float, y: float, 
				u: float, v: float, 
				r: float, g: float, b: float, a: float, 
				pTilbuf: & STileVertexBuffer) inline
{
	pTilvert: & STileVertex = &pTilbuf.m_aTilvert[pTilbuf.m_cTilvert]
	++pTilbuf.m_cTilvert

	pTilvert.m_x = x
	pTilvert.m_y = y

	pTilvert.m_u = u
	pTilvert.m_v = v

	pTilvert.m_r = r
	pTilvert.m_g = g
	pTilvert.m_b = b
	pTilvert.m_a = a
}

FlushTileVerts proc (pDrac: & SDrawContext, pTilbuf: & STileVertexBuffer)
{
	aTilvert: [] STileVertex = pTilbuf.m_aTilvert

	// push orthographic projection
	glPushMatrix()
	glLoadIdentity()

	// set scissor rect

	// set up shader
	//glEnable(GL_BLEND)
	//glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)
	assert(pDrac.m_pShman != null, "NULL GContext in flushTileVerts", #file, #line)
	BeginShader(pDrac.m_pShman, pDrac.m_pShman.m_mpCoreshkShhand[CORESHK.Sprite])

	//pTex := pFontman.m_aFont[fontk].m_pTex
	//SetShaderParam(pFontman.m_mpFontshkIParamTex[iShhand], pTex, 0)

	pTilvert := &aTilvert[0]
	glVertexPointer(3, GL_FLOAT, cast (s32) sizeof(STileVertex), &aTilvert[0].m_x)
	glEnableClientState(GL_VERTEX_ARRAY)
			
	glColorPointer(4, GL_FLOAT, cast (s32) sizeof(STileVertex), &aTilvert[0].m_r)
	glEnableClientState(GL_COLOR_ARRAY)

	glClientActiveTexture(GL_TEXTURE0)
	glTexCoordPointer(2, GL_FLOAT, cast (s32) sizeof(STileVertex), &aTilvert[0].m_u)
	glEnableClientState(GL_TEXTURE_COORD_ARRAY)

	glDrawArrays(GL_QUADS, 0, cast (s32) pTilbuf.m_cTilvert)

	//if (pTex)
	//{
	//	glDisable(pTex.m_druTarget)
	//}

	glDisableClientState(GL_VERTEX_ARRAY)
	glDisableClientState(GL_COLOR_ARRAY)	
	glDisableClientState(GL_TEXTURE_COORD_ARRAY)

	EndShader()

	glPopMatrix()

	pTilbuf.m_cTilvert = 0
}	

UpdatePlayers proc (pGame : & SGame, dT: f32)
{
	kDTStepDownSteer :: 0.4
	kDTStepDownDrop :: 0.3

	kDTHoldRepeatInitial :: 0.2
	kDTHoldRepeatAgain :: 0.15

	aFStepDown: [pGame.m_aPlay.count] bool

	for iPlay := 0; iPlay < pGame.m_cPlay; ++iPlay
	{
		pBoard := &g_game.m_aBoard[iPlay]
		pPlay := &g_game.m_aPlay[iPlay]
		pPlayinp := &pPlay.m_playinp

		aFStepDown[iPlay] = false
		if g_fApplyGravity
		{
			pPlay.m_dTStepDown += dT
		}

		dTStepDown: f32
		if pPlay.m_pEntSteer != null
		{
			dTStepDown = kDTStepDownSteer
		}
		else
		{
			dTStepDown = kDTStepDownDrop
		}

		if pPlay.m_dTStepDown > dTStepDown
		{
			aFStepDown[iPlay] = true
			pPlay.m_dTStepDown = 0
		}

		kDCellPerSecond :: 0
		kDCellPerSecondPressDown :: 20
		dCellPerSecond : f32 = kDCellPerSecond

		// update steering for player pill
		if (pPlay.m_pEntSteer)
		{
			pEntSteer := pPlay.m_pEntSteer

			posNew := pEntSteer.m_pos
			dirNew := pEntSteer.m_dir
			posCell := PosCell(pBoard, pEntSteer.m_pos)
			posTail := posCell + DCellFromDir(pEntSteer.m_dir)

			fMoveRight := false
			if pPlayinp.m_mpButkEdges[BUTK.Right] == EDGES.Hold
			{
				pPlay.m_dTRepeatHold -= dT
				if pPlay.m_dTRepeatHold <= 0
				{
					fMoveRight = true
					pPlay.m_dTRepeatHold = kDTHoldRepeatAgain
				}
			}
			else if pPlayinp.m_mpButkEdges[BUTK.Right] == EDGES.Press
			{
				pPlay.m_dTRepeatHold = kDTHoldRepeatInitial
				fMoveRight = true
			}

			if fMoveRight
			{ 
				if	!FIsCellOccupied(pBoard, posCell.m_x + 1, posCell.m_y, pEntSteer) &&
					!FIsCellOccupied(pBoard, posTail.m_x + 1, posTail.m_y, pEntSteer)
				{
					posNew.m_x = cast(f32)((posCell.m_x + 1) * pBoard.m_dXyTile.m_x)
				}
			}

			fMoveLeft := false
			if pPlayinp.m_mpButkEdges[BUTK.Left] == EDGES.Hold
			{
				pPlay.m_dTRepeatHold -= dT
				if pPlay.m_dTRepeatHold < 0
				{
					fMoveLeft = true
					pPlay.m_dTRepeatHold = kDTHoldRepeatAgain
				}
			}
			else if pPlayinp.m_mpButkEdges[BUTK.Left] == EDGES.Press
			{
				pPlay.m_dTRepeatHold = kDTHoldRepeatInitial
				fMoveLeft = true
			}

			if fMoveLeft
			{
				if	!FIsCellOccupied(pBoard, posCell.m_x - 1, posCell.m_y, pEntSteer) &&
					!FIsCellOccupied(pBoard, posTail.m_x - 1, posTail.m_y, pEntSteer)
				{
					posNew.m_x = cast(f32)((posCell.m_x - 1) * pBoard.m_dXyTile.m_x)
				}
			}

			dCellDir := DCellFromDir(dirNew)
			posCellMin := S32x2Min(posCell, posCell + dCellDir)

			dirTry := dirNew

			if pPlayinp.m_mpButkEdges[BUTK.RotateClock] == EDGES.Press || 
				pPlayinp.m_mpButkEdges[BUTK.RotateClockAlt] == EDGES.Press 
			{
				dirTry = (dirNew + 1) % DIR.max
			}

			if pPlayinp.m_mpButkEdges[BUTK.RotateCClock] == EDGES.Press ||
				pPlayinp.m_mpButkEdges[BUTK.RotateCClockAlt] == EDGES.Press
			{
				dirTry = (dirNew + DIR.max - 1) % DIR.max
			}

			posCellCheck: s32x2
			posCellCheckAlt: s32x2
			switch dirTry
			{
				case DIR.Left,
					DIR.Right:
					posCellCheck = posCellMin + S32x2Create(1, 0)
					posCellCheckAlt = posCellMin + S32x2Create(-1, 0)
				case DIR.Up,
					DIR.Down:
					posCellCheck = posCellMin + S32x2Create(0, 1)
					posCellCheckAlt = posCellMin + S32x2Create(1, 1)
			}

			posCellDest: s32x2 
			switch dirTry
			{
				case DIR.Right,
					DIR.Up:
						posCellDest = posCellMin
				case DIR.Left,
					DIR.Down: 
						posCellDest = posCellMin - DCellFromDir(dirTry)
			}

			if dirTry != dirNew 
			{
				if !FIsCellOccupied(pBoard, posCellCheck.m_x, posCellCheck.m_y, pEntSteer)  
				{
					posNew = F32x2Cast(posCellDest * pBoard.m_dXyTile)
					dirNew = dirTry
				}
				else if !FIsCellOccupied(pBoard, posCellCheckAlt.m_x, posCellCheckAlt.m_y)
				{
					posCellDest += (posCellCheckAlt - posCellMin)
					posNew = F32x2Cast(posCellDest * pBoard.m_dXyTile)
					dirNew = dirTry	
				}
			}

			if pPlayinp.m_mpButkEdges[BUTK.Down] >= EDGES.Hold
			{
				dCellPerSecond = kDCellPerSecondPressDown
				pPlay.m_dTHoldDown += dT
				pPlay.m_dTStepDown = 0
			}

			pEntSteer.m_dir = dirNew
			pEntSteer.m_pos = posNew
			ReparentBoardEntity(pBoard, pEntSteer)
		}

		dYPerSec := cast(f32)pBoard.m_dXyTile.m_y * dCellPerSecond
		dY := dT * dYPerSec

		fAnyFalling := false
		for yCell := 0; yCell < kDYCellBoard; ++yCell
		{	
			for xCell := 0; xCell < kDXCellBoard; ++xCell
			{
				pEnt := PEntFromCell(pBoard, xCell, yCell, CELOOK.ExcludeTail)
				if !pEnt
					{ continue }

				pEnt.m_dTEnts += dT

				iCellPos := ICellFromPos(pBoard, pEnt.m_pos)
				iCell := ICell(xCell, yCell)
				assert(iCell == iCellPos, "bad cell calculation", #file, #line)

				if pEnt.m_ents == ENTS.Dead
				{
					if pEnt.m_dTEnts > kDTShowDead
					{
						FreeEntity(&g_game, &g_game.m_pEntUnusedFirst, pEnt)
					}
				}
				else if pEnt.m_entk != ENTK.Virus
				{
					// falling
					yNew := pEnt.m_pos.m_y
					if pPlay.m_pEntSteer == pEnt && dY > 0
					{
						yNew -= dY	
					}
					else if aFStepDown[iPlay]
					{
						yNew -= cast(f32)pBoard.m_dXyTile.m_y
					}

					fIsBelowBlocked := FIsCellOccupied(pBoard, xCell, yCell-1, pEnt)
					if pEnt.m_fHasTail
					{
						dCellTail := DCellFromDir(pEnt.m_dir)
						fIsBelowBlocked |= FIsCellOccupied(pBoard, xCell + dCellTail.m_x, yCell-1 + dCellTail.m_y, pEnt)
					}

					if !fIsBelowBlocked
					{
						pEnt.m_dTStabilize = 0
					}
					else
					{
						pEnt.m_dTStabilize += dT
					}

					yCellNew := NFloor(yNew / cast(f32)pBoard.m_dXyTile.m_y)
					if 	yCellNew != yCell
					{
						// check for a landing

						if fIsBelowBlocked
						{
							yNew = cast(f32)(yCell * pBoard.m_dXyTile.m_y) + 0.001

							if pEnt.m_dTStabilize > kDTStabilize && pEnt.m_ents != ENTS.Stable
							{
								pEnt.m_dTPulse = 0

								SetEnts(pEnt, ENTS.Stable)
								if pPlay.m_pEntSteer == pEnt
								{
									pPlay.m_pEntSteer = null
								}
							}
						}
						else
						{
							pEnt.m_dTPulse = 0
							SetEnts(pEnt, ENTS.Falling)
							fAnyFalling = true
						}
					}
					pEnt.m_posSmooth.m_y += yNew - pEnt.m_pos.m_y
					pEnt.m_pos.m_y = yNew
					ReparentBoardEntity(pBoard, pEnt)
				}
			}
		}

		smpPosX: SSmp
		smpPosX.m_dGMin = 120.0
		smpPosX.m_dGMax = 500.0
		smpPosX.m_dTMax = 0.1

		smpPosY: SSmp
		smpPosY.m_dGMin = 40.0
		smpPosY.m_dGMax = 100.0
		smpPosY.m_dTMax = 1.45

		smpRad: SSmp
		smpRad.m_dGMin = 5
		smpRad.m_dGMax = 40
		smpRad.m_dTMax = 0.15

		// loop over all cells checking for pills that should be dead
		cVirusLiving : int
		fAnyDead := false
		for yCell := 0; yCell < kDYCellBoard; ++yCell
		{	
			for xCell := 0; xCell < kDXCellBoard; ++xCell
			{
				pEnt := PEntFromCell(pBoard, xCell, yCell, CELOOK.IncludeTail)
				if !pEnt
					{ continue }

				pEnt.m_posSmooth.m_x = GSmooth(pEnt.m_posSmooth.m_x, pEnt.m_pos.m_x, &smpPosX, dT)
				pEnt.m_posSmooth.m_y = GSmooth(pEnt.m_posSmooth.m_y, pEnt.m_pos.m_y, &smpPosX, dT)
				pEnt.m_radSmooth = RadSmooth(pEnt.m_radSmooth, RadFromDir(pEnt.m_dir), &smpRad, dT)

				if pEnt.m_ents != ENTS.Stable
				{ 
					fAnyDead |= pEnt.m_ents == ENTS.Dead
					continue 
				}

				pillcol := PillcolFromCell(pBoard, xCell, yCell)

				// horizontal scan
				xCellIt := xCell+1
				for ; xCellIt < kDXCellBoard; ++xCellIt	
				{
					if PillcolFromCell(pBoard, xCellIt, yCell) != pillcol
						{ break }
				}

				fAutoKill := (pPlay.m_grfplay & FPLAY.Autokill) != 0
				cPillcol := xCellIt - xCell
				cPillcolKill := 4
				if fAutoKill && pEnt.m_entk != ENTK.Virus
					{ cPillcolKill = 1}

				if cPillcol >= cPillcolKill
				{
					if !fAutoKill
						{ ++pPlay.m_cKills }

					for iCellDead := 0; iCellDead < cPillcol; ++iCellDead
					{
						KillCell(pPlay, pBoard, xCell + iCellDead, yCell)
						fAnyDead = true
					}
				}

				// vertical scan
				yCellIt := yCell+1
				for ; yCellIt < kDYCellBoard; ++yCellIt	
				{
					if PillcolFromCell(pBoard, xCell, yCellIt) != pillcol
						{ break }
				}

				cPillcol = yCellIt - yCell
				if cPillcol >= 4
				{
					++pPlay.m_cKills
					for iCellDead := 0; iCellDead < cPillcol; ++iCellDead
					{
						KillCell(pPlay, pBoard, xCell, yCell + iCellDead)
						fAnyDead = true
					}
				}

				pEnt.m_dTPulse += dT

				// living viruses?	
				if pEnt.m_entk == ENTK.Virus
				{
					if pEnt.m_ents != ENTS.Dead
					{
						cVirusLiving += 1
					}
				}
			}
		}

		if !cVirusLiving
		{
			SetGamres(pPlay, GAMRES.WinClearedAll)
		}

		if fAnyFalling || fAnyDead
		{
			pPlay.m_dTUntilSpawn = GMax(kDTNextPill, pPlay.m_dTUntilSpawn - dT)
		}
		else
		{
			pPlay.m_dTUntilSpawn -= dT
		}
	}

	for iPlay := 0; iPlay < pGame.m_cPlay; ++iPlay
	{
		pPlay := &pGame.m_aPlay[iPlay]
		if pPlay.m_dTUntilSpawn < 0 && pPlay.m_pEntSteer == null && aFStepDown[iPlay]
		{
			if pPlay.m_cKills > 1
			{
				for iPlayOther := 0; iPlayOther < pGame.m_cPlay; ++iPlayOther
				{
					if iPlay == iPlayOther
						{ continue }
					pGame.m_aPlay[iPlayOther].m_mpIplayCGarbagePending[iPlay] += pPlay.m_cKills
					pGame.m_aPlay[iPlayOther].m_cGarbageReceived += pPlay.m_cKills
				}
			}
			pPlay.m_cGarbageSent += pPlay.m_cKills
			pPlay.m_cKills = 0
		}
	}

	// spawn garbage or pills
	for iPlay := 0; iPlay < pGame.m_cPlay; ++iPlay
	{
		pPlay := &pGame.m_aPlay[iPlay]
		pBoard := &pGame.m_aBoard[iPlay]
		if pPlay.m_dTUntilSpawn < 0 && pPlay.m_pEntSteer == null && aFStepDown[iPlay]
		{
			xCellMidpoint := kDXCellBoard/2 - 1
			yCellSpawn := kDYCellBoardVisible - 1

			cGarbagePending := 0
			for iPlayOther := 0; iPlayOther < pGame.m_cPlay; ++iPlayOther
			{
				cGarbagePending += pPlay.m_mpIplayCGarbagePending[iPlayOther]
				pPlay.m_mpIplayCGarbagePending[iPlayOther] = 0
			}

			if cGarbagePending
			{
				for iGarbage := 0; iGarbage < cGarbagePending; ++iGarbage
				{
					xCellSearchMin, xCellSearchMax: int

					if (iGarbage % 0x2) == 1
					{
						xCellSearchMin = 0
						xCellSearchMax = xCellMidpoint
					}
					else
					{
						xCellSearchMin = xCellMidpoint
						xCellSearchMax = kDXCellBoard-1
					}

					// BB - should replace this with shuffle based search
					fFoundSpot := false
					for cRetry := 0; cRetry < 20; ++cRetry
					{
						xCellGarbage := NRandom(&pBoard.m_rng, cast (s32)xCellSearchMin, cast (s32)xCellSearchMax)

						if !FIsCellOccupied(pBoard, xCellGarbage, yCellSpawn)
						{
							pEntGarbage := PEntAllocate(&g_game.m_pEntUnusedFirst, ENTK.Garbage)
							if pEntGarbage
							{
								SetEnts(pEntGarbage, ENTS.Falling)
								pEntGarbage.m_pillcol = cast(PILLCOL)NRandom(&pBoard.m_rng, PILLCOL.min, PILLCOL.MaxPills)

								CutPos(pEntGarbage, PosFromCell(pBoard, xCellGarbage, yCellSpawn), DIR.Right)
								ReparentBoardEntity(pBoard, pEntGarbage)
							}
							break
						}
					}
				}
			}
			else
			{
				if FIsCellOccupied(pBoard, xCellMidpoint, yCellSpawn) ||
					FIsCellOccupied(pBoard, xCellMidpoint + 1, yCellSpawn)
				{
					SetGamres(pPlay, GAMRES.LoseOverflow)
				}
				else
				{
					pEntPill := PEntAllocate(&g_game.m_pEntUnusedFirst, ENTK.Pill)
					if pEntPill
					{
						SetEnts(pEntPill, ENTS.Falling)
						pEntPill.m_fHasTail = true
						pEntPill.m_pillcol = pPlay.m_pillcolNextHead
						pEntPill.m_pillcolTail = pPlay.m_pillcolNextTail

						pPlay.m_pillcolNextHead = cast(PILLCOL)NRandom(&pBoard.m_rng, PILLCOL.min, PILLCOL.MaxPills)
						pPlay.m_pillcolNextTail = cast(PILLCOL)NRandom(&pBoard.m_rng, PILLCOL.min, PILLCOL.MaxPills)

						CutPos(pEntPill, PosFromCell(pBoard, xCellMidpoint, yCellSpawn), pEntPill.m_dir)
						pPlay.m_pEntSteer = pEntPill

						ReparentBoardEntity(pBoard, pEntPill)
					}
				}
			}
		}
	}

	cWon, cLost, cPending: int
	pPlayPending: & SPlayer
	for iPlay := 0; iPlay < pGame.m_cPlay; ++iPlay
	{
		gamresCur := pGame.m_aPlay[iPlay].m_gamres
		if gamresCur >= GAMRES.LoseMin && gamresCur < GAMRES.LoseMax
		{
			++cLost
		}
		else if gamresCur >= GAMRES.WinMin && gamresCur < GAMRES.WinMax
		{
			++cWon
		}
		else 
		{
			++cPending
			pPlayPending = &pGame.m_aPlay[iPlay]
		}
	}

	if cPending <= 1 && cWon == 0 && pGame.m_cPlay > 1
	{
		if pPlayPending
		{
			SetGamres(pPlayPending, GAMRES.WinLastStanding)
			++cWon
		}
	}

	if cWon || cLost == pGame.m_cPlay
	{
		SetGams(pGame, GAMS.PostGame)

		for iPlay := 0; iPlay < pGame.m_cPlay; ++iPlay
		{
			pPlay := &pGame.m_aPlay[iPlay]
			if (pPlay.m_gamres == GAMRES.Pending)
			{
				SetGamres(pPlay, GAMRES.LoseTooSlow)
			}
		}
	}
}

SetGamres proc (pPlay: & SPlayer, gamres: GAMRES)
{
	pPlay.m_gamres = gamres
}

SetPlays proc (pPlay: & SPlayer, plays: PLAYS)
{
	pPlay.m_plays = plays
}

SetGams proc (pGame: & SGame, gams: GAMS)
{
	pGame.m_gams = gams
	pGame.m_dTGams = 0

	dXyVport := S32x2Create(kDXWindow, kDYWindow)
	switch (pGame.m_gams)
	{
		case GAMS.Pregame:
			for iBoard := 0; iBoard < pGame.m_aBoard.count; ++iBoard
			{
				pBoard := &pGame.m_aBoard[iBoard]

				pBoard.m_nRngSeed = cast(u32)NRandom(&g_rng, 0, 0xFFFFFFFF)
				SeedRandom(&pBoard.m_rng, pBoard.m_nRngSeed)
			}

			InitPlayers(&g_game)

			pGame.m_cPlay = kCPlayerMax
			for iBoard := 0; iBoard < pGame.m_cPlay; ++iBoard
		    {
			    ClearBoard(&pGame.m_aBoard[iBoard], pGame)
				InitBoard(iBoard, pGame.m_cPlay, dXyVport, &pGame.m_aBoard[iBoard], kCVirusStarting)
			}

		case GAMS.InGame:

			// BB - need to remap correct players (and controllers) if there are gaps in the players that have signed in
			cPlay := 0

			/*
			// set up player 2 as an autokill player (for testing)
			pPlayAuto := &pGame.m_aPlay[1]
			if pPlayAuto.m_plays == PLAYS.Inactive
			{
				SetPlays(pPlayAuto, PLAYS.PregameReady)
				pPlayAuto.m_grfplay = pPlayAuto.m_grfplay | FPLAY.Autokill
			}*/

			for iPlay := 0; iPlay < pGame.m_aPlay.count; ++iPlay
			{
				pPlay := &pGame.m_aPlay[iPlay]
				if pPlay.m_plays >= PLAYS.PregameReady
				{
					++cPlay
					SetPlays(pPlay, PLAYS.InGame)
				}
			}

			pGame.m_cPlay = cPlay
			for iBoard := 0; iBoard < pGame.m_cPlay; ++iBoard
		    {
			    ClearBoard(&pGame.m_aBoard[iBoard], pGame)
				InitBoard(iBoard, pGame.m_cPlay, dXyVport, &pGame.m_aBoard[iBoard], kCVirusStarting)
			}

		case GAMS.PostGame: 
			break
	}
}

UpdatePregame proc (pGame: & SGame, pDrac: & SDrawContext)
{
	pPlayZero := &pGame.m_aPlay[0]
	if pPlayZero.m_plays == PLAYS.Inactive
	{
		SetPlays(pPlayZero, PLAYS.PregameOptions)
	}

	cWaiting := 0
	for iPlay := 0; iPlay < pGame.m_aPlay.count; ++iPlay
	{
		pPlay := &pGame.m_aPlay[iPlay]
		pBoard := &pGame.m_aBoard[iPlay]
		pPlayinp := &pPlay.m_playinp

		posCenter := F32x2Cast(pBoard.m_pos) + F32x2Cast(pBoard.m_dXyBoard) * 0.5

		switch pPlay.m_plays
		{
			case PLAYS.Inactive:
				DrawTextCentered(pDrac, posCenter, "Press Start")
				if pPlayinp.m_mpButkEdges[BUTK.Select] == EDGES.Press
				{
					SetPlays(pPlay, PLAYS.PregameOptions)
				}

			case PLAYS.PregameOptions:

				aCh: [128] u8		
				snprintf(aCh, aCh.count, "Level: %d", pPlay.m_iStartingLevel)
				DrawTextCentered(pDrac, posCenter, aCh)

				snprintf(aCh, aCh.count, "Speed: %d", pPlay.m_iStartingLevel)
				DrawTextCentered(pDrac, posCenter, aCh)

				DrawTextCentered(pDrac, posCenter, "Press 'X' when ready")
				++cWaiting

				if pPlayinp.m_mpButkEdges[BUTK.Select] == EDGES.Press
				{
					SetPlays(pPlay, PLAYS.PregameReady)
				}
				if pPlayinp.m_mpButkEdges[BUTK.Cancel] == EDGES.Press
				{
					SetPlays(pPlay, PLAYS.Inactive)
				}
			case PLAYS.PregameReady:
				DrawTextCentered(pDrac, posCenter, "Ready")

				if pPlayinp.m_mpButkEdges[BUTK.Cancel] == EDGES.Press
				{
					SetPlays(pPlay, PLAYS.PregameOptions)
				}
		}
	}

	if cWaiting == 0
	{
		SetGams(pGame, GAMS.InGame)
	}
}

DrawGameResults proc (pDrac: & SDrawContext, pPlay: & SPlayer, pBoard: & SBoard)
{
	xMin : f32 = cast(f32)pBoard.m_pos.m_x
	yMin : f32 = cast(f32)pBoard.m_pos.m_y
	xMax : f32 = cast(f32)(pBoard.m_pos.m_x + pBoard.m_dXyBoard.m_x) + pBoard.m_gTileSpacing
	yMax : f32 = cast(f32)(pBoard.m_pos.m_y + pBoard.m_dXyBoard.m_y) + pBoard.m_gTileSpacing
	colvecBg : SColorVec

	kDYTextLine	:: 25

	posCenter := F32x2Cast(pBoard.m_pos) + F32x2Cast(pBoard.m_dXyBoard) * 0.5
	posCenter.m_y += kDYTextLine * 5
	aCh: [128] u8
	switch pPlay.m_gamres
	{
		case GAMRES.WinClearedAll,
			GAMRES.WinLastStanding:
			snprintf(aCh, aCh.count, "Winner!")
			colvecBg = ColvecFromCol(ColCreate(25, 25, 50, 130))
		case GAMRES.LoseOverflow,
			GAMRES.LoseTooSlow:
			snprintf(aCh, aCh.count, "You Lose.")
			colvecBg = ColvecFromCol(ColCreate(100, 0, 0, 100))
	}

	AppendTile(xMin, yMin, xMax, yMax, &colvecBg, &g_tilbuf)

	kGCharSizeWinLose :: 50
	kGCharSizeStats :: 20
	kGCharSizePrompt :: 30

	pFontd := &pDrac.m_pDras.m_fontd
	gCharSizePrev := pFontd.m_gCharSize

	pFontd.m_gCharSize = kGCharSizeWinLose
	DrawTextCentered(pDrac, posCenter, aCh)

	pFontd.m_gCharSize = kGCharSizeStats
	posCenter.m_y -= kDYTextLine * 5
	snprintf(aCh, aCh.count, "%d kills", pPlay.m_cKilledCells)
	DrawTextCentered(pDrac, posCenter, aCh)

	posCenter.m_y -= kDYTextLine
	snprintf(aCh, aCh.count, "%d garbage sent", pPlay.m_cGarbageSent)
	DrawTextCentered(pDrac, posCenter, aCh)

	posCenter.m_y -= kDYTextLine
	snprintf(aCh, aCh.count, "%d garbage received", pPlay.m_cGarbageReceived)
	DrawTextCentered(pDrac, posCenter, aCh)
	posCenter.m_y -= kDYTextLine
	snprintf(aCh, aCh.count, "%.2f seconds pressing down", pPlay.m_dTHoldDown)
	DrawTextCentered(pDrac, posCenter, aCh)

	pFontd.m_gCharSize = kGCharSizePrompt
	posCenter.m_y -= kDYTextLine * 5
	DrawTextCentered(pDrac, posCenter, "Press X To Continue.")

	pFontd.m_gCharSize = gCharSizePrev
}

main proc () -> int
{
	pWindow : HWND
	CreateWindow(kDXWindow, kDYWindow, "Physician PillMan", &pWindow)

	pDrac := PDracStaticInit(PVAllocDefault)
	if !pDrac
		{return 0 }

	pDrac.m_pDras.m_fontd.m_gCharSize = 20

	SetupOrthoViewport(0, 0, kDXWindow, kDYWindow)

	//SeedRandom(&g_rng, 0xBADDBEEF)
	SeedRandom(&g_rng, NTimeSeed())

    dRadSpin :: 0.01
    gRadSpin: float

	InitUnusedEntList(g_game.m_aEnt, &g_game.m_pEntUnusedFirst)

    // Make sure sleep has 1ms granularity
    s_cMsDesiredGranularity :: 1
    fIsSleepGranular := FTrySetTimerResolution(s_cMsDesiredGranularity)
    g_cTickPerSecond = CTickPerSecond() 

    nHzMonitorRefresh : s32 = GetMonitorRefresh(pWindow)
    nHzTarget := cast (f32)(nHzMonitorRefresh)

    dTFrameTarget := 1.0 / nHzTarget
	aChStatus: [512] u8

	cTickLast := CTickWallClock()
	fShouldClose := false
	dTGame: f32

	SetGams(&g_game, GAMS.Pregame)

	pVJoyman := CreateJoystickManager()
	InitJoysticks(&g_game)

	while fShouldClose == false
	{
		UpdateJoystickManager(pVJoyman)

		fShouldClose |= !FHandleEvents(&g_game)

		/*
		for iPlay := 1; iPlay < g_game.m_aPlay.count; ++iPlay
		{
			g_game.m_aPlay[iPlay].m_playinp = g_game.m_aPlay[0].m_playinp
		}*/

		gRadSpin += dRadSpin

		DrawBoards(&g_game, pDrac)
		//DrawMapBackground(aChMap, &g_tilbuf)
		//DrawEntities(aEnt, &g_tilbuf)

		for iPlay := 0; iPlay < g_game.m_cPlay; ++iPlay
		{
			pPlay := &g_game.m_aPlay[iPlay]
			if pPlay.m_gamres != GAMRES.Pending
			{
    			pBoard := &g_game.m_aBoard[iPlay]
    			DrawGameResults(pDrac, pPlay, pBoard)
    		}
		}

		FlushTileVerts(pDrac, &g_tilbuf)
		FlushFontVerts(pDrac, &g_Fvbuf)

		//DrawTestTriangle(gRadSpin)

        SwapBuffers(pWindow)
		ClearWindow(0, 0, 0, 1)

        UpdateWindowEvents()

        switch (g_game.m_gams)
        {
        	case GAMS.Pregame:
        		UpdatePregame(&g_game, pDrac)
        	case GAMS.InGame:
		        UpdatePlayers(&g_game, dTGame)
        	case GAMS.PostGame:
        		for iPlay := 0; iPlay < g_game.m_cPlay; ++iPlay
        		{
        			pPlay := &g_game.m_aPlay[iPlay]

					if g_game.m_dTGams > kDTEndgameMin && pPlay.m_playinp.m_mpButkEdges[BUTK.Select] == EDGES.Press
					{
						SetGams(&g_game, GAMS.Pregame)
					}
        		}
        }
        g_game.m_dTGams += dTGame
        //UpdateActors(aAct, &playinp, dTGame)
		//UpdatePuck(g_pActPuck, &playinp, dTGame, aChMap, &mapdim)
		//UpdateEntities(aEnt)

// 		if !s_fIsPaused
	    {
	    	cTickWork := CTickWallClock()
	    	dTWorkElapsed := DTElapsed(cTickLast, cTickWork)

	        dTElapsedFrame := dTWorkElapsed
	        if dTElapsedFrame < dTFrameTarget
	        {                        
	            if fIsSleepGranular
	            {
	                SleepMS := cast (u32)(1000.0 * (dTFrameTarget - dTElapsedFrame))
	                if SleepMS > 0
	                {
	                    Sleep(SleepMS)
	                }
	            }

	            while dTElapsedFrame < dTFrameTarget
	            {                            
	                dTElapsedFrame = DTElapsed(cTickLast, CTickWallClock())
	            }
	        }
	    }

	    cTickEnd := CTickWallClock()
	    dTFrameActual := DTElapsed(cTickLast, cTickEnd)
	    cTickLast = cTickEnd

	    nHzActual := 1 / dTFrameActual
	    snprintf(aChStatus, aChStatus.count, "%0.1f / %0.1f, %0.2f ms", nHzActual, nHzTarget, dTFrameActual * 1000)
		DrawText(pDrac, F32x2Create(20, kDYWindow - 35), aChStatus)

		dTGame = dTFrameActual
		g_systCur += dTGame
	}
	return 1
}