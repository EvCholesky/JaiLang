#import "Basic"
#import "Color"
#import "Font"
#import "GL"
#import "Math"

// Ideas:
// Each player has a color
// gems change which player you send garbage to
// garbage queues (with a color indicator) at the top
// Clocks slow down your fall rate, and send a speed up clock to your target - they last until the speed up clock is gone (or either clock?) 
// Need some kind of powerup to deal with vertical walls - a vertical column destroyer? something to push sideways? a magnet?

// orig: 64x128 px, 8x8 cells, 8x16 playspace

kDXWindow :: 1280
kDYWindow :: 720

kDXCellBoard :: 8
kDYCellBoard :: 16
kBoardBorderWidth :: 10
kDYBoardBorderBottom :: 30

kCCellPerBoard :: kDXCellBoard * kDYCellBoard
kEntMax :: kCCellPerBoard * kCPlayerMax
kYMaxVirusStart :: 12

kDTStartingSpawn :: 1
kDTNextPill	:: 0.20
kDTShowDead :: 0.2

kCVirusStarting :: 2 //20

kCPlayerMax :: 4

g_cTickPerSecond: s64 = 1

Syst typedef f64
g_systCur: f64
g_rng: SRandomGen

PILLCOL enum u8
{
	Red,
	Blue,
	Yellow,
	MaxPills,
	Green : MaxPills,	// extra color to allow for four player backgrounds
}

DIR enum u8
{
	Left,
	Up,
	Right,
	Down
}

ColFromPillcol proc (pillcol: PILLCOL) -> SColor
{
	switch pillcol
	{
		case PILLCOL.Red:	 	return ColCreate(231, 0, 90, 255)
		case PILLCOL.Blue:		return ColCreate(57, 189, 255, 255)
		case PILLCOL.Yellow:	return ColCreate(255, 189, 0, 255)
		case PILLCOL.Green:		return ColCreate(57, 255, 189, 255)
	}
	return ColCreate (255, 255, 255, 255)
}

STileVertex struct // tag=tilvert
{
	m_x, m_y: f32
	m_u, m_v: f32
	m_r, m_g, m_b, m_a: f32
}

STileVertexBuffer struct // tag=tilbuf
{
	m_aTilvert: [4096] STileVertex
	m_cTilvert: int
}
g_tilbuf: STileVertexBuffer

BUTK enum // button kind
{
	Up,
	Down,
	Left,
	Right,
	RotateClock,
	RotateCClock,
	Select,
	Cancel,
}

SPlayerInput struct // tag = playinp
{
	m_mpButkEdges: [BUTK.max] EDGES
}

GAMRES enum // GAMe RESult
{
	Pending,
	WinMin,
	WinClearedAll: WinMin,
	WinLastStanding,
	WinMax,

	LoseMin: WinMax,
	LoseOverflow: LoseMin,
	LoseTooSlow,
	LoseMax,
}

PLAYS enum s8 // PLAYer State
{
	Inactive,
	PregameOptions,
	PregameReady,
	InGame,
	PostGame,
}

FPLAY enum u8
{
	Autokill: 0x1,		// pills are killed as soon as they stabilize, used to test n players. Can't win, can't spawn garbage.
}

GAMS enum s8 // GAMe State
{
	Pregame,
	InGame,
	PostGame,
}

SPlayer struct // tag = play
{
	m_plays := PLAYS.nil
	m_gamres := GAMRES.nil
	m_grfplay: FPLAY.loose
	m_pillcol: PILLCOL
	m_iPlayerTarget: int						// player that will receive this player's garbage
	m_playinp: SPlayerInput

	m_mpIplayCGarbagePending: [kCPlayerMax] int	// how much garbage is pending from each player
	m_cKills: int

	m_dTUntilSpawn : f32 = kDTStartingSpawn 	// nothing was falling last update, spawn a new pill
	m_pEntSteer : & SEntity						// falling entity controlled by this player
}

SGame struct // tag = game
{
	m_aEnt : [kEntMax] SEntity
	m_pEntUnusedFirst: & SEntity		// list of unused entities

	m_aBoard: [kCPlayerMax] SBoard	

	m_gams := GAMS.nil
	m_cPlay:= 2
	m_aPlay: [kCPlayerMax] SPlayer
	m_dTStepDown : f32
}
g_game: SGame

SBoard struct
{
	m_dXyTile: s32x2	// pixel dims of each tile
	m_dXyBoard: s32x2	// total dims of the map
	m_gTileSpacing: s32
	m_pos: s32x2 		// lower left of the board

	m_iBoard: s32
	m_nRngSeed: u32	= 0xBADDBEEF
	m_rng: SRandomGen
	m_mpIcellPEnt: [kCCellPerBoard] & SEntity
}

ENTK enum s8 // ENTity Kind
{
	None,
	Pill,
	Virus,
	Garbage,
	Gem,
}

ENTS enum s8 // ENTity State
{
	Falling,
	Stable,
	Dead,
}

SEntity struct // tag = ent
{
	m_entk: ENTK
	m_ents: ENTS
	m_dTEnts: f32				// time in this state

	m_pos: f32x2				// pixel position
	m_pillcol: PILLCOL
	m_pillcolTail: PILLCOL		// other pill color (cause pills are one entity but two colors)
	m_dir:= DIR.Right 			// direction from pill head to tail

	m_iBoard	: s32 = -1
	m_iCellParent : s32 = -1	// board cell this entity is parented to
	m_iCellParentTail : s32 = -1

	m_pEntUnusedNext: & SEntity

	m_fHasTail := true			// NOTE: pills should never have a tail but no head!
}

InitPlayers proc (pGame: & SGame)
{
	/*
	pGame.m_aPlay[0].m_col = PILLCOL.Red
	pGame.m_aPlay[1].m_col = PILLCOL.Blue
	pGame.m_aPlay[2].m_col = PILLCOL.Yellow
	pGame.m_aPlay[3].m_col = PILLCOL.Green
	*/

	for iPlay := 0; iPlay < pGame.m_cPlay; ++iPlay
	{
		pPlay := &pGame.m_aPlay[iPlay]
		if pPlay.m_plays == PLAYS.nil
		{
			SetPlays(pPlay, PLAYS.Inactive)
		}

		pPlay.m_pEntSteer = null
		pPlay.m_pillcol = cast(PILLCOL)iPlay
		pPlay.m_iPlayerTarget = (iPlay + 1) % pGame.m_cPlay
		pPlay.m_dTUntilSpawn = kDTStartingSpawn

		SetGamres(pPlay, GAMRES.Pending)

		if (pPlay.m_grfplay & FPLAY.Autokill) != 0
		{
	    	SetPlays(pPlay, PLAYS.Inactive)	
		}
    	else if pPlay.m_plays != PLAYS.Inactive
    	{
	    	SetPlays(pPlay, PLAYS.PregameOptions)	
	    }
	}
}

PosFromCell proc (pBoard: & SBoard, xCell: int, yCell: int) -> f32x2 
{
	// should this include board origin?
	return F32x2Create(cast(f32)(xCell * pBoard.m_dXyTile.m_x),  cast(f32)(yCell * pBoard.m_dXyTile.m_y))
}

InitUnusedEntList proc (aEntAll: [] SEntity, ppEntFirst: && SEntity)
{
	ppEntPrev := ppEntFirst
	for iEnt:= 0; iEnt < aEntAll.count; ++iEnt
	{
		pEnt := &aEntAll[iEnt]
		@ppEntPrev = pEnt
		ppEntPrev = &pEnt.m_pEntUnusedNext
	}

	@ppEntPrev = null
}

PEntAllocate proc (ppEntFirst: && SEntity, entk: ENTK) -> & SEntity
{
	if (!ppEntFirst || !@ppEntFirst)
		{ return null }

	pEnt := @ppEntFirst
	pEnt.m_fHasTail = false
	pEnt.m_dir = DIR.Right

	@ppEntFirst = pEnt.m_pEntUnusedNext

	pEnt.m_pEntUnusedNext = null
	pEnt.m_entk = entk
	pEnt.m_ents = ENTS.Stable
	return pEnt
}

FreeEntity proc (pGame: & SGame, ppEntFirst: && SEntity, pEnt: & SEntity)
{
	if !fverify(pEnt.m_pEntUnusedNext == null, "freeing entity that is already unused", #file, #line)
		{ return }

	if fverify(pEnt.m_iBoard >= 0, "bad board", #file, #line)
	{
		assert(pEnt.m_iCellParent >= 0, "partially parented entity", #file, #line)
		pBoard := &pGame.m_aBoard[pEnt.m_iBoard]

		UnparentBoardEntity(pBoard, pEnt)
		//assert(pBoard.m_mpIcellPEnt[pEnt.m_iCellParent] == pEntj, "bad entity parenting")
		//pBoard.m_mpIcellPEnt[pEnt.m_iCellParent] = null
	}

	pEnt.m_iBoard = -1

	pEnt.m_pEntUnusedNext = @ppEntFirst
	@ppEntFirst = pEnt
}

PosCell proc (pBoard: & SBoard, pos: f32x2) -> s32x2
{
	//xCell := NFloor(pos.m_x / cast(f32)pBoard.m_dXyTile.m_x)
	//yCell := NFloor(pos.m_y / cast(f32)pBoard.m_dXyTile.m_y)
	xCell := NRound(pos.m_x) / pBoard.m_dXyTile.m_x
	yCell := NRound(pos.m_y) / pBoard.m_dXyTile.m_y
	return S32x2Create(xCell, yCell)
}

ICellFromPos proc (pBoard: & SBoard, pos: f32x2) -> s32
{
	//xCell := NFloor(pos.m_x / cast(f32)pBoard.m_dXyTile.m_x)
	//yCell := NFloor(pos.m_y / cast(f32)pBoard.m_dXyTile.m_y)
	xCell := NRound(pos.m_x) / pBoard.m_dXyTile.m_x
	yCell := NRound(pos.m_y) / pBoard.m_dXyTile.m_y
	return ICell(xCell, yCell)
}

ICell proc (posCell: s32x2) -> s32
{
	return posCell.m_x + posCell.m_y * kDXCellBoard	
}

ICell proc (xCell: int, yCell: int) -> s32
{
	return cast(s32)(xCell + yCell * kDXCellBoard)
}

CELOOK enum // CEll LOOKup
{
	ExcludeTail,
	IncludeTail,
}

PEntFromCell proc (pBoard: & SBoard, xCell: int, yCell: int, celook: CELOOK) -> & SEntity
{
	pEnt := pBoard.m_mpIcellPEnt[ICell(xCell, yCell)]
	if pEnt
	{
		iCell := ICell(xCell, yCell)
		if iCell == pEnt.m_iCellParentTail && celook == CELOOK.ExcludeTail
			{ return null }

		//iCellPos := ICellFromPos(pBoard, pEnt.m_pos)
		//assert(iCell == iCellPos, "bad cell calculation in lookup", #file, #line)
	}
	return pEnt
}

FIsCellOccupied proc (pBoard: & SBoard, xCell: int, yCell: int) -> bool
{
	if xCell < 0 || xCell >= kDXCellBoard || yCell < 0 || yCell >= kDYCellBoard
		{ return true }

	return PEntFromCell(pBoard, xCell, yCell, CELOOK.IncludeTail) != null
}

FIsCellOccupied proc (pBoard: & SBoard, xCell: int, yCell: int, pEntIgnore: & SEntity) -> bool
{
	if xCell < 0 || xCell >= kDXCellBoard || yCell < 0 || yCell >= kDYCellBoard
		{ return true }

	pEnt := PEntFromCell(pBoard, xCell, yCell, CELOOK.IncludeTail)
	return pEnt != null && pEnt != pEntIgnore
}


PillcolFromCell proc (pBoard: & SBoard, xCell: int, yCell: int) -> PILLCOL
{
	pEnt := PEntFromCell(pBoard, xCell, yCell, CELOOK.IncludeTail)
	if !pEnt || pEnt.m_ents != ENTS.Stable
		{ return PILLCOL.nil }

	iCell := ICell(xCell, yCell)
	if iCell == pEnt.m_iCellParentTail
		{ return pEnt.m_pillcolTail }

	return pEnt.m_pillcol
}

KillCell proc (pBoard: & SBoard, xCell: int, yCell: int)
{
	pEnt := PEntFromCell(pBoard, xCell, yCell, CELOOK.IncludeTail)

	// Need to handle tails
	if pEnt
	{
		posCell := PosCell(pBoard, pEnt.m_pos)

		if pEnt.m_fHasTail
		{
			pEnt.m_fHasTail = false
			ReparentBoardEntity(pBoard, pEnt)

			pEntTail := PEntAllocate(&g_game.m_pEntUnusedFirst, pEnt.m_entk)
			pEntTail.m_fHasTail = false
			pEntTail.m_pillcol = pEnt.m_pillcolTail

			posCellTail := posCell + DCellFromDir(pEnt.m_dir)
			pEntTail.m_pos = PosFromCell(pBoard, posCellTail.m_x, posCellTail.m_y)

			ReparentBoardEntity(pBoard, pEntTail)
			if posCellTail.m_x == xCell && posCellTail.m_y == yCell
			{
				SetEnts(pEntTail, ENTS.Dead)
			}
		}

		if posCell.m_x == xCell && posCell.m_y == yCell
		{
			SetEnts(pEnt, ENTS.Dead)
		}
	}
}

SetEnts proc (pEnt: & SEntity, entsNew: ENTS)
{
	if pEnt.m_ents == entsNew
		{ return }

	pEnt.m_ents = entsNew
	pEnt.m_dTEnts = 0
}

DCellFromDir proc (dir: DIR) -> s32x2
{
	switch dir
	{
		case DIR.Left: 	return S32x2Create(-1, 0)
		case DIR.Right: return S32x2Create(1, 0)
		case DIR.Down: 	return S32x2Create(0, -1)
		case DIR.Up: 	return S32x2Create(0, 1)
	}

	assert(false, "unknown dir", #file, #line)
	return S32x2Create(0, 0)
}

UnparentBoardEntity proc (pBoard: & SBoard, pEnt: & SEntity)
{
	if pEnt.m_iCellParent >= 0
	{
		assert(pBoard.m_mpIcellPEnt[pEnt.m_iCellParent] == pEnt, "bad entity parenting", #file, #line)
		pBoard.m_mpIcellPEnt[pEnt.m_iCellParent] = null
		pEnt.m_iCellParent = -1

		if pEnt.m_iCellParentTail >= 0
		{
			assert(pBoard.m_mpIcellPEnt[pEnt.m_iCellParentTail] == pEnt, "bad entity parenting", #file, #line)
			pBoard.m_mpIcellPEnt[pEnt.m_iCellParentTail] = null
			pEnt.m_iCellParentTail = -1
		}
	}
}

ReparentBoardEntity proc (pBoard: & SBoard, pEnt: & SEntity)
{
	//if iCellNew == pEnt.m_iCellParent	
	//	{ return }

	pEnt.m_iBoard = pBoard.m_iBoard
	UnparentBoardEntity(pBoard, pEnt)

	posCell := PosCell(pBoard, pEnt.m_pos)
	pEnt.m_iCellParent = ICell(posCell)
	assert(pBoard.m_mpIcellPEnt[pEnt.m_iCellParent] == null, "trying to parent to occupied cell", #file, #line)
	pBoard.m_mpIcellPEnt[pEnt.m_iCellParent] = pEnt
	
	if (pEnt.m_fHasTail)
	{
		dPosCell := DCellFromDir(pEnt.m_dir)	
		pEnt.m_iCellParentTail = ICell(posCell + dPosCell)
		assert(pBoard.m_mpIcellPEnt[pEnt.m_iCellParentTail] == null, "trying to parent tail to occupied cell", #file, #line)
		pBoard.m_mpIcellPEnt[pEnt.m_iCellParentTail] = pEnt
	}
}

ClearBoard proc (pBoard: & SBoard, pGame: & SGame)
{
	for yCell := 0; yCell < kDYCellBoard; ++yCell
	{	
		for xCell := 0; xCell < kDXCellBoard; ++xCell
		{
			pEnt := PEntFromCell(pBoard, xCell, yCell, CELOOK.ExcludeTail)
			if pEnt
			{
				FreeEntity(pGame, &pGame.m_pEntUnusedFirst, pEnt)
			}
		}
	}
}

InitBoard proc (iPlay: int, cPlay: int,	dXyVport: s32x2, pBoard: & SBoard, cVirus: int)
{
	// 40 x 40
	kDYBorderTop :: 92
	kDYBorderBottom :: 44
	kDXBorderLeft :: 30
	kDXBorderRight :: 30
	kDXBorderMiddle :: 30

	// find our cell size
	dYMax := cast(s32)dXyVport.m_y - (kDYBorderTop + kDYBorderBottom)
	dYCell := dYMax / kDYCellBoard

	dXBoard : s32 = cast(s32)((dXyVport.m_x - (kDXBorderLeft + kDXBorderRight + (cPlay - 1) * kDXBorderMiddle)) / cPlay)
	dXCell := dXBoard / kDXCellBoard

	dXCell = NMin(dXCell, dYCell)	
	dYCell = dXCell

	pBoard.m_dXyTile = S32x2Create(cast(s32)dXCell, cast(s32)dYCell)
	pBoard.m_gTileSpacing = pBoard.m_dXyTile.m_x / 8 

	pBoard.m_dXyBoard = S32x2Create(cast(s32)dXCell * kDXCellBoard, cast(s32)dYCell * kDYCellBoard)

	dXBoardSep := dXyVport.m_x / cPlay
	pBoard.m_pos = S32x2Create(cast(s32)((dXBoard + kDXBorderMiddle) * iPlay) + kDXBorderLeft, kDYBorderBottom)

	SeedRandom(&pBoard.m_rng, pBoard.m_nRngSeed)

	pBoard.m_iBoard = cast(s32)iPlay

	// BB - there are better ways to do this
	cRetry := 0
	for iVirus:= 0; iVirus < cVirus; ++iVirus
	{
		pEntVirus := PEntAllocate(&g_game.m_pEntUnusedFirst, ENTK.Virus)
		pEntVirus.m_fHasTail = false

		pillcol := cast(PILLCOL)NRandom(&pBoard.m_rng, PILLCOL.min, PILLCOL.MaxPills)
		pEntVirus.m_pillcol = pillcol

		while true
		{
			xCell := NRandom(&pBoard.m_rng, 0, kDXCellBoard)
			yCell := NRandom(&pBoard.m_rng, 0, kYMaxVirusStart)

			if !FIsCellOccupied(pBoard, xCell, yCell)
			{
				pEntVirus.m_pos = PosFromCell(pBoard, xCell, yCell)
				ReparentBoardEntity(pBoard, pEntVirus)
				break
			}
			else
			{
				++cRetry 
			}
		}
	}

	printf("cells are %d x %d. Board is %d x %d\n", dXCell, dYCell, pBoard.m_dXyBoard.m_x, pBoard.m_dXyBoard.m_y)
	printf("%d retries\n", cRetry)
}

DrawOutsideBorder proc (xMin: f32, yMin: f32, xMax: f32, yMax: f32, sWidth: f32, colvec: SColorVec)
{
	AppendTile(xMin - sWidth, yMin - sWidth, xMin, yMax + sWidth, &colvec, &g_tilbuf)	// left
	AppendTile(xMax, yMin - sWidth, xMax + sWidth, yMax + sWidth, &colvec, &g_tilbuf)	// right

	AppendTile(xMin, yMin - sWidth, xMax, yMin, &colvec, &g_tilbuf)	// bottom
	AppendTile(xMin, yMax, xMax, yMax + sWidth, &colvec, &g_tilbuf)	// bottom
}

DrawInsideBorder proc (xMin: f32, yMin: f32, xMax: f32, yMax: f32, sWidth: f32, colvec: SColorVec)
{
	xMinAdj := xMin + sWidth
	yMinAdj := yMin + sWidth
	xMaxAdj := xMax - sWidth
	yMaxAdj := yMax - sWidth
	DrawOutsideBorder(xMinAdj, yMinAdj, xMaxAdj, yMaxAdj, sWidth, colvec)
}

DrawBoardBackground proc (pBoard: & SBoard, pillcolSelf: PILLCOL, pillcolTarget: PILLCOL)
{
	xMin : f32 = cast(f32)pBoard.m_pos.m_x
	yMin : f32 = cast(f32)pBoard.m_pos.m_y
	xMax : f32 = cast(f32)(pBoard.m_pos.m_x + pBoard.m_dXyBoard.m_x + pBoard.m_gTileSpacing)
	yMax : f32 = cast(f32)(pBoard.m_pos.m_y + pBoard.m_dXyBoard.m_y + pBoard.m_gTileSpacing)

	colvecBorder := ColvecFromCol(ColFromPillcol(pillcolSelf))
	DrawOutsideBorder(xMin, yMin, xMax, yMax, kBoardBorderWidth, colvecBorder)

	dYBottom: f32 = kDYBoardBorderBottom  - kBoardBorderWidth
	xMin -= kBoardBorderWidth
	xMax += kBoardBorderWidth
	yMin -= kBoardBorderWidth
	AppendTile(xMin, yMin - dYBottom, xMax, yMin, &colvecBorder, &g_tilbuf)

}

DrawEntity proc (pEnt: & SEntity, pBoard: & SBoard)
{
	kVirusBorderWidth :: 3
	kDeadEntWidth :: 3

	posMin := pEnt.m_pos + F32x2Cast(pBoard.m_pos)
	posMax := posMin + F32x2Cast(pBoard.m_dXyTile)
	posMin.m_x += cast(f32)pBoard.m_gTileSpacing
	posMin.m_y += cast(f32)pBoard.m_gTileSpacing

	colvecEnt := ColvecFromCol(ColFromPillcol(pEnt.m_pillcol))	

	kULerpStable :: 0.7
	colvecStable := ColvecFromCol(ColCreate(0, 0, 0, 255))
	uLerpStable := 1.0
	if pEnt.m_ents == ENTS.Stable
	{
		uLerpStable = kULerpStable
		colvecEnt = ColvecLerp(colvecStable, colvecEnt, uLerpStable)
	}

	switch pEnt.m_entk	
	{
		case ENTK.Virus:

			if pEnt.m_ents != ENTS.Dead
			{
				posMin.m_x += kVirusBorderWidth
				posMin.m_y += kVirusBorderWidth
				posMax.m_x -= kVirusBorderWidth
				posMax.m_y -= kVirusBorderWidth

				AppendTile(posMin.m_x, posMin.m_y, posMax.m_x, posMax.m_y, &colvecEnt, &g_tilbuf)

				colvecBorder := ColvecFromCol(ColCreate(165, 231, 255, 255))
				colvecBorder = ColvecLerp(colvecStable, colvecBorder, uLerpStable)

				DrawOutsideBorder(posMin.m_x, posMin.m_y, posMax.m_x, posMax.m_y, kVirusBorderWidth, colvecBorder)
			}
			else
			{
				DrawInsideBorder(posMin.m_x, posMin.m_y, posMax.m_x, posMax.m_y, kVirusBorderWidth, colvecEnt)
			}

		case ENTK.Pill:

			gHalfSpacing := cast(f32)pBoard.m_gTileSpacing/2
			posMinTail := posMin
			posMaxTail := posMax

			if pEnt.m_fHasTail
			{
				switch pEnt.m_dir
				{
					case DIR.Left: 
						posMinTail.m_x -= cast(f32)pBoard.m_dXyTile.m_x
						posMin.m_x -= gHalfSpacing
						posMaxTail.m_x = posMin.m_x
					case DIR.Right: 
						posMaxTail.m_x += cast(f32)pBoard.m_dXyTile.m_x
						posMax.m_x += gHalfSpacing
						posMinTail.m_x = posMax.m_x
					case DIR.Up: 
						posMaxTail.m_y += cast(f32)pBoard.m_dXyTile.m_y
						posMax.m_y += gHalfSpacing
						posMinTail.m_y = posMax.m_y
					case DIR.Down: 
						posMinTail.m_y -= cast(f32)pBoard.m_dXyTile.m_y
						posMin.m_y -= gHalfSpacing
						posMaxTail.m_y = posMin.m_y
				}
			}

			if (pEnt.m_ents != ENTS.Dead)	
			{
				AppendTile(posMin.m_x, posMin.m_y, posMax.m_x, posMax.m_y, &colvecEnt, &g_tilbuf)

				// debug marker for primary cell
				colvecLight := ColvecLerp(ColvecFromCol(ColCreate(255,255,255,255)), colvecEnt, 0.5)
				AppendTile(posMin.m_x + 5, posMax.m_y - 10, posMin.m_x + 10, posMax.m_y - 5, &colvecLight, &g_tilbuf)

				if (pEnt.m_fHasTail)
				{
					colvecTail := ColvecFromCol(ColFromPillcol(pEnt.m_pillcolTail))	
					colvecTail = ColvecLerp(colvecStable, colvecTail, uLerpStable)

					AppendTile(posMinTail.m_x, posMinTail.m_y, posMaxTail.m_x, posMaxTail.m_y, &colvecTail, &g_tilbuf)
				}
			}
			else
			{
				DrawInsideBorder(posMin.m_x, posMin.m_y, posMax.m_x, posMax.m_y, kDeadEntWidth, colvecEnt)

				if (pEnt.m_fHasTail)
				{
					colvecTail := ColvecFromCol(ColFromPillcol(pEnt.m_pillcolTail))
					colvecTail = ColvecLerp(colvecStable, colvecTail, uLerpStable)

					DrawInsideBorder(posMinTail.m_x, posMinTail.m_y, posMaxTail.m_x, posMaxTail.m_y, kDeadEntWidth, colvecTail)
				}
			}
		case ENTK.Garbage:
			if pEnt.m_ents != ENTS.Dead
			{
				gHalfSpacing := cast(f32)pBoard.m_gTileSpacing/2
				posHalf := F32x2Create(gHalfSpacing, gHalfSpacing)

				posSplitBegin := posMin + (posMax - posMin) * 0.5
				posSplitEnd := posSplitBegin + posHalf
				posSplitBegin -= posHalf

				AppendTile(posMin.m_x, posMin.m_y, posSplitBegin.m_x, posSplitBegin.m_y, &colvecEnt, &g_tilbuf)
				AppendTile(posMin.m_x, posSplitEnd.m_y, posSplitBegin.m_x, posMax.m_y, &colvecEnt, &g_tilbuf)

				AppendTile(posSplitEnd.m_x, posMin.m_y, posMax.m_x, posSplitBegin.m_y, &colvecEnt, &g_tilbuf)
				AppendTile(posSplitEnd.m_x, posSplitEnd.m_y, posMax.m_x, posMax.m_y, &colvecEnt, &g_tilbuf)
			}
			else
			{
				DrawInsideBorder(posMin.m_x, posMin.m_y, posMax.m_x, posMax.m_y, kVirusBorderWidth, colvecEnt)
			}
	}

}

DrawGarbage proc (pBoard: & SBoard, posMin: f32x2, colvec: SColorVec)
{
	posMax := posMin + F32x2Cast(pBoard.m_dXyTile)

	gHalfSpacing := cast(f32)pBoard.m_gTileSpacing/2
	dPosHalf := F32x2Create(gHalfSpacing, gHalfSpacing)

	posSplitBegin := posMin + (posMax - posMin) * 0.5
	posSplitEnd := posSplitBegin + dPosHalf
	posSplitBegin -= dPosHalf

	AppendTile(posMin.m_x, posMin.m_y, posSplitBegin.m_x, posSplitBegin.m_y, &colvec, &g_tilbuf)
	AppendTile(posMin.m_x, posSplitEnd.m_y, posSplitBegin.m_x, posMax.m_y, &colvec, &g_tilbuf)

	AppendTile(posSplitEnd.m_x, posMin.m_y, posMax.m_x, posSplitBegin.m_y, &colvec, &g_tilbuf)
	AppendTile(posSplitEnd.m_x, posSplitEnd.m_y, posMax.m_x, posMax.m_y, &colvec, &g_tilbuf)
}


DrawBoards proc (pGame : & SGame, pDrac: & SDrawContext)
{
	for iPlay:=0; iPlay < pGame.m_cPlay; ++iPlay
	{
		cVirusLiving: int
		pPlay := pGame.m_aPlay[iPlay]
		iPlayTarget  := iPlay
		if (pPlay.m_iPlayerTarget >= 0)
			{ iPlayTarget = pPlay.m_iPlayerTarget }

		pBoard := &pGame.m_aBoard[iPlay]
		DrawBoardBackground(pBoard, pPlay.m_pillcol, pGame.m_aPlay[iPlayTarget].m_pillcol)

		for yCell := 0; yCell < kDYCellBoard; ++yCell
		{	
			for xCell := 0; xCell < kDXCellBoard; ++xCell
			{
				pEnt := PEntFromCell(pBoard, xCell, yCell, CELOOK.ExcludeTail)
				if pEnt
				{ 
					DrawEntity(pEnt, pBoard)
					if pEnt.m_entk == ENTK.Virus
					{
						++cVirusLiving
					}
				}
			}
		}

		kRGarbageTrimBottom :: 0.25
		kRGarbageSpacing :: 1.25

		posGarbage := pBoard.m_pos + S32x2Create(-kBoardBorderWidth, kBoardBorderWidth)
		posGarbage.m_y += pBoard.m_dXyBoard.m_y + cast(s32)(cast(f32)pBoard.m_dXyTile.m_y * kRGarbageTrimBottom)

		for iPlayOther:=0; iPlayOther < pGame.m_cPlay; ++iPlayOther
		{
			pPlayOther := &pGame.m_aPlay[iPlayOther]
			colvec := ColvecFromCol(ColFromPillcol(pPlayOther.m_pillcol))

			cGarbage := pPlay.m_mpIplayCGarbagePending[iPlayOther]
			for iGarbage := 0; iGarbage < cGarbage; ++iGarbage
			{
				DrawGarbage(pBoard, F32x2Cast(posGarbage), colvec)	
				posGarbage.m_x += cast(s32)(cast(f32)pBoard.m_dXyTile.m_x * kRGarbageSpacing)
			}
		}

		posLabel := pBoard.m_pos
		posLabel.m_x += pBoard.m_dXyBoard.m_x / 2
		posLabel.m_y -= kDYBoardBorderBottom - 5

		aChVirusCount: [16] u8
		snprintf(aChVirusCount, aChVirusCount.count, "%d", cVirusLiving)
		DrawTextCentered(pDrac, F32x2Cast(posLabel), aChVirusCount)
	}
}

ClearPlayerInput proc (pPlayinp: & SPlayerInput)
{
	for butk := BUTK.min; butk != butk.max; ++butk
	{
		pPlayinp.m_mpButkEdges[butk] = EDGES.Off
	}
}

AdvancePlayerInput proc (pPlayinp: & SPlayerInput)
{
	for butk := BUTK.min; butk != butk.max; ++butk
	{
		if pPlayinp.m_mpButkEdges[butk] >= EDGES.Hold
		{
			pPlayinp.m_mpButkEdges[butk] = EDGES.Hold
		}
		else
		{
			pPlayinp.m_mpButkEdges[butk] = EDGES.Off
		}
	}
}

FHandleEvents proc (pPlayinp: & SPlayerInput) -> bool
{
	mpKeycodeButk: [BUTK.max] KEYCODE = 
	{	
		KEYCODE.ArrowUp, 		//Up,
		KEYCODE.ArrowDown, 		//Down,
		KEYCODE.ArrowLeft, 		//Left,
		KEYCODE.ArrowRight, 	//Right,
		KEYCODE.KeyA,			//RotateClock,
		KEYCODE.KeyS,			//RotateCClock,
		KEYCODE.Enter, 			//Select,
		KEYCODE.F3				//Cancel,
	}	

	AdvancePlayerInput(pPlayinp)

	event : SEvent
	while FGetNextEvent(&event)
	{
		//printf("Event: keycode=%d, edges = %d\n", event.m_keycode, event.m_edges)
		if event.m_keycode == KEYCODE.Escape && event.m_edges == EDGES.Press
			{ return false }

		//HandlePlayerInputEvent(&event, pPlayinp)

		for butk := BUTK.min; butk != BUTK.max; ++butk
		{
			if event.m_keycode == mpKeycodeButk[butk]
			{
				pPlayinp.m_mpButkEdges[butk] = event.m_edges
				break	
			}
		}
	}

	return true
}
DTElapsed proc (cTickStart: s64, cTickEnd: s64) -> f32 inline
{
    return cast (f32)(cTickEnd - cTickStart) / cast(f32)g_cTickPerSecond
}

AppendTile proc (
			xMin: float, yMin: float,
			xMax: float, yMax: float,
			colvec: & SColorVec,
			pTilbuf: & STileVertexBuffer)
{
	if pTilbuf.m_aTilvert.count < pTilbuf.m_cTilvert + 4
		{ return }

	AppendTilvert(
		xMin, yMax,
		0,	0,	// u, v
		colvec.m_x, colvec.m_y, colvec.m_z, colvec.m_w,
		pTilbuf)

	AppendTilvert(
		xMax, yMax,
		0,	0,	// u, v
		colvec.m_x, colvec.m_y, colvec.m_z, colvec.m_w,
		pTilbuf)

	AppendTilvert(
		xMax, yMin,
		0,	0,	// u, v
		colvec.m_x, colvec.m_y, colvec.m_z, colvec.m_w,
		pTilbuf)

	AppendTilvert(
		xMin, yMin,
		0,	0,	// u, v
		colvec.m_x, colvec.m_y, colvec.m_z, colvec.m_w,
		pTilbuf)
}

AppendTilvert proc (
				x: float, y: float, 
				u: float, v: float, 
				r: float, g: float, b: float, a: float, 
				pTilbuf: & STileVertexBuffer) inline
{
	pTilvert: & STileVertex = &pTilbuf.m_aTilvert[pTilbuf.m_cTilvert]
	++pTilbuf.m_cTilvert

	pTilvert.m_x = x
	pTilvert.m_y = y

	pTilvert.m_u = u
	pTilvert.m_v = v

	pTilvert.m_r = r
	pTilvert.m_g = g
	pTilvert.m_b = b
	pTilvert.m_a = a
}

FlushTileVerts proc (pDrac: & SDrawContext, pTilbuf: & STileVertexBuffer)
{
	aTilvert: [] STileVertex = pTilbuf.m_aTilvert

	// push orthographic projection
	glPushMatrix()
	glLoadIdentity()

	// set scissor rect

	// set up shader
	//glEnable(GL_BLEND)
	//glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)
	assert(pDrac.m_pShman != null, "NULL GContext in flushTileVerts", #file, #line)
	BeginShader(pDrac.m_pShman, pDrac.m_pShman.m_mpCoreshkShhand[CORESHK.Sprite])

	//pTex := pFontman.m_aFont[fontk].m_pTex
	//SetShaderParam(pFontman.m_mpFontshkIParamTex[iShhand], pTex, 0)

	pTilvert := &aTilvert[0]
	glVertexPointer(3, GL_FLOAT, cast (s32) sizeof(STileVertex), &aTilvert[0].m_x)
	glEnableClientState(GL_VERTEX_ARRAY)
			
	glColorPointer(4, GL_FLOAT, cast (s32) sizeof(STileVertex), &aTilvert[0].m_r)
	glEnableClientState(GL_COLOR_ARRAY)

	glClientActiveTexture(GL_TEXTURE0)
	glTexCoordPointer(2, GL_FLOAT, cast (s32) sizeof(STileVertex), &aTilvert[0].m_u)
	glEnableClientState(GL_TEXTURE_COORD_ARRAY)

	glDrawArrays(GL_QUADS, 0, cast (s32) pTilbuf.m_cTilvert)

	//if (pTex)
	//{
	//	glDisable(pTex.m_druTarget)
	//}

	glDisableClientState(GL_VERTEX_ARRAY)
	glDisableClientState(GL_COLOR_ARRAY)	
	glDisableClientState(GL_TEXTURE_COORD_ARRAY)

	EndShader()

	glPopMatrix()

	pTilbuf.m_cTilvert = 0
}	

UpdatePlayers proc (pGame : & SGame, dT: f32)
{
	kDTStepDown :: 0.4
	fStepDown := false

	pGame.m_dTStepDown += dT
	if pGame.m_dTStepDown > kDTStepDown
	{
		fStepDown = true
		pGame.m_dTStepDown = 0
	}

	for iPlay := 0; iPlay < pGame.m_cPlay; ++iPlay
	{
		pBoard := &g_game.m_aBoard[iPlay]
		pPlay := &g_game.m_aPlay[iPlay]
		pPlayinp := &pPlay.m_playinp

		kDCellPerSecond :: 0
		kDCellPerSecondPressDown :: 20
		dCellPerSecond : f32 = kDCellPerSecond

		// update steering for player pill
		if (pPlay.m_pEntSteer)
		{
			pEntSteer := pPlay.m_pEntSteer

			posNew := pEntSteer.m_pos
			dirNew := pEntSteer.m_dir
			posCell := PosCell(pBoard, pEntSteer.m_pos)

			if pPlayinp.m_mpButkEdges[BUTK.Right] == EDGES.Press
			{ 
				xCellMax := posCell.m_x + 1
				if pEntSteer.m_fHasTail && pEntSteer.m_dir == DIR.Right
					{ ++xCellMax }

				if xCellMax < kDXCellBoard && !FIsCellOccupied(pBoard, xCellMax, posCell.m_y)
				{
					posNew.m_x = cast(f32)((posCell.m_x + 1) * pBoard.m_dXyTile.m_x)
				}
			}
			if pPlayinp.m_mpButkEdges[BUTK.Left] == EDGES.Press
			{
				xCellMin := posCell.m_x - 1
				if pEntSteer.m_fHasTail && pEntSteer.m_dir == DIR.Left
					{ --xCellMin }

				if xCellMin >= 0 && !FIsCellOccupied(pBoard, xCellMin, posCell.m_y)
				{
					posNew.m_x = cast(f32)((posCell.m_x - 1) * pBoard.m_dXyTile.m_x)
				}
			}

			dCellDir := DCellFromDir(dirNew)
			posCellMin := S32x2Min(posCell, posCell + dCellDir)

			dirTry := dirNew

			if pPlayinp.m_mpButkEdges[BUTK.RotateClock] == EDGES.Press
			{
				dirTry = (dirNew + 1) % DIR.max
			}

			if pPlayinp.m_mpButkEdges[BUTK.RotateCClock] == EDGES.Press
			{
				dirTry = (dirNew + DIR.max - 1) % DIR.max
			}

			posCellCheck: s32x2
			posCellCheckAlt: s32x2
			switch dirTry
			{
				case DIR.Left,
					DIR.Right:
					posCellCheck = posCellMin + S32x2Create(1, 0)
					posCellCheckAlt = posCellMin + S32x2Create(-1, 0)
				case DIR.Up,
					DIR.Down:
					posCellCheck = posCellMin + S32x2Create(0, 1)
					posCellCheckAlt = posCellMin + S32x2Create(1, 1)
			}

			posCellDest: s32x2 
			switch dirTry
			{
				case DIR.Right,
					DIR.Up:
						posCellDest = posCellMin
				case DIR.Left,
					DIR.Down: 
						posCellDest = posCellMin - DCellFromDir(dirTry)
			}

			if dirTry != dirNew 
			{
				if !FIsCellOccupied(pBoard, posCellCheck.m_x, posCellCheck.m_y, pEntSteer)  
				{
					posNew = F32x2Cast(posCellDest * pBoard.m_dXyTile)
					dirNew = dirTry
				}
				else if !FIsCellOccupied(pBoard, posCellCheckAlt.m_x, posCellCheckAlt.m_y)
				{
					posCellDest += (posCellCheckAlt - posCellMin)
					posNew = F32x2Cast(posCellDest * pBoard.m_dXyTile)
					dirNew = dirTry	
				}
			}

			if (pPlayinp.m_mpButkEdges[BUTK.Down] >= EDGES.Hold)
			{
				dCellPerSecond = kDCellPerSecondPressDown
			}

			pEntSteer.m_dir = dirNew
			pEntSteer.m_pos = posNew
			ReparentBoardEntity(pBoard, pEntSteer)
		}

		dYPerSec := cast(f32)pBoard.m_dXyTile.m_y * dCellPerSecond
		dY := dT * dYPerSec

		fAnyFalling := false
		for yCell := 0; yCell < kDYCellBoard; ++yCell
		{	
			for xCell := 0; xCell < kDXCellBoard; ++xCell
			{
				pEnt := PEntFromCell(pBoard, xCell, yCell, CELOOK.ExcludeTail)
				if !pEnt
					{ continue }

				pEnt.m_dTEnts += dT

				iCellPos := ICellFromPos(pBoard, pEnt.m_pos)
				iCell := ICell(xCell, yCell)
				assert(iCell == iCellPos, "bad cell calculation", #file, #line)

				if pEnt.m_ents == ENTS.Dead
				{
					if pEnt.m_dTEnts > kDTShowDead
					{
						FreeEntity(&g_game, &g_game.m_pEntUnusedFirst, pEnt)
					}
				}
				else if pEnt.m_entk != ENTK.Virus
				{
					// falling
					yNew := pEnt.m_pos.m_y
					if pPlay.m_pEntSteer == pEnt && dY > 0
					{
						yNew -= dY	
					}
					else if fStepDown
					{
						yNew -= cast(f32)pBoard.m_dXyTile.m_y
					}

					yCellNew := NFloor(yNew / cast(f32)pBoard.m_dXyTile.m_y)
					if 	yCellNew != yCell
					{
						// check for a landing

						fIsBelowBlocked := FIsCellOccupied(pBoard, xCell, yCellNew, pEnt)

						if pEnt.m_fHasTail
						{
							dCellTail := DCellFromDir(pEnt.m_dir)
							fIsBelowBlocked |= FIsCellOccupied(pBoard, xCell + dCellTail.m_x, yCellNew + dCellTail.m_y, pEnt)
						}

						if fIsBelowBlocked
						{
							yNew = cast(f32)(yCell * pBoard.m_dXyTile.m_y) + 0.01

							SetEnts(pEnt, ENTS.Stable)
							if pPlay.m_pEntSteer == pEnt
							{
								pPlay.m_pEntSteer = null
							}
						}
						else
						{
							SetEnts(pEnt, ENTS.Falling)
							fAnyFalling = true
						}
					}
					pEnt.m_pos.m_y = yNew
					ReparentBoardEntity(pBoard, pEnt)
				}
			}
		}

		// loop over all cells checking for pills that should be dead
		cVirusLiving : int
		fAnyDead := false
		for yCell := 0; yCell < kDYCellBoard; ++yCell
		{	
			for xCell := 0; xCell < kDXCellBoard; ++xCell
			{
				pEnt := PEntFromCell(pBoard, xCell, yCell, CELOOK.IncludeTail)
				if !pEnt
					{ continue }
				if pEnt.m_ents != ENTS.Stable
				{ 
					fAnyDead |= pEnt.m_ents == ENTS.Dead
					continue 
				}

				pillcol := PillcolFromCell(pBoard, xCell, yCell)

				// horizontal scan
				xCellIt := xCell+1
				for ; xCellIt < kDXCellBoard; ++xCellIt	
				{
					if PillcolFromCell(pBoard, xCellIt, yCell) != pillcol
						{ break }
				}

				fAutoKill := (pPlay.m_grfplay & FPLAY.Autokill) != 0
				cPillcol := xCellIt - xCell
				cPillcolKill := 4
				if fAutoKill && pEnt.m_entk != ENTK.Virus
					{ cPillcolKill = 1}

				if cPillcol >= cPillcolKill
				{
					if !fAutoKill
						{ ++pPlay.m_cKills }

					for iCellDead := 0; iCellDead < cPillcol; ++iCellDead
					{
						KillCell(pBoard, xCell + iCellDead, yCell)
						fAnyDead = true
					}
				}

				// vertical scan
				yCellIt := yCell+1
				for ; yCellIt < kDYCellBoard; ++yCellIt	
				{
					if PillcolFromCell(pBoard, xCell, yCellIt) != pillcol
						{ break }
				}

				cPillcol = yCellIt - yCell
				if cPillcol >= 4
				{
					++pPlay.m_cKills
					for iCellDead := 0; iCellDead < cPillcol; ++iCellDead
					{
						KillCell(pBoard, xCell, yCell + iCellDead)
						fAnyDead = true
					}
				}

				// living viruses?	
				if pEnt.m_entk == ENTK.Virus
				{
					if pEnt.m_ents != ENTS.Dead
					{
						cVirusLiving += 1
					}
				}
			}
		}

		if !cVirusLiving
		{
			SetGamres(pPlay, GAMRES.WinClearedAll)
		}

		if fAnyFalling || fAnyDead
		{
			pPlay.m_dTUntilSpawn = GMax(kDTNextPill, pPlay.m_dTUntilSpawn - dT)
		}
		else
		{
			pPlay.m_dTUntilSpawn -= dT
		}
	}

	for iPlay := 0; iPlay < pGame.m_cPlay; ++iPlay
	{
		pPlay := &pGame.m_aPlay[iPlay]
		if pPlay.m_dTUntilSpawn < 0 && pPlay.m_pEntSteer == null && fStepDown
		{
			if pPlay.m_cKills > 1
			{
				for iPlayOther := 0; iPlayOther < pGame.m_cPlay; ++iPlayOther
				{
					if iPlay == iPlayOther
						{ continue }
					pGame.m_aPlay[iPlayOther].m_mpIplayCGarbagePending[iPlay] += pPlay.m_cKills
				}
			}
			pPlay.m_cKills = 0
		}
	}

	// spawn garbage or pills
	for iPlay := 0; iPlay < pGame.m_cPlay; ++iPlay
	{
		pPlay := &pGame.m_aPlay[iPlay]
		pBoard := &pGame.m_aBoard[iPlay]
		if pPlay.m_dTUntilSpawn < 0 && pPlay.m_pEntSteer == null && fStepDown
		{
			xCellMidpoint := kDXCellBoard/2 - 1
			yCellSpawn := kDYCellBoard - 1

			cGarbagePending := 0
			for iPlayOther := 0; iPlayOther < pGame.m_cPlay; ++iPlayOther
			{
				cGarbagePending += pPlay.m_mpIplayCGarbagePending[iPlayOther]
				pPlay.m_mpIplayCGarbagePending[iPlayOther] = 0
			}

			if cGarbagePending
			{
				for iGarbage := 0; iGarbage < cGarbagePending; ++iGarbage
				{
					xCellSearchMin, xCellSearchMax: int

					if (iGarbage % 0x2) == 1
					{
						xCellSearchMin = 0
						xCellSearchMax = xCellMidpoint
					}
					else
					{
						xCellSearchMin = xCellMidpoint
						xCellSearchMax = kDXCellBoard-1
					}

					// BB - should replace this with shuffle based search
					fFoundSpot := false
					for cRetry := 0; cRetry < 20; ++cRetry
					{
						xCellGarbage := NRandom(&pBoard.m_rng, cast (s32)xCellSearchMin, cast (s32)xCellSearchMax)

						if !FIsCellOccupied(pBoard, xCellGarbage, yCellSpawn)
						{
							pEntGarbage := PEntAllocate(&g_game.m_pEntUnusedFirst, ENTK.Garbage)
							if pEntGarbage
							{
								SetEnts(pEntGarbage, ENTS.Falling)
								pEntGarbage.m_pillcol = cast(PILLCOL)NRandom(&pBoard.m_rng, PILLCOL.min, PILLCOL.MaxPills)

								pEntGarbage.m_pos = PosFromCell(pBoard, xCellGarbage, yCellSpawn)
								ReparentBoardEntity(pBoard, pEntGarbage)
							}
							break
						}
					}
				}
			}
			else
			{
				if FIsCellOccupied(pBoard, xCellMidpoint, yCellSpawn) ||
					FIsCellOccupied(pBoard, xCellMidpoint + 1, yCellSpawn)
				{
					SetGamres(pPlay, GAMRES.LoseOverflow)
				}
				else
				{
					pEntPill := PEntAllocate(&g_game.m_pEntUnusedFirst, ENTK.Pill)
					if pEntPill
					{
						SetEnts(pEntPill, ENTS.Falling)
						pEntPill.m_fHasTail = true
						pEntPill.m_pillcol = cast(PILLCOL)NRandom(&pBoard.m_rng, PILLCOL.min, PILLCOL.MaxPills)
						pEntPill.m_pillcolTail = cast(PILLCOL)NRandom(&pBoard.m_rng, PILLCOL.min, PILLCOL.MaxPills)

						pEntPill.m_pos = PosFromCell(pBoard, xCellMidpoint, yCellSpawn)
						pPlay.m_pEntSteer = pEntPill

						ReparentBoardEntity(pBoard, pEntPill)
					}
				}
			}
		}
	}

	cWon, cLost, cPending: int
	pPlayPending: & SPlayer
	for iPlay := 0; iPlay < pGame.m_cPlay; ++iPlay
	{
		gamresCur := pGame.m_aPlay[iPlay].m_gamres
		if gamresCur >= GAMRES.LoseMin && gamresCur < GAMRES.LoseMax
		{
			++cLost
		}
		else if gamresCur >= GAMRES.WinMin && gamresCur < GAMRES.WinMax
		{
			++cWon
		}
		else 
		{
			++cPending
			pPlayPending = &pGame.m_aPlay[iPlay]
		}
	}

	if cPending <= 1 && cWon == 0
	{
		if pPlayPending
		{
			SetGamres(pPlayPending, GAMRES.WinLastStanding)
			++cWon
		}
	}

	if cWon || cLost == pGame.m_cPlay
	{
		SetGams(pGame, GAMS.PostGame)

		for iPlay := 0; iPlay < pGame.m_cPlay; ++iPlay
		{
			pPlay := &pGame.m_aPlay[iPlay]
			if (pPlay.m_gamres == GAMRES.Pending)
			{
				SetGamres(pPlay, GAMRES.LoseTooSlow)
			}
		}
	}
}

SetGamres proc (pPlay: & SPlayer, gamres: GAMRES)
{
	pPlay.m_gamres = gamres
}

SetPlays proc (pPlay: & SPlayer, plays: PLAYS)
{
	pPlay.m_plays = plays
}

SetGams proc (pGame: & SGame, gams: GAMS)
{
	pGame.m_gams = gams

	switch (pGame.m_gams)
	{
		case GAMS.Pregame:
			InitPlayers(&g_game)

		    dXyVport := S32x2Create(kDXWindow, kDYWindow)

			pGame.m_cPlay = kCPlayerMax
			for iBoard := 0; iBoard < pGame.m_cPlay; ++iBoard
		    {
			    ClearBoard(&pGame.m_aBoard[iBoard], pGame)
				InitBoard(iBoard, pGame.m_cPlay, dXyVport, &pGame.m_aBoard[iBoard], kCVirusStarting)
			}

		case GAMS.InGame:

			// BB - need to remap correct players (and controllers) if there are gaps in the players that have signed in
			cPlay := 0

			pPlayAuto := &pGame.m_aPlay[1]
			if pPlayAuto.m_plays == PLAYS.Inactive
			{
				SetPlays(pPlayAuto, PLAYS.PregameReady)
				pPlayAuto.m_grfplay = pPlayAuto.m_grfplay | FPLAY.Autokill
			}

			for iPlay := 0; iPlay < pGame.m_aPlay.count; ++iPlay
			{
				pPlay := &pGame.m_aPlay[iPlay]
				if pPlay.m_plays >= PLAYS.PregameReady
				{
					++cPlay
					SetPlays(pPlay, PLAYS.InGame)
				}
			}

			pGame.m_cPlay = cPlay

		case GAMS.PostGame:
	}
}

UpdatePregame proc (pGame: & SGame, pDrac: & SDrawContext)
{
	pPlayZero := &pGame.m_aPlay[0]
	if pPlayZero.m_plays == PLAYS.Inactive
	{
		SetPlays(pPlayZero, PLAYS.PregameOptions)
	}

	cWaiting := 0
	for iPlay := 0; iPlay < pGame.m_aPlay.count; ++iPlay
	{
		pPlay := &pGame.m_aPlay[iPlay]
		pBoard := &pGame.m_aBoard[iPlay]
		pPlayinp := &pPlay.m_playinp

		posCenter := F32x2Cast(pBoard.m_pos) + F32x2Cast(pBoard.m_dXyBoard) * 0.5

		switch pPlay.m_plays
		{
			case PLAYS.Inactive:
				DrawTextCentered(pDrac, posCenter, "Press Start")
			case PLAYS.PregameOptions:
				DrawTextCentered(pDrac, posCenter, "Press 'X' when ready")
				++cWaiting

				if pPlayinp.m_mpButkEdges[BUTK.Select] == EDGES.Press
				{
					SetPlays(pPlay, PLAYS.PregameReady)
				}
				if pPlayinp.m_mpButkEdges[BUTK.Cancel] == EDGES.Press
				{
					SetPlays(pPlay, PLAYS.Inactive)
				}
			case PLAYS.PregameReady:
				DrawTextCentered(pDrac, posCenter, "Ready")

				if pPlayinp.m_mpButkEdges[BUTK.Cancel] == EDGES.Press
				{
					SetPlays(pPlay, PLAYS.PregameOptions)
				}
		}
	}

	if cWaiting == 0
	{
		SetGams(pGame, GAMS.InGame)
	}
}

DrawGameResults proc (pDrac: & SDrawContext, pPlay: & SPlayer, pBoard: & SBoard)
{
	posCenter := F32x2Cast(pBoard.m_pos) + F32x2Cast(pBoard.m_dXyBoard) * 0.5
	aCh: [64] u8
	switch pPlay.m_gamres
	{
		case GAMRES.WinClearedAll,
			GAMRES.WinLastStanding:
			snprintf(aCh, aCh.count, "Winner!")
		case GAMRES.LoseOverflow,
			GAMRES.LoseTooSlow:
			snprintf(aCh, aCh.count, "You Lose.")
	}

	DrawTextCentered(pDrac, posCenter, aCh)
}

main proc () -> int
{
	pWindow : HWND
	CreateWindow(kDXWindow, kDYWindow, "Physician PillMan", &pWindow)

	pDrac := PDracStaticInit(PVAllocDefault)
	if !pDrac
		{return 0 }

	pDrac.m_pDras.m_fontd.m_gCharSize = 20

	SetupOrthoViewport(0, 0, kDXWindow, kDYWindow)
	SeedRandom(&g_rng, 0xBADDBEEF)

    dRadSpin :: 0.01
    gRadSpin: float

	InitUnusedEntList(g_game.m_aEnt, &g_game.m_pEntUnusedFirst)

    // Make sure sleep has 1ms granularity
    s_cMsDesiredGranularity :: 1
    fIsSleepGranular := FTrySetTimerResolution(s_cMsDesiredGranularity)
    g_cTickPerSecond = CTickPerSecond() 

    nHzMonitorRefresh : s32 = GetMonitorRefresh(pWindow)
    nHzTarget := cast (f32)(nHzMonitorRefresh)

    dTFrameTarget := 1.0 / nHzTarget
	aChStatus: [512] u8

	cTickLast := CTickWallClock()
	fShouldClose := false
	dTGame: f32

	SetGams(&g_game, GAMS.Pregame)
	pVJoyman := CreateJoystickManager()

	while fShouldClose == false
	{
		fShouldClose |= !FHandleEvents(&g_game.m_aPlay[0].m_playinp)
		UpdateJoystickManager(pVJoyman)

		/*
		for iPlay := 1; iPlay < g_game.m_aPlay.count; ++iPlay
		{
			g_game.m_aPlay[iPlay].m_playinp = g_game.m_aPlay[0].m_playinp
		}*/

		gRadSpin += dRadSpin

		DrawBoards(&g_game, pDrac)
		//DrawMapBackground(aChMap, &g_tilbuf)
		//DrawEntities(aEnt, &g_tilbuf)

		FlushTileVerts(pDrac, &g_tilbuf)
		FlushFontVerts(pDrac, &g_Fvbuf)

		//DrawTestTriangle(gRadSpin)

        SwapBuffers(pWindow)
		ClearWindow(0, 0, 0, 1)

        UpdateWindowEvents()

        switch (g_game.m_gams)
        {
        	case GAMS.Pregame:
        		UpdatePregame(&g_game, pDrac)
        	case GAMS.InGame:
		        UpdatePlayers(&g_game, dTGame)
        	case GAMS.PostGame:
        		for iPlay := 0; iPlay < g_game.m_cPlay; ++iPlay
        		{
        			pPlay := &g_game.m_aPlay[iPlay]
        			pBoard := &g_game.m_aBoard[iPlay]
        			DrawGameResults(pDrac, pPlay, pBoard)

					if pPlay.m_playinp.m_mpButkEdges[BUTK.Select] == EDGES.Press
					{
						SetGams(&g_game, GAMS.Pregame)
					}
        		}
        }
        //UpdateActors(aAct, &playinp, dTGame)
		//UpdatePuck(g_pActPuck, &playinp, dTGame, aChMap, &mapdim)
		//UpdateEntities(aEnt)

// 		if !s_fIsPaused
	    {
	    	cTickWork := CTickWallClock()
	    	dTWorkElapsed := DTElapsed(cTickLast, cTickWork)

	        dTElapsedFrame := dTWorkElapsed
	        if dTElapsedFrame < dTFrameTarget
	        {                        
	            if fIsSleepGranular
	            {
	                SleepMS := cast (u32)(1000.0 * (dTFrameTarget - dTElapsedFrame))
	                if SleepMS > 0
	                {
	                    Sleep(SleepMS)
	                }
	            }

	            while dTElapsedFrame < dTFrameTarget
	            {                            
	                dTElapsedFrame = DTElapsed(cTickLast, CTickWallClock())
	            }
	        }
	    }

	    cTickEnd := CTickWallClock()
	    dTFrameActual := DTElapsed(cTickLast, cTickEnd)
	    cTickLast = cTickEnd

	    nHzActual := 1 / dTFrameActual
	    snprintf(aChStatus, aChStatus.count, "%0.1f / %0.1f, %0.2f ms", nHzActual, nHzTarget, dTFrameActual * 1000)
		DrawText(pDrac, F32x2Create(20, kDYWindow - 35), aChStatus)

		dTGame = dTFrameActual
		g_systCur += dTGame
	}
	return 1
}