#import "Basic"
#import "Color"
#import "Font"
#import "GL"
#import "Math"
#import "Smooth"
#import "wwise"

// Ideas:
// Each player has a color
// gems change which player you send garbage to
// garbage queues (with a color indicator) at the top
// Clocks slow down your fall rate, and send a speed up clock to your target - they last until the speed up clock is gone (or either clock?) 
// Need some kind of powerup to deal with vertical walls - a vertical column destroyer? something to push sideways? a magnet?

// orig: 64x128 px, 8x8 cells, 8x16 playspace

kDXWindow immutable := 1920
kDYWindow immutable := 1080

kDXCellBoard immutable := 8
kDYCellBoard immutable := 17
kDYCellBoardVisible immutable := 16 // the last row is only for overflow off the top, shouldn't draw (unless occupied)
kBoardBorderWidth immutable := 10
kDYBoardBorderBottom immutable := 54

kCCellPerBoard immutable := kDXCellBoard * kDYCellBoard
kEntMax immutable := kCCellPerBoard * kCPlayerMax
kYMaxVirusStart immutable := 12

kDTStartingSpawn immutable := 1
kDTNextPill	immutable := 0.3
kDTShowDead immutable := 0.3
kDTStabilize immutable := 0.05

kDTEndgameMin immutable := 1.5
kDTPulseTotal immutable := 1.5
kDTPulseBell immutable := 0.25

kCVirusStarting immutable := 15
kCPlayerMax immutable := 4

kDTPulseBellStabilize immutable := 0.35

g_fApplyGravity := true	// debug toggle for falling pieces
g_nSoundIdNext : u64

g_cTickPerSecond: s64 = 1

Syst typedef f64
g_systCur: f64
g_rng: SRandomGen

PILLCOL enum u8
{
	Red,
	Blue,
	Yellow,
	MaxPills,
	Green 		:= MaxPills,	// extra color to allow for four player backgrounds
}

PILLSPEED enum s8
{
	Slow,
	Medium,
	Fast,
}

DIR enum u8
{
	Left,
	Up,
	Right,
	Down
}

FSPRITE flag_enum
{
	FlipU,
	FlipV
}

SFRAM enum 
{
	TopR,
	TopB,
	TopY,
	TopSh,
	BottomR,
	BottomB,
	BottomY,
	BottomSh,
	DotR,
	DotB,
	DotY,
	DotSh,
	VirusR,
	VirusB,
	VirusY,
	VirusRSh,
	VirusBSh,
	VirusYSh,
	DeadR,
	DeadB,
	DeadY,
	GarbageR1,
	GarbageB1,
	GarbageY1,
	GarbageR2,
	GarbageB2,
	GarbageY2,
	GarbageR3,
	GarbageB3,
	GarbageY3,
	GarbageR4,
	GarbageB4,
	GarbageY4,
	Background1, 
	Background2, 
	Background3, 
	Background4, 
	Untextured,
}

SSprite struct // tag = sp
{
	m_tilak: TILAK
	m_dX: f32
	m_dY: f32
	m_u1, m_u2: f32
	m_v1, m_v2: f32
}

SSpriteSet struct // tag = spset
{
	m_pTex: & STexture
	m_mpSframSp: [SFRAM.max] SSprite	// would be better as an ary, need a way to construct arys on the fly
	m_iParamTex: s32
}

InitSpriteFrame proc (pSpset: & SSpriteSet, tilak: TILAK, sfram: SFRAM, xMin: f32, xMax: f32, yMin: f32, yMax: f32)
{
	dXImage immutable := 1024
	dYImage immutable := 1024

	pSp := &pSpset.m_mpSframSp[sfram]
	pSp.m_tilak = tilak
	pSp.m_dX = xMax - xMin
	pSp.m_dY = yMax - yMin
	pSp.m_u1 = xMin / dXImage
	pSp.m_u2 = xMax / dXImage
	pSp.m_v1 = yMax / dYImage
	pSp.m_v2 = yMin / dYImage
}

FTryInitSprites proc (pDrac: & SDrawContext, pSpset: & SSpriteSet, pChzFilename: & const u8) -> bool
{
	aCh: [1024] u8
	ConcatPChz(pChzFilename, ".tga", aCh)
	pSpset.m_pTex = PTexLoad(aCh, false)
	pSpset.m_iParamTex = IParamFind(pDrac.m_pShman, pDrac.m_pShman.m_mpCoreshkShhand[CORESHK.Sprite], "s_sampTexture")

	if !pSpset.m_pTex
	{
		printf("Failed to load sprite texture %s\n", aCh)
		return false
	}

	InitSpriteFrame(pSpset, TILAK.Entity, SFRAM.TopR, 210, 280, 0, 70)
	InitSpriteFrame(pSpset, TILAK.Entity, SFRAM.BottomR, 280, 350, 0, 70)
	InitSpriteFrame(pSpset, TILAK.Entity, SFRAM.DotR, 0, 70, 140, 210)
	InitSpriteFrame(pSpset, TILAK.Entity, SFRAM.VirusR, 0, 70, 210, 280)
	InitSpriteFrame(pSpset, TILAK.Entity, SFRAM.DeadR, 210, 280, 280, 350)
	InitSpriteFrame(pSpset, TILAK.Entity, SFRAM.GarbageR1, 0, 70, 280, 350)
	InitSpriteFrame(pSpset, TILAK.Entity, SFRAM.GarbageR2, 0, 70, 350, 420)
	InitSpriteFrame(pSpset, TILAK.Entity, SFRAM.GarbageR3, 0, 70, 420, 490)
	InitSpriteFrame(pSpset, TILAK.Entity, SFRAM.GarbageR4, 0, 70, 490, 560)

	InitSpriteFrame(pSpset, TILAK.Entity, SFRAM.TopB, 210, 280, 140, 210)
	InitSpriteFrame(pSpset, TILAK.Entity, SFRAM.BottomB, 280, 350, 140, 210)
	InitSpriteFrame(pSpset, TILAK.Entity, SFRAM.DotB, 140, 210, 140, 210)
	InitSpriteFrame(pSpset, TILAK.Entity, SFRAM.VirusB, 140, 210, 210, 280)
	InitSpriteFrame(pSpset, TILAK.Entity, SFRAM.DeadB, 350, 420, 280, 350)
	InitSpriteFrame(pSpset, TILAK.Entity, SFRAM.GarbageB1, 140, 210, 280, 350)
	InitSpriteFrame(pSpset, TILAK.Entity, SFRAM.GarbageB2, 140, 210, 350, 420)
	InitSpriteFrame(pSpset, TILAK.Entity, SFRAM.GarbageB3, 140, 210, 420, 490)
	InitSpriteFrame(pSpset, TILAK.Entity, SFRAM.GarbageB4, 140, 210, 490, 560)

	InitSpriteFrame(pSpset, TILAK.Entity, SFRAM.TopY, 210, 280, 70, 140)
	InitSpriteFrame(pSpset, TILAK.Entity, SFRAM.BottomY, 280, 350, 70, 140)
	InitSpriteFrame(pSpset, TILAK.Entity, SFRAM.DotY, 70, 140, 140, 210)
	InitSpriteFrame(pSpset, TILAK.Entity, SFRAM.VirusY, 70, 140, 210, 280)
	InitSpriteFrame(pSpset, TILAK.Entity, SFRAM.DeadY, 280, 350, 280, 350)
	InitSpriteFrame(pSpset, TILAK.Entity, SFRAM.GarbageY1, 70, 140, 280, 350)
	InitSpriteFrame(pSpset, TILAK.Entity, SFRAM.GarbageY2, 70, 140, 350, 420)
	InitSpriteFrame(pSpset, TILAK.Entity, SFRAM.GarbageY3, 70, 140, 420, 490)
	InitSpriteFrame(pSpset, TILAK.Entity, SFRAM.GarbageY4, 70, 140, 490, 560)

	InitSpriteFrame(pSpset, TILAK.Shadow, SFRAM.TopSh, 430, 516, 172, 258)
	InitSpriteFrame(pSpset, TILAK.Shadow, SFRAM.BottomSh, 516, 602, 172, 258)
	InitSpriteFrame(pSpset, TILAK.Shadow, SFRAM.DotSh, 430, 516, 258, 344)

	InitSpriteFrame(pSpset, TILAK.Background, SFRAM.Background1, 0, 210, 560, 770)
	InitSpriteFrame(pSpset, TILAK.Background, SFRAM.Background2, 210, 420, 560, 770)
	InitSpriteFrame(pSpset, TILAK.Background, SFRAM.Background3, 420, 630, 560, 770)
	InitSpriteFrame(pSpset, TILAK.Background, SFRAM.Background4, 630, 840, 560, 770)

	InitSpriteFrame(pSpset, TILAK.Entity, SFRAM.Untextured, 1023, 1023, 1023, 1023)
	return true
}

ColFromPillcol proc (pillcol: PILLCOL) -> SColor
{
	switch pillcol
	{
		case PILLCOL.Red:	 	return ColCreate(231, 0, 90)
		case PILLCOL.Blue:		return ColCreate(57, 189, 255)
		case PILLCOL.Yellow:	return ColCreate(255, 189, 0)
		case PILLCOL.Green:		return ColCreate(57, 255, 189)
	}
	return ColCreate (255, 255, 255, 255)
}

ColLightFromPillcol proc (pillcol: PILLCOL) -> SColor
{
	switch pillcol
	{
		case PILLCOL.Red:	 	return ColCreate(255, 160, 198)
		case PILLCOL.Blue:		return ColCreate(114, 189, 255)
		case PILLCOL.Yellow:	return ColCreate(255, 255, 125)
		case PILLCOL.Green:		return ColCreate(57, 255, 189)
	}
	return ColCreate (255, 255, 255, 255)
}

TILAK enum // TIle LAyer Kind
{
	Background,
	Shadow,
	Entity
}

STileVertex struct // tag=tilvert
{
	m_x, m_y: f32
	m_u, m_v: f32
	m_r, m_g, m_b, m_a: f32
	m_rOvr, m_gOvr, m_bOvr, m_aOvr: f32
}

STileLayer struct // tag = tilay
{
	m_aTilvert: [4096] STileVertex
	m_cTilvert: int
}

STileVertexBuffer struct // tag=tilbuf
{
	m_mpTilakTilay: [TILAK.max] STileLayer
	m_pSpset: & SSpriteSet
}
g_tilbuf: STileVertexBuffer

BUTK enum // button kind
{
	Up,
	Down,
	Left,
	Right,
	RotateClock,
	RotateCClock,
	RotateClockAlt,		// BB - once we have struct literals this should go away, replace mpButkKeycode with a pair map
	RotateCClockAlt,
	Select,
	Cancel,
}

SPlayerInput struct // tag = playinp
{
	m_mpButkEdges: [BUTK.max] EDGES
	m_pPadmap: & SGamepadMap
	m_nDeviceId: s32 = -1
}

SGamepadMapData	struct // tag = padmapd
{
	m_mpButkKeycode: & KEYCODE
	m_pChzJoystickName: & u8		// joystick name reported by GLFW
}

SGamepadMap	struct	// tag = padmap
{
	m_nDeviceId: s32				// gamepad index as reported by Gllib
	m_pPadmapd: & SGamepadMapData
}

GAMRES enum // GAMe RESult
{
	Pending,
	WinMin,
	WinClearedAll		:= WinMin,
	WinLastStanding,
	WinMax,

	LoseMin				:= WinMax,
	LoseOverflow		:= LoseMin,
	LoseTooSlow,
	LoseMax,
}

PLAYS enum s8 // PLAYer State
{
	Inactive,
	PregameOptions,
	PregameReady,
	InGame,
	PostGame,
}

FPLAY enum u8
{
	Autokill		:= 0x1,		// pills are killed as soon as they stabilize, used to test n players. Can't win, can't spawn garbage.
}

GAMS enum s8 // GAMe State
{
	Pregame,
	InGame,
	PostGame,
}

SPlayer struct // tag = play
{
	m_plays := PLAYS.nil
	m_gamres := GAMRES.nil
	m_grfplay: FPLAY.loose
	m_pillcol: PILLCOL
	m_pillcolNextHead: PILLCOL
	m_pillcolNextTail: PILLCOL
	m_iPlayerTarget: int						// player that will receive this player's garbage
	m_iStartingLevel := 5						// starting virus count is (m_iStartingLeve + 1)*4
	m_playinp: SPlayerInput
	m_pillspeed := PILLSPEED.Medium
	m_nSoundObj: u64	

	m_mpIplayCGarbagePending: [kCPlayerMax] int	// how much garbage is pending from each player
	m_cKills: int

	m_dTUntilSpawn : f32 = kDTStartingSpawn 	// nothing was falling last update, spawn a new pill
	m_dTRepeatHold : f32 = -1
	m_dTStepDown : f32
	m_pEntSteer : & SEntity						// falling entity controlled by this player

	m_cKilledCells: int
	m_cGarbageSent: int
	m_cGarbageReceived: int
	m_cErrors: int

	m_uDropAccel: f32							// 0..1 speedup for pill dropping
	m_dTHoldDown: f32
	m_dTTotal: f32

	m_iMenuItem: int = 0
}

SGame struct // tag = game
{
	m_aEnt : [kEntMax] SEntity
	m_pEntUnusedFirst: & SEntity		// list of unused entities

	m_aBoard: [kCPlayerMax] SBoard	

	m_aPadmapd: [kCPlayerMax] SGamepadMapData
	m_aPadmap: [kCPlayerMax] SGamepadMap
	m_cPadmapd: int
	m_cPadmap: int

	m_gams := GAMS.nil
	m_dTGams : f32 						// Time in this game state
	m_cPlay:= 2
	m_aPlay: [kCPlayerMax] SPlayer
}
g_game: SGame

SBoard struct
{
	m_dXyTile: s32x2	// pixel dims of each tile
	m_dXyBoard: s32x2	// total dims of the map
	m_gTileSpacing: f32
	m_pos: s32x2 		// lower left of the board

	m_iBoard: s32
	m_nRngSeed: u32	= 0x1234BEEF //0xBADDBEEF
	m_rng: SRandomGen
	m_mpIcellPEnt: [kCCellPerBoard] & SEntity
}

ENTK enum s8 // ENTity Kind
{
	None,
	Pill,
	Virus,
	Garbage,
	Gem,
}

ENTS enum s8 // ENTity State
{
	Falling,
	Stable,
	Dead,
}

SEntity struct // tag = ent
{
	m_entk: ENTK
	m_ents: ENTS
	m_dTEnts: f32				// time in this state

	m_pos: f32x2				// pixel position
	m_posSmooth: f32x2
	m_radSmooth: f32
	m_pillcol: PILLCOL
	m_pillcolTail: PILLCOL		// other pill color (cause pills are one entity but two colors)
	m_dir:= DIR.Right 			// direction from pill head to tail
	m_dTPulse := 0.0
	m_dTStabilize := 0.0		// time since landing, before stabilizing (for ground sliding)

	m_iBoard	: s32 = -1
	m_iCellParent : s32 = -1	// board cell this entity is parented to
	m_iCellParentTail : s32 = -1
	m_iPlaySource: int			// player that sent this to us (if garbage)

	m_pEntUnusedNext: & SEntity

	m_fHasTail := true			// NOTE: pills should never have a tail but no head!
}

NSoundObjAlloc proc (pChzName: & const u8) -> u64
{
	nId := g_nSoundIdNext	
	g_nSoundIdNext++
	WwiseRegisterGameObject(nId, pChzName)
	return nId
}

AkAllocHook proc (in_size: uSize) -> & void #cdecl
{
    return PVMalloc( cast (uSize) in_size )
}

AkFreeHook proc (in_ptr: & void) #cdecl
{
    FreeMalloc( in_ptr )
}

// Note: VirtualAllocHook() may be used by I/O pools of the default implementation
// of the Stream Manager, to allow "true" unbuffered I/O (using FILE_FLAG_NO_BUFFERING
// - refer to the Windows SDK documentation for more details). This is NOT mandatory;
// you may implement it with a simple malloc().
AkVirtualAllocHook proc(
    in_pMemAddress: & void,
    in_size: sSize,
    in_dwAllocationType: u32,
    in_dwProtect: u32
    ) -> & void #cdecl
{
    return PVVirtualMalloc( in_pMemAddress, in_size, in_dwAllocationType, in_dwProtect )
}

AkVirtualFreeHook proc (in_pMemAddress: & void, in_size: sSize, in_dwFreeType: u32) #cdecl
{
    VirtualFreeMalloc( in_pMemAddress, in_size, in_dwFreeType )
}

InitPlayers proc (pGame: & SGame)
{
	for iPlay := 0; iPlay < pGame.m_aPlay.count; ++iPlay
	{
		pPlay := &pGame.m_aPlay[iPlay]
		pBoard := &pGame.m_aBoard[iPlay]
		if pPlay.m_plays == PLAYS.nil
		{
			SetPlays(pPlay, PLAYS.Inactive)
		}

		pPlay.m_pEntSteer = null
		pPlay.m_pillcol = cast(PILLCOL)iPlay
		pPlay.m_iPlayerTarget = (iPlay + 1) % pGame.m_cPlay
		pPlay.m_dTUntilSpawn = kDTStartingSpawn
		pPlay.m_dTRepeatHold = 0
		pPlay.m_nSoundObj = NSoundObjAlloc("player")

		pPlay.m_dTStepDown = 0
		pPlay.m_cKilledCells = 0
		pPlay.m_cGarbageSent = 0
		pPlay.m_cGarbageReceived = 0
		pPlay.m_cErrors = 0
		pPlay.m_dTHoldDown = 0
		pPlay.m_dTTotal = 0
		pPlay.m_uDropAccel = 0

		pPlay.m_pillcolNextHead = cast(PILLCOL)NRandom(&pBoard.m_rng, PILLCOL.min, PILLCOL.MaxPills)
		pPlay.m_pillcolNextTail = cast(PILLCOL)NRandom(&pBoard.m_rng, PILLCOL.min, PILLCOL.MaxPills)

		for iPlayOther := 0; iPlayOther < kCPlayerMax; ++iPlayOther
		{
			pPlay.m_mpIplayCGarbagePending[iPlayOther] = 0
		}
		pPlay.m_cKills = 0
		SetGamres(pPlay, GAMRES.Pending)

		if (pPlay.m_grfplay & FPLAY.Autokill) != 0
		{
	    	SetPlays(pPlay, PLAYS.Inactive)	
		}
    	else if pPlay.m_plays != PLAYS.Inactive
    	{
	    	SetPlays(pPlay, PLAYS.PregameOptions)	
	    }
	}
}

PosFromCell proc (pBoard: & SBoard, xCell: int, yCell: int) -> f32x2 
{
	// should this include board origin?
	return F32x2Create(cast(f32)(xCell * pBoard.m_dXyTile.m_x),  cast(f32)(yCell * pBoard.m_dXyTile.m_y))
}

InitUnusedEntList proc (aEntAll: [] SEntity, ppEntFirst: && SEntity)
{
	ppEntPrev := ppEntFirst
	for iEnt:= 0; iEnt < aEntAll.count; ++iEnt
	{
		pEnt := &aEntAll[iEnt]
		@ppEntPrev = pEnt					// point at the new entry
		ppEntPrev = &pEnt.m_pEntUnusedNext	// store of the 'next' pointer
	}

	@ppEntPrev = null
}

PEntAllocate proc (ppEntFirst: && SEntity, entk: ENTK) -> & SEntity
{
	if (!ppEntFirst || !@ppEntFirst)
		{ return null }

	pEnt := @ppEntFirst
	pEnt.m_fHasTail = false
	pEnt.m_pillcolTail = PILLCOL.nil
	pEnt.m_dir = DIR.Right
	pEnt.m_dTPulse = 0
	pEnt.m_dTStabilize = 0
	pEnt.m_iPlaySource = -1

	@ppEntFirst = pEnt.m_pEntUnusedNext

	pEnt.m_pEntUnusedNext = null
	pEnt.m_entk = entk
	pEnt.m_ents = ENTS.Stable
	return pEnt
}

FreeEntity proc (pGame: & SGame, ppEntFirst: && SEntity, pEnt: & SEntity)
{
	if !fverify(pEnt.m_pEntUnusedNext == null, "freeing entity that is already unused", #file, #line)
		{ return }

	if fverify(pEnt.m_iBoard >= 0, "bad board", #file, #line)
	{
		assert(pEnt.m_iCellParent >= 0, "partially parented entity", #file, #line)
		pBoard := &pGame.m_aBoard[pEnt.m_iBoard]

		UnparentBoardEntity(pBoard, pEnt)
		//assert(pBoard.m_mpIcellPEnt[pEnt.m_iCellParent] == pEntj, "bad entity parenting")
		//pBoard.m_mpIcellPEnt[pEnt.m_iCellParent] = null
	}

	pEnt.m_iBoard = -1

	pEnt.m_pEntUnusedNext = @ppEntFirst
	@ppEntFirst = pEnt
}

PosCell proc (pBoard: & SBoard, pos: f32x2) -> s32x2
{
	//xCell := NFloor(pos.m_x / cast(f32)pBoard.m_dXyTile.m_x)
	//yCell := NFloor(pos.m_y / cast(f32)pBoard.m_dXyTile.m_y)
	xCell := NRound(pos.m_x) / pBoard.m_dXyTile.m_x
	yCell := NRound(pos.m_y) / pBoard.m_dXyTile.m_y
	return S32x2Create(xCell, yCell)
}

ICellFromPos proc (pBoard: & SBoard, pos: f32x2) -> s32
{
	//xCell := NFloor(pos.m_x / cast(f32)pBoard.m_dXyTile.m_x)
	//yCell := NFloor(pos.m_y / cast(f32)pBoard.m_dXyTile.m_y)
	xCell := NRound(pos.m_x) / pBoard.m_dXyTile.m_x
	yCell := NRound(pos.m_y) / pBoard.m_dXyTile.m_y
	return ICell(xCell, yCell)
}

ICell proc (posCell: s32x2) -> s32
{
	return posCell.m_x + posCell.m_y * kDXCellBoard	
}

ICell proc (xCell: int, yCell: int) -> s32
{
	return cast(s32)(xCell + yCell * kDXCellBoard)
}

CELOOK enum // CEll LOOKup
{
	ExcludeTail,
	IncludeTail,
}

PEntFromCell proc (pBoard: & SBoard, xCell: int, yCell: int, celook: CELOOK) -> & SEntity
{
	pEnt := pBoard.m_mpIcellPEnt[ICell(xCell, yCell)]
	if pEnt
	{
		iCell := ICell(xCell, yCell)
		if iCell == pEnt.m_iCellParentTail && celook == CELOOK.ExcludeTail
			{ return null }

		//iCellPos := ICellFromPos(pBoard, pEnt.m_pos)
		//assert(iCell == iCellPos, "bad cell calculation in lookup", #file, #line)
	}
	return pEnt
}

FIsCellOccupied proc (pBoard: & SBoard, xCell: int, yCell: int) -> bool
{
	if xCell < 0 || xCell >= kDXCellBoard || yCell < 0 || yCell >= kDYCellBoard
		{ return true }

	return PEntFromCell(pBoard, xCell, yCell, CELOOK.IncludeTail) != null
}

FIsCellOccupied proc (pBoard: & SBoard, xCell: int, yCell: int, pEntIgnore: & SEntity) -> bool
{
	if xCell < 0 || xCell >= kDXCellBoard || yCell < 0 || yCell >= kDYCellBoard
		{ return true }

	pEnt := PEntFromCell(pBoard, xCell, yCell, CELOOK.IncludeTail)
	return pEnt != null && pEnt != pEntIgnore
}


PillcolFromCell proc (pBoard: & SBoard, xCell: int, yCell: int) -> PILLCOL
{
	pEnt := PEntFromCell(pBoard, xCell, yCell, CELOOK.IncludeTail)
	if !pEnt || pEnt.m_ents != ENTS.Stable
		{ return PILLCOL.nil }

	iCell := ICell(xCell, yCell)
	if iCell == pEnt.m_iCellParentTail
		{ return pEnt.m_pillcolTail }

	return pEnt.m_pillcol
}

EntkKillCell proc (pPlay: & SPlayer, pBoard: & SBoard, xCell: int, yCell: int) -> ENTK
{
	pEnt := PEntFromCell(pBoard, xCell, yCell, CELOOK.IncludeTail)
	++pPlay.m_cKilledCells
	entkKilled := ENTK.nil

	// Need to handle tails
	if pEnt
	{
		entkKilled = pEnt.m_entk
		posCell := PosCell(pBoard, pEnt.m_pos)

		if pEnt.m_fHasTail
		{
			pEnt.m_fHasTail = false
			pEnt.m_dTPulse = 0
			ReparentBoardEntity(pBoard, pEnt)

			pEntTail := PEntAllocate(&g_game.m_pEntUnusedFirst, pEnt.m_entk)
			pEntTail.m_fHasTail = false
			pEntTail.m_pillcol = pEnt.m_pillcolTail

			posCellTail := posCell + DCellFromDir(pEnt.m_dir)
			CutPos(pEntTail, PosFromCell(pBoard, posCellTail.m_x, posCellTail.m_y), pEnt.m_dir)

			ReparentBoardEntity(pBoard, pEntTail)
			if posCellTail.m_x == xCell && posCellTail.m_y == yCell
			{
				SetEnts(pEntTail, ENTS.Dead)
			}
		}

		if posCell.m_x == xCell && posCell.m_y == yCell
		{
			SetEnts(pEnt, ENTS.Dead)
		}
	}
	return entkKilled
}

SetEnts proc (pEnt: & SEntity, entsNew: ENTS)
{
	if pEnt.m_ents == entsNew
		{ return }

	pEnt.m_ents = entsNew
	pEnt.m_dTEnts = 0
}

DCellFromDir proc (dir: DIR) -> s32x2
{
	switch dir
	{
		case DIR.Left: 	return S32x2Create(-1, 0)
		case DIR.Right: return S32x2Create(1, 0)
		case DIR.Down: 	return S32x2Create(0, -1)
		case DIR.Up: 	return S32x2Create(0, 1)
	}

	assert(false, "unknown dir", #file, #line)
	return S32x2Create(0, 0)
}

UnparentBoardEntity proc (pBoard: & SBoard, pEnt: & SEntity)
{
	if pEnt.m_iCellParent >= 0
	{
		assert(pBoard.m_mpIcellPEnt[pEnt.m_iCellParent] == pEnt, "bad entity parenting", #file, #line)
		pBoard.m_mpIcellPEnt[pEnt.m_iCellParent] = null
		pEnt.m_iCellParent = -1

		if pEnt.m_iCellParentTail >= 0
		{
			assert(pBoard.m_mpIcellPEnt[pEnt.m_iCellParentTail] == pEnt, "bad entity parenting", #file, #line)
			pBoard.m_mpIcellPEnt[pEnt.m_iCellParentTail] = null
			pEnt.m_iCellParentTail = -1
		}
	}
}

ReparentBoardEntity proc (pBoard: & SBoard, pEnt: & SEntity)
{
	//if iCellNew == pEnt.m_iCellParent	
	//	{ return }

	pEnt.m_iBoard = pBoard.m_iBoard
	UnparentBoardEntity(pBoard, pEnt)

	posCell := PosCell(pBoard, pEnt.m_pos)
	pEnt.m_iCellParent = ICell(posCell)
	assert(pBoard.m_mpIcellPEnt[pEnt.m_iCellParent] == null, "trying to parent to occupied cell", #file, #line)
	pBoard.m_mpIcellPEnt[pEnt.m_iCellParent] = pEnt
	
	if (pEnt.m_fHasTail)
	{
		dPosCell := DCellFromDir(pEnt.m_dir)	
		pEnt.m_iCellParentTail = ICell(posCell + dPosCell)
		assert(pBoard.m_mpIcellPEnt[pEnt.m_iCellParentTail] == null, "trying to parent tail to occupied cell", #file, #line)
		pBoard.m_mpIcellPEnt[pEnt.m_iCellParentTail] = pEnt
	}
}

ClearBoard proc (pBoard: & SBoard, pGame: & SGame)
{
	for yCell := 0; yCell < kDYCellBoard; ++yCell
	{	
		for xCell := 0; xCell < kDXCellBoard; ++xCell
		{
			pEnt := PEntFromCell(pBoard, xCell, yCell, CELOOK.ExcludeTail)
			if pEnt
			{
				FreeEntity(pGame, &pGame.m_pEntUnusedFirst, pEnt)
			}
		}
	}
}

InitBoard proc (iPlay: int, cPlay: int,	dXyVport: s32x2, pBoard: & SBoard, cVirus: int)
{
	// 40 x 40
	kDYBorderTop immutable := 120
	kDYBorderBottom immutable := 120
	kDXBorderLeft immutable := 30
	kDXBorderRight immutable := 30
	kDXBorderMiddle immutable := 30

	// find our cell size
	dYMax := cast(s32)dXyVport.m_y - (kDYBorderTop + kDYBorderBottom)
	dYCell := dYMax / kDYCellBoardVisible

	dXBoard : s32 = cast(s32)((dXyVport.m_x - (kDXBorderLeft + kDXBorderRight + (cPlay - 1) * kDXBorderMiddle)) / cPlay)
	dXCell := dXBoard / kDXCellBoard

	dXCell = NMin(dXCell, dYCell)	
	dYCell = dXCell

	pBoard.m_dXyTile = S32x2Create(cast(s32)dXCell, cast(s32)dYCell)
	pBoard.m_gTileSpacing = 0 //cast(f32)pBoard.m_dXyTile.m_x / 8 

	pBoard.m_dXyBoard = S32x2Create(cast(s32)dXCell * kDXCellBoard, cast(s32)dYCell * kDYCellBoardVisible)

	dXBorderTotal := dXyVport.m_x - pBoard.m_dXyBoard.m_x * cPlay
	dXSeperate := dXBorderTotal / (cPlay + 1)

	pBoard.m_pos = S32x2Create(cast(s32)((pBoard.m_dXyBoard.m_x + dXSeperate) * iPlay + dXSeperate), kDYBorderBottom)

	pBoard.m_iBoard = cast(s32)iPlay

	aiVirus: [kDXCellBoard * kYMaxVirusStart] s32
	ShuffleArray(&pBoard.m_rng, aiVirus, kDXCellBoard * kYMaxVirusStart)

	for iVirus:= 0; iVirus < cVirus; ++iVirus
	{
		pEntVirus := PEntAllocate(&g_game.m_pEntUnusedFirst, ENTK.Virus)
		pEntVirus.m_fHasTail = false

		pillcol := cast (PILLCOL) (iVirus % PILLCOL.MaxPills)
		pEntVirus.m_pillcol = pillcol
		pEntVirus.m_dTPulse = GRandom(&pBoard.m_rng, 0, kDTPulseTotal)

		idx := aiVirus[iVirus]
		yCell := idx / kDXCellBoard
		xCell := idx - (yCell * kDXCellBoard)

		assert(!FIsCellOccupied(pBoard, xCell, yCell), "board placement failed", #file, #line)

		CutPos(pEntVirus, PosFromCell(pBoard, xCell, yCell), pEntVirus.m_dir)
		ReparentBoardEntity(pBoard, pEntVirus)
	}

	printf("cells are %d x %d. Board is %d x %d\n", dXCell, dYCell, pBoard.m_dXyBoard.m_x, pBoard.m_dXyBoard.m_y)
}

DrawOutsideBorder proc (xMin: f32, yMin: f32, xMax: f32, yMax: f32, sWidth: f32, colvec: SColorVec)
{
	AppendTile(SFRAM.Untextured, xMin - sWidth, yMin - sWidth, xMin, yMax + sWidth, &colvec, &g_tilbuf)	// left
	AppendTile(SFRAM.Untextured, xMax, yMin - sWidth, xMax + sWidth, yMax + sWidth, &colvec, &g_tilbuf)	// right

	AppendTile(SFRAM.Untextured, xMin, yMin - sWidth, xMax, yMin, &colvec, &g_tilbuf)	// bottom
	AppendTile(SFRAM.Untextured, xMin, yMax, xMax, yMax + sWidth, &colvec, &g_tilbuf)	// bottom
}

DrawInsideBorder proc (xMin: f32, yMin: f32, xMax: f32, yMax: f32, sWidth: f32, colvec: SColorVec)
{
	xMinAdj := xMin + sWidth
	yMinAdj := yMin + sWidth
	xMaxAdj := xMax - sWidth
	yMaxAdj := yMax - sWidth
	DrawOutsideBorder(xMinAdj, yMinAdj, xMaxAdj, yMaxAdj, sWidth, colvec)
}

DrawBoardBackground proc (pBoard: & SBoard, pillcolSelf: PILLCOL, pillcolTarget: PILLCOL)
{
	xMin : f32 = cast(f32)pBoard.m_pos.m_x
	yMin : f32 = cast(f32)pBoard.m_pos.m_y
	xMax : f32 = cast(f32)(pBoard.m_pos.m_x + pBoard.m_dXyBoard.m_x) + pBoard.m_gTileSpacing
	yMax : f32 = cast(f32)(pBoard.m_pos.m_y + pBoard.m_dXyBoard.m_y) + pBoard.m_gTileSpacing

	/*
	colvecBorder := ColvecFromCol(ColFromPillcol(pillcolSelf))
	DrawOutsideBorder(xMin, yMin, xMax, yMax, kBoardBorderWidth, colvecBorder)

	dYBottom: f32 = kDYBoardBorderBottom  - kBoardBorderWidth
	xMin -= kBoardBorderWidth
	xMax += kBoardBorderWidth
	yMin -= kBoardBorderWidth
	AppendTile(SFRAM.Untextured, xMin, yMin - dYBottom, xMax, yMin, &colvecBorder, &g_tilbuf)
	*/

	kDXBackgroundPad immutable := 24
	kMinBackgroundPad immutable := 20
	kMaxBackgroundPad immutable := 30
	colvecWhite := ColvecFromCol(ColCreate(255,255,255))	
	posMin := F32x2Create(xMin - kDXBackgroundPad, yMin - kMinBackgroundPad)
	posMax := F32x2Create(xMax + kDXBackgroundPad, yMax + kMaxBackgroundPad)
	sfram := SFRAM.Background1 + cast(SFRAM)pillcolSelf	
	DrawNineCell(sfram, posMin, posMax, &colvecWhite, &g_tilbuf)
}

CutPos proc (pEnt: & SEntity, pos: f32x2, dir: DIR)
{
	pEnt.m_pos = pos	
	pEnt.m_posSmooth = pos

	pEnt.m_dir = dir
	pEnt.m_radSmooth = RadFromDir(dir)
}

RadFromDir proc (dir: DIR) -> f32
{
	switch dir
	{
	case DIR.Left: 	return kPi
	case DIR.Up:	return kPiOver2
	case DIR.Right:	return 0
	case DIR.Down:	return kPi + kPiOver2
	}
	assert(false, "unhandled dir?", #file, #line)
	return 0
}

DPosPillFromDir proc (pBoard: & SBoard, dir: DIR) -> f32x2
{
	// returns the offset applied to each piece as it rotates

	switch dir
	{
	case DIR.Left: 	return F32x2Create(cast(f32)pBoard.m_dXyTile.m_x, 0)
	case DIR.Up:	return F32x2Create(cast(f32)pBoard.m_dXyTile.m_x, 0)
	case DIR.Right:	return F32x2Create(0, 0)
	case DIR.Down:	return F32x2Create(0, cast(f32)pBoard.m_dXyTile.m_y)
	}
	assert(false, "unhandled dir?", #file, #line)
	return F32x2Create(0,0)

}

DrawNineCell proc (sfram: SFRAM, posMin: f32x2, posMax: f32x2, pColvec: & SColorVec, pTilbuf: & STileVertexBuffer)
{
	pSp := &pTilbuf.m_pSpset.m_mpSframSp[sfram]

	pTilay := &pTilbuf.m_mpTilakTilay[pSp.m_tilak]
	if pTilay.m_aTilvert.count < pTilay.m_cTilvert + (4 * 9)
		{ return }

	kRScale immutable := 0.5	
	dU := (pSp.m_u2 - pSp.m_u1)
	dV := (pSp.m_v2 - pSp.m_v1)
	ddXU := pSp.m_dX / dU
	ddYV := pSp.m_dY / dV

	dPos := posMax - posMin
	dXSplit := Min(dPos.m_x * 0.5, ddXU * dU * 0.333)
	dYSplit := Min(dPos.m_y * 0.5, ddYV * dV * 0.333)

	//	v3
	//	v2
	//	v1
	// 	0	u1	u2	u3

	x0 := posMin.m_x
	x1 := x0 + dXSplit
	x2 := posMax.m_x - dXSplit
	x3 := posMax.m_x

	y0 := posMin.m_y
	y1 := y0 + dYSplit
	y2 := posMax.m_y - dYSplit
	y3 := posMax.m_y

	u0 := pSp.m_u1
	u1 := pSp.m_u1 + dU * 0.333
	u2 := pSp.m_u1 + dU * 0.666
	u3 := pSp.m_u2
	
	v0 := pSp.m_v1
	v1 := pSp.m_v1 + dV * 0.333
	v2 := pSp.m_v1 + dV * 0.666
	v3 := pSp.m_v2

	AppendTile(	x0, y0, x1, y1,
				u0, v0, u1, v1,
				pColvec, pTilay)
	AppendTile(	x0, y1, x1, y2,
				u0, v1, u1, v2,
				pColvec, pTilay)
	AppendTile(	x0, y2, x1, y3,
				u0, v2, u1, v3,
				pColvec, pTilay)

	AppendTile(	x1, y0, x2, y1,
				u1, v0, u2, v1,
				pColvec, pTilay)
	AppendTile(	x1, y1, x2, y2,
				u1, v1, u2, v2,
				pColvec, pTilay)

	AppendTile( x1, y2, x2, y3,
				u1, v2, u2, v3,
				pColvec, pTilay)

	AppendTile( x2, y2, x3, y3,
				u2, v2, u3, v3,
				pColvec, pTilay)
	AppendTile( x2, y1, x3, y2,
				u2, v1, u3, v2,
				pColvec, pTilay)
	AppendTile(	x2, y0, x3, y1,
				u2, v0, u3, v1,
				pColvec, pTilay)
}

DrawPill proc (pBoard: & SBoard, pos: f32x2, rad: f32, pillcolHead: PILLCOL, fHasTail: bool, pillcolTail: PILLCOL, rOpacity: f32, rXScale: f32, uPulse: f32 = 0) 
{
	kXShadowPad immutable := 4
	kYShadowPad immutable := 4 

	colWhite := ColCreate(255, 255, 255, 255)
	colHead := ColLerp(ColFromPillcol(pillcolHead), colWhite, uPulse)
	colTail := ColLerp(ColFromPillcol(pillcolTail), colWhite, uPulse)

	gHalfSpacing := pBoard.m_gTileSpacing * 0.5

	dXySpacing := F32x2Create(pBoard.m_gTileSpacing, pBoard.m_gTileSpacing)
	posOrigin := pos + dXySpacing
	vecHalfSpace := (F32x2Cast(pBoard.m_dXyTile) - dXySpacing) * 0.5
	posOrigin += vecHalfSpace

	posMin := -vecHalfSpace
	posMax := posMin + F32x2Cast(pBoard.m_dXyTile) - dXySpacing

	posMinTail := posMin
	posMinTail.m_x += cast(f32)pBoard.m_dXyTile.m_x

	posMaxTail := posMinTail + F32x2Cast(pBoard.m_dXyTile) - dXySpacing

	if fHasTail
	{
		posMax.m_x += gHalfSpacing	
		posMinTail.m_x = posMax.m_x
	}

	// xScaling
	{
		xMid := (posMaxTail.m_x - posMin.m_x) * 0.5 + posMin.m_x
		posMin.m_x = (posMin.m_x - xMid) * rXScale + xMid
		posMax.m_x = (posMax.m_x - xMid) * rXScale + xMid
		posMinTail.m_x = (posMinTail.m_x - xMid) * rXScale + xMid
		posMaxTail.m_x = (posMaxTail.m_x - xMid) * rXScale + xMid
	}

	kXPulseScale immutable := 4
	kYPulseScale immutable := 4
	xPulse := kXPulseScale * uPulse
	yPulse := kYPulseScale * uPulse
	posMin.m_x -= xPulse
	posMax.m_x += xPulse
	posMin.m_y -= yPulse
	posMax.m_y += yPulse
	posMinTail.m_x -= xPulse
	posMaxTail.m_x += xPulse
	posMinTail.m_y -= yPulse
	posMaxTail.m_y += yPulse

	dPosRot := F32x2Create(0,0)
	posOrigin += dPosRot

	colvecEnt := ColvecFromCol(colHead)	
	colvecEnt.m_w *= rOpacity

	colvecWhite := ColvecFromCol(colWhite)
	colvecWhite.m_w *= rOpacity

	colvecShadowPulse := colvecWhite
	colvecShadowPulse.m_w = 0
	colvecPulseHead := ColvecFromCol(ColLightFromPillcol(pillcolHead))
	colvecPulseHead.m_w = uPulse

	sframHead: SFRAM	
	sframShadow: SFRAM
	if fHasTail
	{ 
		sframHead = SFRAM.TopR + cast(SFRAM)pillcolHead
		sframShadow = SFRAM.TopSh
	}
	else
	{ 
		sframHead = SFRAM.DotR + cast(SFRAM)pillcolHead 
		sframShadow = SFRAM.DotSh
		rad = 0
	}

	fsprite : FSPRITE
	fsprite.FlipV = (rad >= kPi) || (rad < 0)

	AppendTile(sframShadow, posOrigin, rad, fsprite, 
			posMin.m_x-kXShadowPad, posMin.m_y-kYShadowPad, posMax.m_x+kXShadowPad, posMax.m_y+kYShadowPad, 
			&colvecWhite, &colvecShadowPulse, &g_tilbuf)
	AppendTile(sframHead, posOrigin, rad, fsprite, posMin.m_x, posMin.m_y, posMax.m_x, posMax.m_y, &colvecWhite, &colvecPulseHead, &g_tilbuf)

	if (fHasTail)
	{
		colvecTail := ColvecFromCol(colTail)
		colvecTail.m_w *= rOpacity

		colvecPulseTail := ColvecFromCol(ColLightFromPillcol(pillcolTail))
		colvecPulseTail.m_w = uPulse

		sframTail := SFRAM.BottomR + cast(SFRAM)pillcolTail

		AppendTile(SFRAM.BottomSh, posOrigin, rad, fsprite, 
			posMinTail.m_x-kXShadowPad, posMinTail.m_y-kYShadowPad, posMaxTail.m_x+kXShadowPad, posMaxTail.m_y+kYShadowPad, 
			&colvecWhite, &colvecShadowPulse, &g_tilbuf)
		AppendTile(sframTail, posOrigin, rad, fsprite, posMinTail.m_x, posMinTail.m_y, posMaxTail.m_x, posMaxTail.m_y, &colvecWhite, &colvecPulseTail, &g_tilbuf)
	}
}

DrawEntity proc (pEnt: & SEntity, pBoard: & SBoard, pos: f32x2, rOpacity: f32)
{
	kVirusBorderSeparation immutable := 2
	kDeadEntWidth immutable := 3

	posMin := pos + F32x2Cast(pBoard.m_pos)
	posMax := posMin + F32x2Cast(pBoard.m_dXyTile)
	posMin.m_x += cast(f32)pBoard.m_gTileSpacing
	posMin.m_y += cast(f32)pBoard.m_gTileSpacing

	colvecEnt := ColvecFromCol(ColCreate(255, 255, 255))
	colvecEnt.m_w *= rOpacity

	kULerpStable immutable := 1.0 // 0.7
	colvecStable := ColvecFromCol(ColCreate(0, 0, 0, 255))
	uLerpStable := 1.0
	if pEnt.m_ents == ENTS.Stable
	{
		uLerpStable = kULerpStable
		colvecEnt = ColvecLerp(colvecStable, colvecEnt, uLerpStable)
	}

	switch pEnt.m_entk	
	{
		case ENTK.Virus:

			if pEnt.m_ents != ENTS.Dead
			{
				uPulse := 0.0
				if pEnt.m_dTPulse >= kDTPulseTotal
				{
					pEnt.m_dTPulse = 0
				}
				if pEnt.m_dTPulse < kDTPulseBell 
				{
					u := pEnt.m_dTPulse / kDTPulseBell
					uPulse = GCurveBell(u)
				}

				kPulseWidthShrink immutable := 3
				kPulseWidthGrow immutable := 2
				uShrink := uPulse * kPulseWidthShrink
				uGrow := uPulse * kPulseWidthGrow

				sfram := SFRAM.VirusR + cast(SFRAM) pEnt.m_pillcol

				posMin.m_x -= kVirusBorderSeparation + uGrow
				posMin.m_y -= kVirusBorderSeparation + uGrow
				posMax.m_x += kVirusBorderSeparation + uGrow
				posMax.m_y += kVirusBorderSeparation + uGrow

				AppendTile(sfram, posMin.m_x, posMin.m_y, posMax.m_x, posMax.m_y, &colvecEnt, &g_tilbuf)
			}
			else
			{
				sfram := SFRAM.DeadR + cast(SFRAM)pEnt.m_pillcol
				AppendTile(sfram, posMin.m_x, posMin.m_y, posMax.m_x, posMax.m_y, &colvecEnt, &g_tilbuf)
			}

		case ENTK.Pill:

			gHalfSpacing := cast(f32)pBoard.m_gTileSpacing/2
			posMinTail := posMin
			posMaxTail := posMax

			if pEnt.m_fHasTail
			{
				switch pEnt.m_dir
				{
					case DIR.Left: 
						posMinTail.m_x -= cast(f32)pBoard.m_dXyTile.m_x
						posMin.m_x -= gHalfSpacing
						posMaxTail.m_x = posMin.m_x
					case DIR.Right: 
						posMaxTail.m_x += cast(f32)pBoard.m_dXyTile.m_x
						posMax.m_x += gHalfSpacing
						posMinTail.m_x = posMax.m_x
					case DIR.Up: 
						posMaxTail.m_y += cast(f32)pBoard.m_dXyTile.m_y
						posMax.m_y += gHalfSpacing
						posMinTail.m_y = posMax.m_y
					case DIR.Down: 
						posMinTail.m_y -= cast(f32)pBoard.m_dXyTile.m_y
						posMin.m_y -= gHalfSpacing
						posMaxTail.m_y = posMin.m_y
				}
			}

			if (pEnt.m_ents != ENTS.Dead)	
			{
				kRPillPulseScale immutable := 0.2
				kPulseEdge immutable := 0.3 // hold pulse at 0.5 for most of the range
				uPulse := 0.0

				if pEnt.m_dTPulse < 0
				{
					u := (pEnt.m_dTPulse + kDTPulseBellStabilize) / kDTPulseBellStabilize
					if (u < 0.5)
					{
						u = 0.5
					}
					else
					{
						u = 1.0 - Min(0.5, 0.5 * (1.0 - u) / kPulseEdge)
					}

					uPulse = GCurveBell(u)
				}

				posPill := pos + F32x2Cast(pBoard.m_pos)
				radDir := RadFromDir(pEnt.m_dir)

				colWhite := ColCreate(255, 255, 255, 255)
				colPill := ColLerp(ColFromPillcol(pEnt.m_pillcol), colWhite, uPulse)
				colTail := ColLerp(ColFromPillcol(pEnt.m_pillcolTail), colWhite, uPulse)

				posSmoothPill := pEnt.m_posSmooth + F32x2Cast(pBoard.m_pos)
				DrawPill(pBoard, posPill, radDir, pEnt.m_pillcol, pEnt.m_fHasTail, pEnt.m_pillcolTail, 1, 1, uPulse)
			}
			else
			{
				sfram := SFRAM.DeadR + cast(SFRAM)pEnt.m_pillcol
				AppendTile(sfram, posMin.m_x, posMin.m_y, posMax.m_x, posMax.m_y, &colvecEnt, &g_tilbuf)
			}
		case ENTK.Garbage:
			if pEnt.m_ents != ENTS.Dead
			{
				DrawGarbage(pBoard, posMin, pEnt.m_iPlaySource, pEnt.m_pillcol)
			}
			else
			{
				sfram := SFRAM.DeadR + cast(SFRAM)pEnt.m_pillcol
				AppendTile(sfram, posMin.m_x, posMin.m_y, posMax.m_x, posMax.m_y, &colvecEnt, &g_tilbuf)
			}
	}

}

DrawGarbage proc (pBoard: & SBoard, posMin: f32x2, iPlaySource: int, pillcol:PILLCOL)
{
	posMax := posMin + F32x2Cast(pBoard.m_dXyTile)

	cPlayerGarbage :int = SFRAM.GarbageR2 - SFRAM.GarbageR1
	sfram := SFRAM.GarbageR1 + cast(SFRAM)(pillcol + iPlaySource * cPlayerGarbage)

	colvec := ColvecFromCol(ColCreate(255,255,255))
	AppendTile(sfram, posMin.m_x, posMin.m_y, posMax.m_x, posMax.m_y, &colvec, &g_tilbuf)
}


DrawBoards proc (pGame : & SGame, pDrac: & SDrawContext)
{
	for iPlay:=0; iPlay < pGame.m_cPlay; ++iPlay
	{
		cVirusLiving: int
		pPlay := pGame.m_aPlay[iPlay]
		iPlayTarget  := iPlay
		if (pPlay.m_iPlayerTarget >= 0)
			{ iPlayTarget = pPlay.m_iPlayerTarget }

		pBoard := &pGame.m_aBoard[iPlay]
		DrawBoardBackground(pBoard, pPlay.m_pillcol, pGame.m_aPlay[iPlayTarget].m_pillcol)

		if pGame.m_gams != GAMS.Pregame
		{
			for yCell := 0; yCell < kDYCellBoard; ++yCell
			{	
				for xCell := 0; xCell < kDXCellBoard; ++xCell
				{
					pEnt := PEntFromCell(pBoard, xCell, yCell, CELOOK.ExcludeTail)
					if pEnt
					{ 
						DrawEntity(pEnt, pBoard, pEnt.m_pos, 1.0)

						if pEnt.m_entk == ENTK.Virus
						{
							++cVirusLiving
						}
					}
				}
			}
		}

		if pGame.m_gams == GAMS.InGame
		{
			kRGarbageTrimBottom immutable := 0.25
			kRGarbageSpacing immutable := 1.25

			posGarbage := pBoard.m_pos + S32x2Create(-kBoardBorderWidth, kBoardBorderWidth)
			posGarbage.m_y += pBoard.m_dXyBoard.m_y + cast(s32)(cast(f32)pBoard.m_dXyTile.m_y * kRGarbageTrimBottom)

			pillWidth := cast(f32)pBoard.m_dXyTile.m_x * 2
			posPill := F32x2Create(cast(f32)(pBoard.m_pos.m_x + pBoard.m_dXyBoard.m_x + kBoardBorderWidth) - pillWidth, cast(f32)posGarbage.m_y) 
			DrawPill(pBoard, posPill, 0, pPlay.m_pillcolNextHead, true, pPlay.m_pillcolNextTail, 1, 1, 0)

			for iPlayOther:=0; iPlayOther < pGame.m_cPlay; ++iPlayOther
			{
				pPlayOther := &pGame.m_aPlay[iPlayOther]

				cGarbage := pPlay.m_mpIplayCGarbagePending[iPlayOther]
				for iGarbage := 0; iGarbage < cGarbage; ++iGarbage
				{
					DrawGarbage(pBoard, F32x2Cast(posGarbage), iPlayOther, PILLCOL.Red)	
					posGarbage.m_x += cast(s32)(cast(f32)pBoard.m_dXyTile.m_x * kRGarbageSpacing)
				}

			}

			posLabel := pBoard.m_pos
			posLabel.m_x += pBoard.m_dXyBoard.m_x / 2
			posLabel.m_y -= kDYBoardBorderBottom - 10

			kGCharSizeVirus immutable := 50
			pFontd := &pDrac.m_pDras.m_fontd
			gCharSizePrev := pFontd.m_gCharSize
			pFontd.m_gCharSize = kGCharSizeVirus

			aChVirusCount: [16] u8
			snprintf(aChVirusCount, aChVirusCount.count, "%d", cVirusLiving)
			DrawTextCentered(pDrac, F32x2Cast(posLabel), aChVirusCount)

			pFontd.m_gCharSize = gCharSizePrev
		}
	}
}

ClearPlayerInput proc (pPlayinp: & SPlayerInput)
{
	for butk := BUTK.min; butk != BUTK.max; ++butk
	{
		pPlayinp.m_mpButkEdges[butk] = EDGES.Off
	}
}

AdvancePlayerInput proc (pPlayinp: & SPlayerInput)
{
	for butk := BUTK.min; butk != BUTK.max; ++butk
	{
		if pPlayinp.m_mpButkEdges[butk] >= EDGES.Hold
		{
			pPlayinp.m_mpButkEdges[butk] = EDGES.Hold
		}
		else
		{
			pPlayinp.m_mpButkEdges[butk] = EDGES.Off
		}
	}
}

g_mpButkKeycodePs4: [BUTK.max] KEYCODE = 
{
	KEYCODE.JoypadButton15,	//Up,
	KEYCODE.JoypadButton17, //Down,
	KEYCODE.JoypadButton18, //Left,
	KEYCODE.JoypadButton16, //Right,
	KEYCODE.JoypadButton2,	//RotateClock,
	KEYCODE.JoypadButton3,	//RotateCClock,
	KEYCODE.JoypadButton4,	//RotateClockAlt,
	KEYCODE.JoypadButton1,	//RotateCClockAlt,
	KEYCODE.JoypadButton2, 	//Select,
	KEYCODE.JoypadButton3	//Cancel,
}

g_mpButkKeycodeWiredX360: [BUTK.max] KEYCODE = 
{
	KEYCODE.JoypadButton11,	//Up,
	KEYCODE.JoypadButton13, //Down,
	KEYCODE.JoypadButton14, //Left,
	KEYCODE.JoypadButton12, //Right,
	KEYCODE.JoypadButton2,	//RotateClock,
	KEYCODE.JoypadButton1,	//RotateCClock,
	KEYCODE.JoypadButton3,	//RotateClockAlt,
	KEYCODE.JoypadButton4,	//RotateCClockAlt,
	KEYCODE.JoypadButton1, 	//Select,
	KEYCODE.JoypadButton2	//Cancel,
}

InitJoysticks proc (pGame: & SGame) -> void
{
	iPadmapd := 0

	pPadmapd := &pGame.m_aPadmapd[iPadmapd++]
	pPadmapd.m_pChzJoystickName = "Wireless Controller"
	pPadmapd.m_mpButkKeycode = g_mpButkKeycodePs4

	pPadmapd = &pGame.m_aPadmapd[iPadmapd++]
	pPadmapd.m_pChzJoystickName = "Xbox 360 Controller"
	pPadmapd.m_mpButkKeycode = g_mpButkKeycodeWiredX360

	pGame.m_cPadmapd = iPadmapd

	for iDeviceId : s32 = kNDeviceIdJoystickMin; iDeviceId < kNDeviceIdJoystickMax; ++iDeviceId
	{
		if FIsJoystickConnected(iDeviceId)
		{
			OnJoystickConnect(pGame, iDeviceId)
		}
	}
}

FHandleEvents proc (pGame: & SGame) -> bool
{
	mpButkKeycodeKeyboard: [BUTK.max] KEYCODE = 
	{	
		KEYCODE.ArrowUp, 		//Up,
		KEYCODE.ArrowDown, 		//Down,
		KEYCODE.ArrowLeft, 		//Left,
		KEYCODE.ArrowRight, 	//Right
		KEYCODE.KeyA,			//RotateClock,
		KEYCODE.KeyS,			//RotateCClock,
		KEYCODE.KeyA,			//RotateClockAlt,
		KEYCODE.KeyS,			//RotateCClockAlt,
		KEYCODE.Enter, 			//Select,
		KEYCODE.F3				//Cancel,
	}	

	for iPlay := 0; iPlay < pGame.m_aPlay.count; ++iPlay
	{
		pPlayinp := &pGame.m_aPlay[iPlay].m_playinp
		AdvancePlayerInput(pPlayinp)
	}

	event : SEvent
	`EventLoop
	while FGetNextEvent(&event)
	{
		/*
		if event.m_keycode != KEYCODE.nil
		{
			printf("Event: eventk = %d, nDeviceId = %d, keycode=%d, edges = %d\n", event.m_eventk, event.m_nDeviceId, event.m_keycode, event.m_edges)
		}*/
		if event.m_keycode == KEYCODE.Escape && event.m_edges == EDGES.Press
			{ return false }
		if event.m_keycode == KEYCODE.KeyG && event.m_edges == EDGES.Press
		{
			g_fApplyGravity = !g_fApplyGravity
			continue
		}

		if event.m_keycode == KEYCODE.KeyE && event.m_edges == EDGES.Press
		{
			SetGams(pGame, GAMS.PostGame)

			SetGamres(&pGame.m_aPlay[0], GAMRES.WinLastStanding)
			for iPlay := 1; iPlay < pGame.m_cPlay; ++iPlay
			{
				pPlay := &pGame.m_aPlay[iPlay]
				if (pPlay.m_gamres == GAMRES.Pending)
				{
					SetGamres(pPlay, GAMRES.LoseTooSlow)
				}
			}
			continue
		}

		mpButkKeycode: & KEYCODE 
		iPlay := -1

		switch event.m_eventk
		{
			case EVENTK.Keyboard:
				iPlay = 0
				mpButkKeycode = mpButkKeycodeKeyboard

			case EVENTK.Joystick:
				iPlay = IPlayFromNDeviceId(pGame, event.m_nDeviceId)

				pPlayinp := &pGame.m_aPlay[iPlay].m_playinp
				if pPlayinp && pPlayinp.m_pPadmap
				{
					mpButkKeycode = pPlayinp.m_pPadmap.m_pPadmapd.m_mpButkKeycode
				}

			case EVENTK.JoystickConnected:
				OnJoystickConnect(pGame, event.m_nDeviceId)
				continue EventLoop

			case EVENTK.JoystickDisconnected:
				OnJoystickDisconnect(pGame, event.m_nDeviceId)
				continue EventLoop
		}


		if iPlay < 0 || !mpButkKeycode
		{
			continue
		}
		pPlayinp := &pGame.m_aPlay[iPlay].m_playinp

		for butk := BUTK.min; butk != BUTK.max; ++butk
		{
			if event.m_keycode == mpButkKeycode[butk]
			{
				pPlayinp.m_mpButkEdges[butk] = event.m_edges
			}
		}
	}

	return true

	OnJoystickDisconnect proc (pGame : & SGame, nDeviceId: s32)
	{
		printf("Disconnecting Joystick %d\n", nDeviceId)
		iPlay := IPlayFromNDeviceId(pGame, nDeviceId)
		if iPlay >= 0
		{
			pPlayinp := &pGame.m_aPlay[iPlay].m_playinp
			if pPlayinp.m_pPadmap
			{
				pPlayinp.m_pPadmap.m_nDeviceId = -1
				pPlayinp.m_nDeviceId = -1
			}
			pPlayinp.m_pPadmap = null
		}
	}
}

OnJoystickConnect proc (pGame: & SGame, nDeviceId: s32)
{
	// find the first player without a padmap	

	for iPlay := 0; iPlay < pGame.m_aPlay.count; ++iPlay
	{
		pPlayinp := &pGame.m_aPlay[iPlay].m_playinp	
		if pPlayinp.m_pPadmap == null
		{
			pPlayinp.m_pPadmap = &pGame.m_aPadmap[iPlay]
			pPlayinp.m_nDeviceId = nDeviceId
			assert(pGame.m_aPadmap[iPlay].m_nDeviceId == 0, "", #file, #line)	
			pGame.m_aPadmap[iPlay].m_nDeviceId = nDeviceId

			// find a valid map data
			pChzJoystickName := PChzJoystickName(nDeviceId)
			iPadmapdMatch := 0
			for iPadmapd := 0; iPadmapd < pGame.m_cPadmapd; ++iPadmapd
			{
				pPadmapd := &pGame.m_aPadmapd[iPadmapd]
				if FAreCozEqual(pChzJoystickName, pPadmapd.m_pChzJoystickName)
				{
					iPadmapdMatch = iPadmapd
					break
				}
			}

			printf("Connecting Joystick(%d) %s, %p\n", nDeviceId, pChzJoystickName, pPlayinp.m_pPadmap)
			pGame.m_aPadmap[iPlay].m_pPadmapd = &pGame.m_aPadmapd[iPadmapdMatch]
			return
		}
	}

	// all players have joysticks
}


IPlayFromNDeviceId proc (pGame: & SGame, nDeviceId: s32) -> int
{
	for iPlay := 0; iPlay < g_game.m_aPlay.count; ++iPlay
	{
		if g_game.m_aPlay[iPlay].m_playinp.m_nDeviceId == nDeviceId
		{
			return iPlay
		}
	}

	return 0
}

DTElapsed proc (cTickStart: s64, cTickEnd: s64) -> f32 inline
{
    return cast (f32)(cTickEnd - cTickStart) / cast(f32)g_cTickPerSecond
}

AppendTile proc (
			sfram: SFRAM,
			pos: f32x2, rad: f32,
			fsprite: FSPRITE,
			xMin: f32, yMin: f32,
			xMax: f32, yMax: f32,
			colvec: & SColorVec,
			colvecOvr: & SColorVec,
			pTilbuf: & STileVertexBuffer)
{
	pSp := &pTilbuf.m_pSpset.m_mpSframSp[sfram]
	pTilay := &pTilbuf.m_mpTilakTilay[pSp.m_tilak]

	if pTilay.m_aTilvert.count < pTilay.m_cTilvert + 4
		{ return }

	mat := Mat33FromPosRad(pos, rad)

	u1 := pSp.m_u1
	u2 := pSp.m_u2
	v1 := pSp.m_v1
	v2 := pSp.m_v2

	if (fsprite.FlipU)
	{
		temp := u1
		u1 = u2
		u2 = temp
	}

	if (fsprite.FlipV)
	{
		temp := v1
		v1 = v2
		v2 = temp
	}

	pos0 := F32x2Create(xMin, yMax)
	pos0 = PosMul(mat, pos0)
	AppendTilvert(
		pos0.m_x, pos0.m_y,
		u1, v2,
		colvec.m_x, colvec.m_y, colvec.m_z, colvec.m_w,
		colvecOvr.m_x, colvecOvr.m_y, colvecOvr.m_z, colvecOvr.m_w,
		pTilay)

	pos1 := F32x2Create(xMax, yMax)
	pos1 = PosMul(mat, pos1)
	AppendTilvert(
		pos1.m_x, pos1.m_y,
		u2, v2,
		colvec.m_x, colvec.m_y, colvec.m_z, colvec.m_w,
		colvecOvr.m_x, colvecOvr.m_y, colvecOvr.m_z, colvecOvr.m_w,
		pTilay)

	pos2 := F32x2Create(xMax, yMin)
	pos2 = PosMul(mat, pos2)
	AppendTilvert(
		pos2.m_x, pos2.m_y,
		u2, v1,
		colvec.m_x, colvec.m_y, colvec.m_z, colvec.m_w,
		colvecOvr.m_x, colvecOvr.m_y, colvecOvr.m_z, colvecOvr.m_w,
		pTilay)

	pos3 := F32x2Create(xMin, yMin)
	pos3 = PosMul(mat, pos3)
	AppendTilvert(
		pos3.m_x, pos3.m_y,
		u1, v1,
		colvec.m_x, colvec.m_y, colvec.m_z, colvec.m_w,
		colvecOvr.m_x, colvecOvr.m_y, colvecOvr.m_z, colvecOvr.m_w,
		pTilay)
}

AppendTile proc (
			sfram: SFRAM,
			xMin: float, yMin: float,
			xMax: float, yMax: float,
			colvec: & SColorVec,
			pTilbuf: & STileVertexBuffer)
{
	pSp := &pTilbuf.m_pSpset.m_mpSframSp[sfram]

	AppendTile(
		xMin, yMin, xMax, yMax, 
		pSp.m_u1, pSp.m_v1, pSp.m_u2, pSp.m_v2,
		colvec,
		&pTilbuf.m_mpTilakTilay[pSp.m_tilak])
}

AppendTile proc (
			xMin: float, yMin: float,
			xMax: float, yMax: float,
			uMin: float, vMin: float,
			uMax: float, vMax: float,
			colvec: & SColorVec,
			pTilay: & STileLayer)
{
	if pTilay.m_aTilvert.count < pTilay.m_cTilvert + 4
		{ return }

	AppendTilvert(
		xMin, yMax,
		uMin, vMax,
		colvec.m_x, colvec.m_y, colvec.m_z, colvec.m_w,
		pTilay)

	AppendTilvert(
		xMax, yMax,
		uMax, vMax,
		colvec.m_x, colvec.m_y, colvec.m_z, colvec.m_w,
		pTilay)

	AppendTilvert(
		xMax, yMin,
		uMax, vMin,
		colvec.m_x, colvec.m_y, colvec.m_z, colvec.m_w,
		pTilay)

	AppendTilvert(
		xMin, yMin,
		uMin, vMin,
		colvec.m_x, colvec.m_y, colvec.m_z, colvec.m_w,
		pTilay)
}

AppendTilvert proc (
				x: float, y: float, 
				u: float, v: float, 
				r: float, g: float, b: float, a: float, 
				pTilay: & STileLayer) inline
{
	pTilvert: & STileVertex = &pTilay.m_aTilvert[pTilay.m_cTilvert]
	++pTilay.m_cTilvert

	pTilvert.m_x = x
	pTilvert.m_y = y

	pTilvert.m_u = u
	pTilvert.m_v = v

	pTilvert.m_r = r
	pTilvert.m_g = g
	pTilvert.m_b = b
	pTilvert.m_a = a

	pTilvert.m_rOvr = 1
	pTilvert.m_gOvr = 1
	pTilvert.m_bOvr = 1
	pTilvert.m_aOvr = 0
}

AppendTilvert proc (
				x: float, y: float, 
				u: float, v: float, 
				r: float, g: float, b: float, a: float, 
				rOvr: float, gOvr: float, bOvr: float, aOvr: float, 
				pTilay: & STileLayer) inline
{
	pTilvert: & STileVertex = &pTilay.m_aTilvert[pTilay.m_cTilvert]
	++pTilay.m_cTilvert

	pTilvert.m_x = x
	pTilvert.m_y = y

	pTilvert.m_u = u
	pTilvert.m_v = v

	pTilvert.m_r = r
	pTilvert.m_g = g
	pTilvert.m_b = b
	pTilvert.m_a = a

	pTilvert.m_rOvr = rOvr
	pTilvert.m_gOvr = gOvr
	pTilvert.m_bOvr = bOvr
	pTilvert.m_aOvr = aOvr
}

FlushTileVerts proc (pDrac: & SDrawContext, pTilbuf: & STileVertexBuffer)
{

	// push orthographic projection
	glPushMatrix()
	glLoadIdentity()

	// set scissor rect

	// set up shader
	glEnable(GL_BLEND)
	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)
	assert(pDrac.m_pShman != null, "NULL GContext in flushTileVerts", #file, #line)
	BeginShader(pDrac.m_pShman, pDrac.m_pShman.m_mpCoreshkShhand[CORESHK.Sprite])


	pTex := pTilbuf.m_pSpset.m_pTex
	SetShaderParam(pTilbuf.m_pSpset.m_iParamTex, pTex, 0)

	for tilak := TILAK.min; tilak < TILAK.max; ++tilak
	{
		pTilay := &pTilbuf.m_mpTilakTilay[tilak]
		aTilvert: [] STileVertex = pTilay.m_aTilvert
		pTilvert := &aTilvert[0]

		glVertexAttribPointer(VERTATTR.Position, 3, GL_FLOAT, false, cast (s32) sizeof(STileVertex), &aTilvert[0].m_x)
		glVertexAttribPointer(VERTATTR.Color, 4, GL_FLOAT, true, cast (s32) sizeof(STileVertex), &aTilvert[0].m_r)
		glVertexAttribPointer(VERTATTR.ColorOvr, 4, GL_FLOAT, true, cast (s32) sizeof(STileVertex), &aTilvert[0].m_rOvr)
		glVertexAttribPointer(VERTATTR.TexCoord, 2, GL_FLOAT, false, cast (s32) sizeof(STileVertex), &aTilvert[0].m_u)
		glEnableVertexAttribArray(VERTATTR.Position)
		glEnableVertexAttribArray(VERTATTR.Color)
		glEnableVertexAttribArray(VERTATTR.ColorOvr)
		glEnableVertexAttribArray(VERTATTR.TexCoord)

		glDrawArrays(GL_QUADS, 0, cast (s32) pTilay.m_cTilvert)
		pTilay.m_cTilvert = 0
	}

	if (pTex)
	{
		glDisable(pTex.m_druTarget)
	}

	glDisableVertexAttribArray(VERTATTR.Position)
	glDisableVertexAttribArray(VERTATTR.Color)
	glDisableVertexAttribArray(VERTATTR.ColorOvr)
	glDisableVertexAttribArray(VERTATTR.TexCoord)
	EndShader()

	glPopMatrix()
}	

UpdatePlayers proc (pGame : & SGame, dT: f32)
{
	kDTStepDownSteerSlowMin immutable := 0.6
	kDTStepDownSteerSlowMax immutable := 0.4
	kDTStepDownDropSlow immutable := 0.3

	kDTStepDownSteerMedMin immutable := 0.4
	kDTStepDownSteerMedMax immutable := 0.25
	kDTStepDownDropMed immutable := 0.25

	kDTStepDownSteerFastMin immutable := 0.32
	kDTStepDownSteerFastMax immutable := 0.32
	kDTStepDownDropFast immutable := 0.25

	kDTHoldRepeatInitial immutable := 0.2
	kDTHoldRepeatAgain immutable := 0.15

	aFStepDown: [pGame.m_aPlay.count] bool

	for iPlay := 0; iPlay < pGame.m_cPlay; ++iPlay
	{
		pBoard := &g_game.m_aBoard[iPlay]
		pPlay := &g_game.m_aPlay[iPlay]
		pPlayinp := &pPlay.m_playinp

		dTStepDownSteer: f32
		dTStepDownDrop: f32
		switch (pPlay.m_pillspeed)
		{
			case PILLSPEED.Slow:
				dTStepDownSteer = GLerp(kDTStepDownSteerSlowMin, kDTStepDownSteerSlowMax, pPlay.m_uDropAccel)
				dTStepDownDrop = kDTStepDownDropSlow
			case PILLSPEED.Medium:
				dTStepDownSteer = GLerp(kDTStepDownSteerMedMin, kDTStepDownSteerMedMax, pPlay.m_uDropAccel)
				dTStepDownDrop = kDTStepDownDropMed
			case PILLSPEED.Fast:
				dTStepDownSteer = GLerp(kDTStepDownSteerFastMin, kDTStepDownSteerFastMax, pPlay.m_uDropAccel)
				dTStepDownDrop = kDTStepDownDropFast
		}

		aFStepDown[iPlay] = false
		if g_fApplyGravity
		{
			pPlay.m_dTStepDown += dT
		}

		dTStepDown: f32
		if pPlay.m_pEntSteer != null
		{
			dTStepDown = dTStepDownSteer
		}
		else
		{
			dTStepDown = dTStepDownDrop
		}

		if pPlay.m_dTStepDown > dTStepDown
		{
			aFStepDown[iPlay] = true
			pPlay.m_dTStepDown = 0
		}

		kDCellPerSecond immutable := 0
		kDCellPerSecondPressDown immutable := 20
		dCellPerSecond : f32 = kDCellPerSecond

		// update steering for player pill
		if (pPlay.m_pEntSteer)
		{
			pEntSteer := pPlay.m_pEntSteer

			posNew := pEntSteer.m_pos
			dirNew := pEntSteer.m_dir
			posCell := PosCell(pBoard, pEntSteer.m_pos)
			posTail := posCell + DCellFromDir(pEntSteer.m_dir)

			fMoveRight := false
			if pPlayinp.m_mpButkEdges[BUTK.Right] == EDGES.Hold
			{
				pPlay.m_dTRepeatHold -= dT
				if pPlay.m_dTRepeatHold <= 0
				{
					fMoveRight = true
					pPlay.m_dTRepeatHold = kDTHoldRepeatAgain
				}
			}
			else if pPlayinp.m_mpButkEdges[BUTK.Right] == EDGES.Press
			{
				pPlay.m_dTRepeatHold = kDTHoldRepeatInitial
				fMoveRight = true
			}

			if fMoveRight
			{ 
				if	!FIsCellOccupied(pBoard, posCell.m_x + 1, posCell.m_y, pEntSteer) &&
					!FIsCellOccupied(pBoard, posTail.m_x + 1, posTail.m_y, pEntSteer)
				{
					posNew.m_x = cast(f32)((posCell.m_x + 1) * pBoard.m_dXyTile.m_x)
					WwisePostEvent("MoveRight", pPlay.m_nSoundObj)
				}
			}

			fMoveLeft := false
			if pPlayinp.m_mpButkEdges[BUTK.Left] == EDGES.Hold
			{
				pPlay.m_dTRepeatHold -= dT
				if pPlay.m_dTRepeatHold < 0
				{
					fMoveLeft = true
					pPlay.m_dTRepeatHold = kDTHoldRepeatAgain
				}
			}
			else if pPlayinp.m_mpButkEdges[BUTK.Left] == EDGES.Press
			{
				pPlay.m_dTRepeatHold = kDTHoldRepeatInitial
				fMoveLeft = true
			}

			if fMoveLeft
			{
				if	!FIsCellOccupied(pBoard, posCell.m_x - 1, posCell.m_y, pEntSteer) &&
					!FIsCellOccupied(pBoard, posTail.m_x - 1, posTail.m_y, pEntSteer)
				{
					posNew.m_x = cast(f32)((posCell.m_x - 1) * pBoard.m_dXyTile.m_x)
					WwisePostEvent("MoveLeft", pPlay.m_nSoundObj)
				}
			}

			dCellDir := DCellFromDir(dirNew)
			posCellMin := S32x2Min(posCell, posCell + dCellDir)

			dirTry := dirNew
			nChange : int

			if pPlayinp.m_mpButkEdges[BUTK.RotateClock] == EDGES.Press || 
				pPlayinp.m_mpButkEdges[BUTK.RotateClockAlt] == EDGES.Press 
			{
				dirTry = (dirNew + 1) % DIR.max
				nChange = 1
			}

			if pPlayinp.m_mpButkEdges[BUTK.RotateCClock] == EDGES.Press ||
				pPlayinp.m_mpButkEdges[BUTK.RotateCClockAlt] == EDGES.Press
			{
				dirTry = (dirNew + DIR.max - 1) % DIR.max
				nChange = -1
			}

			posCellCheck: s32x2
			posCellCheckAlt: s32x2
			switch dirTry
			{
				case DIR.Left,
					DIR.Right:
					posCellCheck = posCellMin + S32x2Create(1, 0)
					posCellCheckAlt = posCellMin + S32x2Create(-1, 0)
				case DIR.Up,
					DIR.Down:
					posCellCheck = posCellMin + S32x2Create(0, 1)
					posCellCheckAlt = posCellMin + S32x2Create(1, 1)
			}

			posCellDest: s32x2 
			switch dirTry
			{
				case DIR.Right,
					DIR.Up:
						posCellDest = posCellMin
				case DIR.Left,
					DIR.Down: 
						posCellDest = posCellMin - DCellFromDir(dirTry)
			}

			if dirTry != dirNew 
			{
				fMoved := false
				if !FIsCellOccupied(pBoard, posCellCheck.m_x, posCellCheck.m_y, pEntSteer)  
				{
					posNew = F32x2Cast(posCellDest * pBoard.m_dXyTile)
					dirNew = dirTry
					fMoved = true
				}
				else if !FIsCellOccupied(pBoard, posCellCheckAlt.m_x, posCellCheckAlt.m_y)
				{
					posCellDest += (posCellCheckAlt - posCellMin)
					posNew = F32x2Cast(posCellDest * pBoard.m_dXyTile)
					dirNew = dirTry	
					fMoved = true
				}

				if fMoved
				{
					if (nChange > 0)
					{
						WwisePostEvent("TurnRight", pPlay.m_nSoundObj)
					}
					if (nChange < 0)
					{
						WwisePostEvent("TurnLeft", pPlay.m_nSoundObj)
					}
				}
			}

			if pPlayinp.m_mpButkEdges[BUTK.Down] >= EDGES.Hold
			{
				dCellPerSecond = kDCellPerSecondPressDown
				pPlay.m_dTHoldDown += dT
				pPlay.m_dTStepDown = 0
			}
			pPlay.m_dTTotal += dT

			pEntSteer.m_dir = dirNew
			pEntSteer.m_pos = posNew
			ReparentBoardEntity(pBoard, pEntSteer)
		}

		dYPerSec := cast(f32)pBoard.m_dXyTile.m_y * dCellPerSecond
		dY := dT * dYPerSec

		fPillHasLanded := false
		fAnyFalling := false
		for yCell := 0; yCell < kDYCellBoard; ++yCell
		{	
			for xCell := 0; xCell < kDXCellBoard; ++xCell
			{
				pEnt := PEntFromCell(pBoard, xCell, yCell, CELOOK.ExcludeTail)
				if !pEnt
					{ continue }

				pEnt.m_dTEnts += dT

				iCellPos := ICellFromPos(pBoard, pEnt.m_pos)
				iCell := ICell(xCell, yCell)
				assert(iCell == iCellPos, "bad cell calculation", #file, #line)

				if pEnt.m_ents == ENTS.Dead
				{
					if pEnt.m_dTEnts > kDTShowDead
					{
						FreeEntity(&g_game, &g_game.m_pEntUnusedFirst, pEnt)
					}
				}
				else if pEnt.m_entk != ENTK.Virus
				{
					// falling
					yNew := pEnt.m_pos.m_y
					if pPlay.m_pEntSteer == pEnt && dY > 0
					{
						yNew -= dY	
					}
					else if aFStepDown[iPlay]
					{
						yNew -= cast(f32)pBoard.m_dXyTile.m_y
					}

					fIsBelowBlocked := FIsCellOccupied(pBoard, xCell, yCell-1, pEnt)
					if pEnt.m_fHasTail
					{
						dCellTail := DCellFromDir(pEnt.m_dir)
						fIsBelowBlocked |= FIsCellOccupied(pBoard, xCell + dCellTail.m_x, yCell-1 + dCellTail.m_y, pEnt)
					}

					if !fIsBelowBlocked
					{
						pEnt.m_dTStabilize = 0
					}
					else
					{
						pEnt.m_dTStabilize += dT
					}

					yCellNew := NFloor(yNew / cast(f32)pBoard.m_dXyTile.m_y)
					if 	yCellNew != yCell
					{
						// check for a landing

						if fIsBelowBlocked
						{
							yNew = cast(f32)(yCell * pBoard.m_dXyTile.m_y) + 0.001

							if pEnt.m_dTStabilize > kDTStabilize && pEnt.m_ents != ENTS.Stable
							{
								pEnt.m_dTPulse = -kDTPulseBellStabilize
								fPillHasLanded = true	

								SetEnts(pEnt, ENTS.Stable)
								if pPlay.m_pEntSteer == pEnt
								{
									pPlay.m_pEntSteer = null
								}
							}
						}
						else
						{
							pEnt.m_dTPulse = 0
							SetEnts(pEnt, ENTS.Falling)
							fAnyFalling = true

							if !pPlay.m_pEntSteer
							{
								WwisePostEvent("SlowDrop", pPlay.m_nSoundObj)
							}
						}
					}
					pEnt.m_posSmooth.m_y += yNew - pEnt.m_pos.m_y
					pEnt.m_pos.m_y = yNew
					ReparentBoardEntity(pBoard, pEnt)
				}
			}
		}

		if fPillHasLanded
		{
			WwisePostEvent("PillLand", pPlay.m_nSoundObj)
		}

		smpPosX: SSmp
		smpPosX.m_dGMin = 150.0
		smpPosX.m_dGMax = 400.0
		smpPosX.m_dTMax = 0.1

		smpPosY: SSmp
		smpPosY.m_dGMin = 100.0
		smpPosY.m_dGMax = 250.0
		smpPosY.m_dTMax = 1.0

		smpRad: SSmp
		smpRad.m_dGMin = 5
		smpRad.m_dGMax = 40
		smpRad.m_dTMax = 0.05

		// loop over all cells checking for pills that should be dead
		cVirusLiving : int
		fAnyDied: bool
		fAnyDead: bool
		fVirusDied: bool
		for yCell := 0; yCell < kDYCellBoard; ++yCell
		{	
			for xCell := 0; xCell < kDXCellBoard; ++xCell
			{
				pEnt := PEntFromCell(pBoard, xCell, yCell, CELOOK.IncludeTail)
				if !pEnt
					{ continue }

				pEnt.m_posSmooth.m_x = GSmooth(pEnt.m_posSmooth.m_x, pEnt.m_pos.m_x, &smpPosX, dT)
				pEnt.m_posSmooth.m_y = GSmooth(pEnt.m_posSmooth.m_y, pEnt.m_pos.m_y, &smpPosX, dT)
				pEnt.m_radSmooth = RadSmooth(pEnt.m_radSmooth, RadFromDir(pEnt.m_dir), &smpRad, dT)

				if pEnt.m_ents != ENTS.Stable
				{ 
					fAnyDead |= pEnt.m_ents == ENTS.Dead
					continue 
				}

				pillcol := PillcolFromCell(pBoard, xCell, yCell)

				// horizontal scan
				xCellIt := xCell+1
				for ; xCellIt < kDXCellBoard; ++xCellIt	
				{
					if PillcolFromCell(pBoard, xCellIt, yCell) != pillcol
						{ break }
				}

				fAutoKill := (pPlay.m_grfplay & FPLAY.Autokill) != 0
				cPillcol := xCellIt - xCell
				cPillcolKill := 4
				if fAutoKill && pEnt.m_entk != ENTK.Virus
					{ cPillcolKill = 1}

				if cPillcol >= cPillcolKill
				{
					if !fAutoKill
						{ ++pPlay.m_cKills }

					for iCellDead := 0; iCellDead < cPillcol; ++iCellDead
					{
						fVirusDied |= EntkKillCell(pPlay, pBoard, xCell + iCellDead, yCell) == ENTK.Virus
						fAnyDied = true
					}
				}

				// vertical scan
				yCellIt := yCell+1
				for ; yCellIt < kDYCellBoard; ++yCellIt	
				{
					if PillcolFromCell(pBoard, xCell, yCellIt) != pillcol
						{ break }
				}

				cPillcol = yCellIt - yCell
				if cPillcol >= 4
				{
					++pPlay.m_cKills
					for iCellDead := 0; iCellDead < cPillcol; ++iCellDead
					{
						fVirusDied |= EntkKillCell(pPlay, pBoard, xCell, yCell + iCellDead) == ENTK.Virus
						fAnyDied = true
					}
				}

				pEnt.m_dTPulse += dT

				// living viruses?	
				if pEnt.m_entk == ENTK.Virus
				{
					if pEnt.m_ents != ENTS.Dead
					{
						cVirusLiving += 1
					}
				}
			}
		}

		if !cVirusLiving
		{
			SetGamres(pPlay, GAMRES.WinClearedAll)
		}

		if fAnyDied
		{
			UpdateDropAccel(pGame, iPlay)
			if (fVirusDied)
			{
				WwisePostEvent("VirusKill", pPlay.m_nSoundObj)
			}
			else
			{
				WwisePostEvent("PillKill", pPlay.m_nSoundObj)
			}
		}

		fAnyDead |= fAnyDied
		if fAnyFalling || fAnyDead
		{
			pPlay.m_dTUntilSpawn = GMax(kDTNextPill, pPlay.m_dTUntilSpawn - dT)
		}
		else
		{
			pPlay.m_dTUntilSpawn -= dT
		}
	}

	for iPlay := 0; iPlay < pGame.m_cPlay; ++iPlay
	{
		pPlay := &pGame.m_aPlay[iPlay]
		if pPlay.m_dTUntilSpawn < 0 && pPlay.m_pEntSteer == null && aFStepDown[iPlay]
		{
			if pPlay.m_cKills > 1
			{
				fSentGarbage := false

				for iPlayOther := 0; iPlayOther < pGame.m_cPlay; ++iPlayOther
				{
					if iPlay == iPlayOther
						{ continue }
					pGame.m_aPlay[iPlayOther].m_mpIplayCGarbagePending[iPlay] += pPlay.m_cKills
					pGame.m_aPlay[iPlayOther].m_cGarbageReceived += pPlay.m_cKills
					fSentGarbage |= pPlay.m_cKills > 0
				}

				pPlay.m_cGarbageSent += pPlay.m_cKills
				if fSentGarbage
				{
					switch iPlay
					{
					case 0: WwisePostEvent("SendGarbage1", pPlay.m_nSoundObj)
					case 1: WwisePostEvent("SendGarbage2", pPlay.m_nSoundObj)
					case 2: WwisePostEvent("SendGarbage1", pPlay.m_nSoundObj)
					}
				}
			}
			pPlay.m_cKills = 0
		}
	}

	// spawn garbage or pills
	for iPlay := 0; iPlay < pGame.m_cPlay; ++iPlay
	{
		pPlay := &pGame.m_aPlay[iPlay]
		pBoard := &pGame.m_aBoard[iPlay]
		if pPlay.m_dTUntilSpawn < 0 && pPlay.m_pEntSteer == null && aFStepDown[iPlay]
		{
			xCellMidpoint := kDXCellBoard/2 - 1
			yCellSpawn := kDYCellBoardVisible - 1

			iPlaySource := pGame.m_cPlay
			for iPlayOther := 0; iPlayOther < pGame.m_cPlay; ++iPlayOther
			{
				if pPlay.m_mpIplayCGarbagePending[iPlayOther] > 0
				{
					iPlaySource = iPlayOther
					break
				}
			}

			// drop garbage (if there's any pending)
			if iPlaySource < pGame.m_cPlay
			{
				//for iGarbage := 0; iGarbage < cGarbagePending; ++iGarbage
				iGarbage: int
				while iPlaySource < pGame.m_cPlay
				{
					xCellSearchMin, xCellSearchMax: int

					++iGarbage
					if (iGarbage % 0x2) == 0
					{
						xCellSearchMin = 0
						xCellSearchMax = xCellMidpoint
					}
					else
					{
						xCellSearchMin = xCellMidpoint
						xCellSearchMax = kDXCellBoard-1
					}


					// BB - should replace this with shuffle based search
					fFoundSpot := false
					for cRetry := 0; cRetry < 20; ++cRetry
					{
						xCellGarbage := NRandom(&pBoard.m_rng, cast (s32)xCellSearchMin, cast (s32)xCellSearchMax)

						if !FIsCellOccupied(pBoard, xCellGarbage, yCellSpawn)
						{
							pEntGarbage := PEntAllocate(&g_game.m_pEntUnusedFirst, ENTK.Garbage)
							if pEntGarbage
							{
								SetEnts(pEntGarbage, ENTS.Falling)
								pEntGarbage.m_iPlaySource = iPlaySource
								pEntGarbage.m_pillcol = cast(PILLCOL)NRandom(&pBoard.m_rng, PILLCOL.min, PILLCOL.MaxPills)

								CutPos(pEntGarbage, PosFromCell(pBoard, xCellGarbage, yCellSpawn), DIR.Right)
								ReparentBoardEntity(pBoard, pEntGarbage)
							}
							break
						}
					}

					pPlay.m_mpIplayCGarbagePending[iPlaySource] -= 1
					while pPlay.m_mpIplayCGarbagePending[iPlaySource] <= 0 && iPlaySource < pGame.m_cPlay
					{
						++iPlaySource
					}
				}
			}
			else
			{
				if FIsCellOccupied(pBoard, xCellMidpoint, yCellSpawn) ||
					FIsCellOccupied(pBoard, xCellMidpoint + 1, yCellSpawn)
				{
					SetGamres(pPlay, GAMRES.LoseOverflow)
				}
				else
				{
					pEntPill := PEntAllocate(&g_game.m_pEntUnusedFirst, ENTK.Pill)
					if pEntPill
					{
						SetEnts(pEntPill, ENTS.Falling)
						pEntPill.m_fHasTail = true
						pEntPill.m_pillcol = pPlay.m_pillcolNextHead
						pEntPill.m_pillcolTail = pPlay.m_pillcolNextTail

						pPlay.m_pillcolNextHead = cast(PILLCOL)NRandom(&pBoard.m_rng, PILLCOL.min, PILLCOL.MaxPills)
						pPlay.m_pillcolNextTail = cast(PILLCOL)NRandom(&pBoard.m_rng, PILLCOL.min, PILLCOL.MaxPills)

						CutPos(pEntPill, PosFromCell(pBoard, xCellMidpoint, yCellSpawn), pEntPill.m_dir)
						pPlay.m_pEntSteer = pEntPill

						ReparentBoardEntity(pBoard, pEntPill)
					}
				}
			}
		}
	}

	cWon, cLost, cPending: int
	pPlayPending: & SPlayer
	for iPlay := 0; iPlay < pGame.m_cPlay; ++iPlay
	{
		gamresCur := pGame.m_aPlay[iPlay].m_gamres
		if gamresCur >= GAMRES.LoseMin && gamresCur < GAMRES.LoseMax
		{
			++cLost
		}
		else if gamresCur >= GAMRES.WinMin && gamresCur < GAMRES.WinMax
		{
			++cWon
		}
		else 
		{
			++cPending
			pPlayPending = &pGame.m_aPlay[iPlay]
		}
	}

	if cPending <= 1 && cWon == 0 && pGame.m_cPlay > 1
	{
		if pPlayPending
		{
			SetGamres(pPlayPending, GAMRES.WinLastStanding)
			++cWon
		}
	}

	if cWon || cLost == pGame.m_cPlay
	{
		SetGams(pGame, GAMS.PostGame)

		for iPlay := 0; iPlay < pGame.m_cPlay; ++iPlay
		{
			pPlay := &pGame.m_aPlay[iPlay]
			if (pPlay.m_gamres == GAMRES.Pending)
			{
				SetGamres(pPlay, GAMRES.LoseTooSlow)
			}
		}
	}
}

UpdateDropAccel proc (pGame: & SGame, iPlay: int)
{
	pBoard := &pGame.m_aBoard[iPlay]
	pPlay := &pGame.m_aPlay[iPlay]

	// walk the board and find the highest virus	

	yVirusMin : int = kDYCellBoard
	`BoardLoop
	for yCell := kDYCellBoard; --yCell; ;
	{	
		for xCell := 0; xCell < kDXCellBoard; ++xCell
		{
			pEnt := PEntFromCell(pBoard, xCell, yCell, CELOOK.IncludeTail)
			if pEnt && pEnt.m_entk == ENTK.Virus && pEnt.m_ents != ENTS.Dead
			{
				yVirusMin = yCell
				break BoardLoop
			}
		}
	}

	kAccelMin immutable := 0.4
	kAccelMax immutable := 0.8
	uVirus := 1.0 - (cast(f32)(yVirusMin) / kDYCellBoard)
	uVirus = (uVirus - kAccelMin) / (kAccelMax - kAccelMin)
	uVirus = GClamp(uVirus, 0, 1)	

	pPlay.m_uDropAccel = uVirus
}

SetGamres proc (pPlay: & SPlayer, gamres: GAMRES)
{
	if (gamres >= GAMRES.WinMin && gamres < GAMRES.WinMax)
	{
		WwisePostEvent("PlayerWin", pPlay.m_nSoundObj)
	}

	pPlay.m_gamres = gamres
}

SetPlays proc (pPlay: & SPlayer, plays: PLAYS)
{
	pPlay.m_plays = plays
}

CVirusFromLevel proc (iLevel: int) -> int
{
	return (iLevel + 1) * 3	
}

SetGams proc (pGame: & SGame, gams: GAMS)
{
	pGame.m_gams = gams
	pGame.m_dTGams = 0

	dXyVport := S32x2Create(kDXWindow, kDYWindow)
	switch (pGame.m_gams)
	{
		case GAMS.Pregame:
			rngSeed := cast(u32)NRandom(&g_rng, 0, 0xFFFFFFFF)
			for iBoard := 0; iBoard < pGame.m_aBoard.count; ++iBoard
			{
				pBoard := &pGame.m_aBoard[iBoard]

				pBoard.m_nRngSeed = rngSeed
				SeedRandom(&pBoard.m_rng, pBoard.m_nRngSeed)
			}

			InitPlayers(&g_game)

			pGame.m_cPlay = kCPlayerMax
			for iBoard := 0; iBoard < pGame.m_cPlay; ++iBoard
		    {
			    ClearBoard(&pGame.m_aBoard[iBoard], pGame)
			    pPlay := &pGame.m_aPlay[iBoard]
				InitBoard(iBoard, pGame.m_cPlay, dXyVport, &pGame.m_aBoard[iBoard], CVirusFromLevel(pPlay.m_iStartingLevel))
			}

		case GAMS.InGame:

			// BB - need to remap correct players (and controllers) if there are gaps in the players that have signed in
			cPlay := 0

			// set up player 2 as an autokill player (for testing)
			/*
			pPlayAuto := &pGame.m_aPlay[1]
			if pPlayAuto.m_plays == PLAYS.Inactive
			{
				SetPlays(pPlayAuto, PLAYS.PregameReady)
				pPlayAuto.m_grfplay = pPlayAuto.m_grfplay | FPLAY.Autokill
			}*/

			for iPlay := 0; iPlay < pGame.m_aPlay.count; ++iPlay
			{
				pPlay := &pGame.m_aPlay[iPlay]
				if pPlay.m_plays >= PLAYS.PregameReady
				{
					++cPlay
					SetPlays(pPlay, PLAYS.InGame)
				}
			}

			pGame.m_cPlay = cPlay
			for iBoard := 0; iBoard < pGame.m_cPlay; ++iBoard
		    {
			    ClearBoard(&pGame.m_aBoard[iBoard], pGame)
			    pPlay := &pGame.m_aPlay[iBoard]
				InitBoard(iBoard, pGame.m_cPlay, dXyVport, &pGame.m_aBoard[iBoard], CVirusFromLevel(pPlay.m_iStartingLevel))
			}

		case GAMS.PostGame: 
			break
	}
}

PrepLineOption proc (fSelected: bool, pDrac: & SDrawContext)
{
	if (fSelected)
	{
		pDrac.m_pDras.m_fontd.m_colMain = ColCreate(255,255,255)
	}
	else
	{
		pDrac.m_pDras.m_fontd.m_colMain = ColCreate(128,128,128)
	}
}

UpdatePregame proc (pGame: & SGame, pDrac: & SDrawContext)
{
	pPlayZero := &pGame.m_aPlay[0]
	if pPlayZero.m_plays == PLAYS.Inactive
	{
		SetPlays(pPlayZero, PLAYS.PregameOptions)
	}

	cWaiting := 0
	for iPlay := 0; iPlay < pGame.m_aPlay.count; ++iPlay
	{
		pPlay := &pGame.m_aPlay[iPlay]
		pBoard := &pGame.m_aBoard[iPlay]
		pPlayinp := &pPlay.m_playinp

		posCenter := F32x2Cast(pBoard.m_pos) + F32x2Cast(pBoard.m_dXyBoard) * 0.5

		switch pPlay.m_plays
		{
			case PLAYS.Inactive:
				kGCharSizePrompt immutable := 60

				pFontd := &pDrac.m_pDras.m_fontd
				gCharSizePrev := pFontd.m_gCharSize
				pFontd.m_gCharSize = kGCharSizePrompt
				DrawTextCentered(pDrac, posCenter, "Press Start")
				pFontd.m_gCharSize = gCharSizePrev

				if pPlayinp.m_mpButkEdges[BUTK.Select] == EDGES.Press
				{
					SetPlays(pPlay, PLAYS.PregameOptions)
				}

			case PLAYS.PregameOptions:

				kGCharSizeOptions immutable := 45
				kGCharSizePrompt immutable := 45
				kDYWindow immutable := 45
				pFontd := &pDrac.m_pDras.m_fontd
				gCharSizePrev := pFontd.m_gCharSize
				pFontd.m_gCharSize = kGCharSizeOptions

				aCh: [128] u8		
				snprintf(aCh, aCh.count, "Level: %d", pPlay.m_iStartingLevel)
				PrepLineOption(pPlay.m_iMenuItem == 0, pDrac)
				if pPlay.m_iMenuItem == 0
				{
					if pPlayinp.m_mpButkEdges[BUTK.Left] == EDGES.Press
					{
						WwisePostEvent("UiDec", pPlay.m_nSoundObj)
						pPlay.m_iStartingLevel = NMax(1, pPlay.m_iStartingLevel - 1)
					}
					else  if pPlayinp.m_mpButkEdges[BUTK.Right] == EDGES.Press
					{
						WwisePostEvent("UiInc", pPlay.m_nSoundObj)
						pPlay.m_iStartingLevel = NMin(20, pPlay.m_iStartingLevel + 1)
					}
				}
				DrawTextCentered(pDrac, posCenter, aCh)
				posCenter.m_y -= kDYWindow

				snprintf(aCh, aCh.count, "Speed: %s", PILLSPEED.names[pPlay.m_pillspeed])
				PrepLineOption(pPlay.m_iMenuItem == 1, pDrac)
				if pPlay.m_iMenuItem == 1
				{
					if pPlayinp.m_mpButkEdges[BUTK.Left] == EDGES.Press
					{
						WwisePostEvent("UiDec", pPlay.m_nSoundObj)
						pPlay.m_pillspeed = Max(PILLSPEED.min, pPlay.m_pillspeed - 1)
					}
					else  if pPlayinp.m_mpButkEdges[BUTK.Right] == EDGES.Press
					{
						WwisePostEvent("UiInc", pPlay.m_nSoundObj)
						pPlay.m_pillspeed = Min(PILLSPEED.last, pPlay.m_pillspeed + 1)
					}
				}
				DrawTextCentered(pDrac, posCenter, aCh)
				posCenter.m_y -= kDYWindow * 3

				PrepLineOption(true, pDrac)
				pFontd.m_gCharSize = kGCharSizePrompt
				DrawTextCentered(pDrac, posCenter, "Press X when ready")
				++cWaiting

				pDrac.m_pDras.m_fontd.m_colMain = ColCreate(255,255,255)
				pFontd.m_gCharSize = gCharSizePrev

				cMenuItem immutable := 2

				if pPlayinp.m_mpButkEdges[BUTK.Up] == EDGES.Press
				{
					pPlay.m_iMenuItem = NMax(0, pPlay.m_iMenuItem - 1)
				}
				else  if pPlayinp.m_mpButkEdges[BUTK.Down] == EDGES.Press
				{
					pPlay.m_iMenuItem = NMin(cMenuItem, pPlay.m_iMenuItem + 1)
				}

				if pPlayinp.m_mpButkEdges[BUTK.Select] == EDGES.Press
				{
					WwisePostEvent("UiOk", pPlay.m_nSoundObj)
					SetPlays(pPlay, PLAYS.PregameReady)
				}
				if pPlayinp.m_mpButkEdges[BUTK.Cancel] == EDGES.Press
				{
					SetPlays(pPlay, PLAYS.Inactive)
				}
			case PLAYS.PregameReady:
				kGCharSizeTitle immutable := 60
				kDYLine immutable := 45

				pFontd := &pDrac.m_pDras.m_fontd
				gCharSizePrev := pFontd.m_gCharSize
				pFontd.m_gCharSize = kGCharSizeTitle
				DrawTextCentered(pDrac, posCenter, "Ready")
				posCenter.m_y -= kDYWindow

				aCh: [128] u8		
				snprintf(aCh, aCh.count, "Level %d", pPlay.m_iStartingLevel)
				DrawTextCentered(pDrac, posCenter, aCh)
				posCenter.m_y -= kDYWindow

				snprintf(aCh, aCh.count, "Speed: %s", PILLSPEED.names[pPlay.m_pillspeed])
				DrawTextCentered(pDrac, posCenter, aCh)
				pFontd.m_gCharSize = gCharSizePrev

				if pPlayinp.m_mpButkEdges[BUTK.Cancel] == EDGES.Press
				{
					SetPlays(pPlay, PLAYS.PregameOptions)
				}
		}
	}

	if cWaiting == 0
	{
		SetGams(pGame, GAMS.InGame)
	}
}

DrawGameResults proc (pDrac: & SDrawContext, pPlay: & SPlayer, pBoard: & SBoard)
{
	xMin : f32 = cast(f32)pBoard.m_pos.m_x
	yMin : f32 = cast(f32)pBoard.m_pos.m_y
	xMax : f32 = cast(f32)(pBoard.m_pos.m_x + pBoard.m_dXyBoard.m_x) + pBoard.m_gTileSpacing
	yMax : f32 = cast(f32)(pBoard.m_pos.m_y + pBoard.m_dXyBoard.m_y) + pBoard.m_gTileSpacing
	colvecBg : SColorVec


	kGCharSizeWinLose immutable := 80
	kGCharSizeStats immutable := 45
	kGCharSizePrompt immutable := 40
	kDYTextLine	immutable := 55

	posCenter := F32x2Cast(pBoard.m_pos) + F32x2Cast(pBoard.m_dXyBoard) * 0.5
	posCenter.m_y += kDYTextLine * 5
	aCh: [128] u8
	switch pPlay.m_gamres
	{
		case GAMRES.WinClearedAll,
			GAMRES.WinLastStanding:
			snprintf(aCh, aCh.count, "Winner!")
			colvecBg = ColvecFromCol(ColCreate(25, 25, 50, 130))
		case GAMRES.LoseOverflow,
			GAMRES.LoseTooSlow:
			snprintf(aCh, aCh.count, "You Lose.")
			colvecBg = ColvecFromCol(ColCreate(100, 0, 0, 100))
	}

	AppendTile(SFRAM.Untextured, xMin, yMin, xMax, yMax, &colvecBg, &g_tilbuf)

	pFontd := &pDrac.m_pDras.m_fontd
	gCharSizePrev := pFontd.m_gCharSize

	pFontd.m_gCharSize = kGCharSizeWinLose
	DrawTextCentered(pDrac, posCenter, aCh)

	pFontd.m_gCharSize = kGCharSizeStats
	posCenter.m_y -= kDYTextLine * 3
	snprintf(aCh, aCh.count, "%d kills", pPlay.m_cKilledCells)
	DrawTextCentered(pDrac, posCenter, aCh)

	posCenter.m_y -= kDYTextLine
	snprintf(aCh, aCh.count, "%d chain combos", pPlay.m_cGarbageSent)
	DrawTextCentered(pDrac, posCenter, aCh)

	posCenter.m_y -= kDYTextLine
	snprintf(aCh, aCh.count, "%d garbage received", pPlay.m_cGarbageReceived)
	DrawTextCentered(pDrac, posCenter, aCh)
	posCenter.m_y -= kDYTextLine

	nPercent := cast(int)(100.0 * pPlay.m_dTHoldDown / pPlay.m_dTTotal)
	snprintf(aCh, aCh.count, "%d%% pressing down", nPercent)
	DrawTextCentered(pDrac, posCenter, aCh)

	pFontd.m_gCharSize = kGCharSizePrompt
	posCenter.m_y -= kDYTextLine * 5
	DrawTextCentered(pDrac, posCenter, "Press X To Continue.")

	pFontd.m_gCharSize = gCharSizePrev
}

main proc () -> int
{
	pWindow : HWND
	CreateWindow(kDXWindow, kDYWindow, "Physician PillMan", &pWindow)

	pDrac := PDracStaticInit(PVAllocDefault)
	if !pDrac
		{return 0 }

	pDrac.m_pDras.m_fontd.m_gCharSize = 20
	pDrac.m_pDras.m_fontd.m_rKerning = 1.05

	SetupOrthoViewport(0, 0, kDXWindow, kDYWindow)

	spset: SSpriteSet
	if !FTryInitSprites(pDrac, &spset, "Assets/Sprites/docSprites")
		{ return 0 }

	g_tilbuf.m_pSpset = &spset

	if !WwiseInit()
	{
		printf("failed to init wwise")
		return 0
	}

	WwiseSetBasePath(".\\Assets\\sound\\doc\\banks")
	if !WwiseLoadBank("init.bnk") || !WwiseLoadBank("moe.bnk")
	{
		printf("failed to load bank")
		WwiseShutdown()
		return 0
	}

	//SeedRandom(&g_rng, 0xBADDBEEF)
	SeedRandom(&g_rng, NTimeSeed())

    dRadSpin immutable := 0.01
    gRadSpin: float

	InitUnusedEntList(g_game.m_aEnt, &g_game.m_pEntUnusedFirst)

    // Make sure sleep has 1ms granularity
    s_cMsDesiredGranularity immutable := 1
    fIsSleepGranular := FTrySetTimerResolution(s_cMsDesiredGranularity)
    g_cTickPerSecond = CTickPerSecond() 

    nHzMonitorRefresh : s32 = GetMonitorRefresh(pWindow)
    nHzTarget := cast (f32)(nHzMonitorRefresh)

    dTFrameTarget := 1.0 / nHzTarget
	aChStatus: [512] u8

	cTickLast := CTickWallClock()
	fShouldClose := false
	dTGame: f32

	SetGams(&g_game, GAMS.Pregame)

	pVJoyman := CreateJoystickManager()
	InitJoysticks(&g_game)

	while fShouldClose == false
	{
		UpdateJoystickManager(pVJoyman)

		fShouldClose |= !FHandleEvents(&g_game)

		/*
		for iPlay := 1; iPlay < g_game.m_aPlay.count; ++iPlay
		{
			g_game.m_aPlay[iPlay].m_playinp = g_game.m_aPlay[0].m_playinp
		}*/

		gRadSpin += dRadSpin

		DrawBoards(&g_game, pDrac)

		for iPlay := 0; iPlay < g_game.m_cPlay; ++iPlay
		{
			pPlay := &g_game.m_aPlay[iPlay]
			if pPlay.m_gamres != GAMRES.Pending
			{
    			pBoard := &g_game.m_aBoard[iPlay]
    			DrawGameResults(pDrac, pPlay, pBoard)
    		}
		}

		FlushTileVerts(pDrac, &g_tilbuf)
		FlushFontVerts(pDrac, &g_Fvbuf)

		//DrawTestTriangle(gRadSpin)

        SwapBuffers(pWindow)
		ClearWindow(0, 0, 0, 1)

        UpdateWindowEvents()

        switch (g_game.m_gams)
        {
        	case GAMS.Pregame:
        		UpdatePregame(&g_game, pDrac)
        	case GAMS.InGame:
		        UpdatePlayers(&g_game, dTGame)
        	case GAMS.PostGame:
        		for iPlay := 0; iPlay < g_game.m_cPlay; ++iPlay
        		{
        			pPlay := &g_game.m_aPlay[iPlay]

					if g_game.m_dTGams > kDTEndgameMin && pPlay.m_playinp.m_mpButkEdges[BUTK.Select] == EDGES.Press
					{
						SetGams(&g_game, GAMS.Pregame)
					}
        		}
        }
        g_game.m_dTGams += dTGame

// 		if !s_fIsPaused
	    {
	    	cTickWork := CTickWallClock()
	    	dTWorkElapsed := DTElapsed(cTickLast, cTickWork)

	        dTElapsedFrame := dTWorkElapsed
	        if dTElapsedFrame < dTFrameTarget
	        {                        
	            if fIsSleepGranular
	            {
	                SleepMS := cast (u32)(1000.0 * (dTFrameTarget - dTElapsedFrame))
	                if SleepMS > 0
	                {
	                    Sleep(SleepMS)
	                }
	            }

	            while dTElapsedFrame < dTFrameTarget
	            {                            
	                dTElapsedFrame = DTElapsed(cTickLast, CTickWallClock())
	            }
	        }
	    }

	    cTickEnd := CTickWallClock()
	    dTFrameActual := DTElapsed(cTickLast, cTickEnd)
	    cTickLast = cTickEnd

	    nHzActual := 1 / dTFrameActual
	    snprintf(aChStatus, aChStatus.count, "%0.1f / %0.1f, %0.2f ms", nHzActual, nHzTarget, dTFrameActual * 1000)
		DrawText(pDrac, F32x2Create(20, kDYWindow - 35), aChStatus)

		dTGame = dTFrameActual
		g_systCur += dTGame

		WwiseProcessAudio()
	}

	WwiseShutdown()
	return 1
}