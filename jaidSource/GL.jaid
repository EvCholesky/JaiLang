#foreign_library "GL"
#foreign_library "opengl32"
#foreign_library "legacy_stdio_definitions"
#foreign_library "..\external\glfw\lib\win32\glfw3"
#foreign_library "user32"
#foreign_library "gdi32"
#foreign_library "shell32"

SRect :: struct 
{
    m_left : s32;
    m_top : s32;
    m_right : s32;
    m_bottom : s32;
}

CreateWindow :: (dX : s64, dY : s64, pChzName : & u8, ppVHwnd : && void) -> bool #foreign;
ClearWindow :: (uRed : float, uGreen : float, uBlue : float, uAlpha : float) -> void #foreign;
UpdateWindowEvents :: () -> void #foreign;
SwapBuffers :: (pVHwnd : & void) -> void #foreign SwapBuffers_JAI;
FGetNextEvent :: (pEvent: & SEvent) -> bool #foreign;

GL_TRIANGLES ::             0x0004;
GL_TEXTURE_2D ::            0x0DE1;
GL_BYTE ::                  0x1400;
GL_UNSIGNED_BYTE ::         0x1401;
GL_SHORT ::                 0x1402;
GL_UNSIGNED_SHORT ::        0x1403;
GL_INT ::                   0x1404;
GL_UNSIGNED_INT ::          0x1405;
GL_FLOAT ::                 0x1406;
GL_2_BYTES ::               0x1407;
GL_3_BYTES ::               0x1408;
GL_4_BYTES ::               0x1409;
GL_DOUBLE ::                0x140A;
GL_RGBA ::                  0x1908;

GL_TEXTURE_BASE_LEVEL ::    0x813C;
GL_TEXTURE_MAX_LEVEL  ::    0x813D;

GL_FRAGMENT_SHADER_ARB ::   0x8B30;
GL_VERTEX_SHADER_ARB ::     0x8B31;

GL_COMPILE_STATUS ::        0x8B81;
GL_LINK_STATUS ::           0x8B82;
GL_INFO_LOG_LENGTH ::       0x8B84;

glsizei :: typedef s32;
glint :: typedef s32;
gluint :: typedef u32;
glenum :: typedef u32;
glchar :: typedef u8;

glBegin :: (mode: s32) #foreign #stdcall;
glEnd :: () #foreign #stdcall;
glColor4f       :: (r: float, g: float, b: float, a: float) -> void #foreign #stdcall;
glColor3f       :: (r: float, g: float, b: float) -> void #foreign #stdcall;
glVertex3f   :: (x: float, y: float, z: float) #foreign #stdcall;
glVertex2f   :: (x: float, y: float) #foreign #stdcall;

glLoadIdentity :: () -> void #foreign #stdcall;
glOrtho :: (xLeft: f64, xRight: f64, yBottom: f64, yTop: f64, zNear: f64, zFar: f64) -> void #foreign #stdcall;
glGenTextures :: (n: glsizei, textures: & gluint) #foreign #stdcall;
glBindTexture :: (target: glenum, texture: gluint) #foreign #stdcall;
glTexParameteri :: (target: glenum, pname: glenum, param: glint) #foreign #stdcall;
glTexImage2D :: (target: glenum, level: glint, internalformat: glint, width: glsizei, height: glsizei, border: glint, format: glenum, type: glenum, pixels: &void) #foreign #stdcall;

// GL extension function pointers
glCreateProgram : () -> gluint #stdcall;
glDeleteProgram : (program: gluint) #stdcall;
glLinkProgram : (program: gluint) #stdcall;
glCreateShader : (type: glenum) -> gluint #stdcall;
glDeleteShader : (shader: gluint) #stdcall;
glShaderSource : (shader: gluint, count: glsizei, string: &&u8, length: &glint) #stdcall;
glCompileShader : (handle: gluint) #stdcall;
glGetShaderiv : (shader: gluint, pname: glenum, param: &glint) #stdcall;
glGetProgramiv : (shader: gluint, pname: glenum, param: &glint) #stdcall;
glGetShaderInfoLog : (shader: gluint, bufSize: glsizei, length: &glsizei, infoLog: &glchar) #stdcall;
glGetProgramInfoLog : (shader: gluint, bufSize: glsizei, length: &glsizei, infoLog: &glchar) #stdcall;
glAttachShader : (program: gluint, shader: gluint) #stdcall;

EVENTK :: enum s32 
{  // If we set this to u8, our packing will stop matching C's.
    Keyboard,
    TextInput,
    Window,
    Quit,
}

KEYCODE :: enum u32 
{
    Unknown: 0,
    ArrowLeft : 1,
    ArrowRight : 2,
    ArrowUp : 3,
    ArrowDown : 4,
    Shift : 5,
    Escape : 6,
    MouseButtonLeft : 7,
    MouseButtonRight : 8,

    Enter : 10,

    F1:  11,
    F2:  12,
    F3:  13,
    F4:  14,
    F5:  15,
    F6:  16,
    F7:  17,
    F8:  18,
    F9:  19,
    F10: 20,
    F11: 21,
    F12: 22,
    F13: 23,
    F14: 24,
    F15: 25,
    F16: 26,
}

EDGES :: enum u32
{
	Off,
	Release,
	Hold,
	Press	
}

SEvent :: struct 
{
    m_eventk : EVENTK = EVENTK.nil;

    // If keyboard event:
    m_edges : EDGES;
    m_keycode : KEYCODE = KEYCODE.nil;
    m_nTextInput : u32;
}

GlfwProc :: typedef ()->void;
PFnGlProcLookup :: (pChzName: &u8) -> GlfwProc #foreign;

FTryInitExtension :: (pChzName: &u8, pfSuccess: &bool) -> GlfwProc 
{
   pFn := PFnGlProcLookup(pChzName); 
   if pFn == null
   {
    printf("Failed to lookup glProc '%s'\n", pChzName);
        @pfSuccess = false;
   }
   return pFn;
}

FTryInitGLExtensions :: () -> bool
{
    // Hopefully this gets less gross when we have reflection

    fSuccess:= true;
    glCreateProgram = acast FTryInitExtension("glCreateProgram", &fSuccess);
    glDeleteProgram  = acast FTryInitExtension("glDeleteProgram", &fSuccess);
    glLinkProgram = acast FTryInitExtension("glLinkProgram", &fSuccess);
    glCreateShader = acast FTryInitExtension("glCreateShader", &fSuccess);
    glDeleteShader = acast FTryInitExtension("glDeleteShader", &fSuccess);
    glShaderSource = acast FTryInitExtension("glShaderSource", &fSuccess);
    glCompileShader = acast FTryInitExtension("glCompileShader", &fSuccess);
    glGetShaderiv = acast FTryInitExtension("glGetShaderiv", &fSuccess);
    glGetProgramiv = acast FTryInitExtension("glGetProgramiv", &fSuccess);
    glGetShaderInfoLog = acast FTryInitExtension("glGetShaderInfoLog", &fSuccess);
    glGetProgramInfoLog = acast FTryInitExtension("glGetProgramInfoLog", &fSuccess);
    glAttachShader = acast FTryInitExtension("glAttachShader", &fSuccess);
    return fSuccess;
}

