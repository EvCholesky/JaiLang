#foreign_library "Basic"

PrintFloat :: (g : float) #foreign;
PrintInt :: (n : int) #foreign;
PrintByte :: (n : s8) #foreign;
PrintBool :: (f : bool) #foreign;
PrintPointer :: (pB : & u8) #foreign;
PrintString :: (pCh : & u8) #foreign;
printf :: (pCh : &u8, ..) -> s32 #foreign;

HANDLE :: typedef int; 	// This actually needs to be pointer-sized, so s32 in 32-bit, 
						//  but lots of people use integers too, arrrrgh!!

INVALID_HANDLE :: -1;

HWND :: typedef HANDLE;
HDC  :: typedef HANDLE;

SStartupInfo :: struct 
{
    m_cb : s32;
    m_lpReserved : & u8;
    m_lpDesktop : & u8;
    m_lpTitle : & u8;
    m_dwX : s32;
    m_dwY : s32;
    m_dwXSize : s32;
    m_dwYSize : s32;
    m_dwXCountChars : s32;
    m_dwYCountChars : s32;
    m_dwFillAttribute: s32;
    m_dwFlags : s32;
    m_wShowWindow : s16;
    m_cbReserved2 : s16;
    m_lpReserved2 : & u8;
    m_hStdInput : HANDLE;
    m_hStdOutput : HANDLE;
    m_hStdError : HANDLE;
}

// (JBlow) For some reason in Windows sinf and cosf don't have linkage, probably because
// they always get turned into intrinsics? So I made my own..
cos  :: (theta: float) -> float #foreign cosf_JAI; 
sin  :: (theta: float) -> float #foreign sinf_JAI;
sqrt :: (theta: float) -> float #foreign sqrtf_JAI;

cos64  :: (theta: f64) -> f64 #foreign cos; 
sin64  :: (theta: f64) -> f64 #foreign sin;
sqrt64 :: (theta: f64) -> f64 #foreign sqrt;

DebugBreak :: () -> void #foreign;
PVMalloc :: (cB : s64) -> & void #foreign;
FreeMalloc :: (pV: &void) #foreign;

FuncAllocate :: typedef (allock: ALLOCK, cB: s64, cBPrev: s64, pVPrev: & void, pVAllocator: & void, options: s64) -> & void;

memcpy :: (dest: &void, source: &void, count: s64) -> &void #foreign;
memset :: (dest: &void, value: int, count: s64)    -> &void #foreign;

PVAllocateDefault :: (allock: ALLOCK, cB: s64, cBPrev: s64, pVPrev: & void, pVAllocator: & void, options: s64) -> & void
{
    if allock == ALLOCK.Allocate
    {
        return PVMalloc(cB);
    } 
    else if allock == ALLOCK.Resize
    {
        // For now, we dont even bother with realloc, just allocate, copy, free.
        pVNew := PVMalloc(cB);
        if !pVNew
            return null;

        if pVPrev && (cBPrev > 0) 
        {
            memcpy(pVNew, pVPrev, cBPrev);
            FreeMalloc(pVPrev);
        }

        return pVNew;
    }
    else if allock == ALLOCK.Free
    {
        FreeMalloc(pVPrev);
    }
    else if allock == ALLOCK.FreeAll 
    {
        assert(false, "ALLOCK.FreeAll is not yet implemented", #file, #line);
    }
    else 
    {
        assert(false, "unhanadled ALLOCK ", #file, #line);
    }

    return null;
}

ALLOCK :: enum 
{
    Allocate,
    Resize,
    Free,
    FreeAll
}

assert :: (fPredicate: bool, pChz: & u8, pChzFile: & u8, nLine: int)
{
	if (!fPredicate)	
	{
		printf("ASSERT FAILED: (%s, %d) %s\n", pChzFile, nLine, pChz); 
		DebugBreak();
	}
}

fverify :: (fPredicate: bool, pChz: & u8, pChzFile: & u8, nLine: int) -> bool
{
	if (!fPredicate)	
	{
		printf("ASSERT FAILED: (%s, %d) %s\n", pChzFile, nLine, pChz); 
		DebugBreak();
	}
	return fPredicate;
}
