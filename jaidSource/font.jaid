#import "Color"
#import "File"
#import "Gl"
#import "Hash"
#import "stb_image"

ALIGNK :: enum
{
	Center,
	SideMin,
	SideMax,
	Left:		SideMin,
	Bottom:		SideMin,
	Right:		SideMax,
	Top:		SideMax,
}

SDrawData :: struct // tag = drawd
{
	m_fontd: SFontData;
}

SFontData :: struct // tag = fontd
{
	m_colMain: SColor;
	m_colShadow: SColor;
	m_gCharSize: f32;
	m_uOpacit: f32;
	m_iGlyphSet: int;
	m_alignkX: ALIGNK;
	m_alignkY: ALIGNK;
	m_fUseFixedWidth: bool;
	m_fUseWordWrap: bool;
}

/*
DRASK :: enum // draw state kind
{
	RectMin,
		RectScissor		= RectMin,
	RectMax,

	VecMin,
		PosSortOriginWs	= VecMin,		// this is the origin for tile "perspective" and sorting
		VecScale,
		PosCursor,
	VecMax,

	ColMin,
		ColFontMain		= ColMin,
		ColFontShadow,
	ColMax,

	GMin,
		GCharSize		= GMin,
		ROpacity,
	GMax,

	NMin,
		IFont			= NMin,
		NAlignkX,
		NAlignkY,
	NMax,


	FMin,
		FFixedWidthFont	= FMin,
		FWordWrap,
		FUseScissor,
		FDrawSolid,
	FMax,
};

SDrawState :: struct
{					
	m_aRect: [DRASK.RectMax - DRASK.RectMin] CRect;
	m_aVec: [DRASK.VecMax - DRASK.VecMin] CVec2;
	m_aCol: [DRASK.ColMax - DRASK.ColMin] CColor;
	m_aG: [DRASK.GMax - DRASK.GMin] f32;
	m_aN: [DRASK.NMax - DRASK.NMin] s16;
	m_aF: [DRASK.FMax - DRASK.FMin] bool;
};

InitDrask :: (pDrask :: & SDrawState)
{
	SetRect(DRASK.RectScissor, CRect(0,0,0,0));

	SetVec(DRASK.PosSortOriginWs, CVec2(KZERO));
	SetVec(DRASK.VecScale, CVec2(1.0f, 1.0f));
	SetVec(DRASK.PosCursor, CVec2(KZERO));

	SetCol(DRASK.ColFontMain, CColor(kWhite));
	SetCol(DRASK.ColFontShadow, CColor(kBlack));

	SetG(DRASK.GCharSize, 24.0f);
	SetG(DRASK.ROpacity, 1.0f);

	SetN(DRASK.IFont, 0);
	SetN(DRASK.NAlignkX, ALIGNK_Center);
	SetN(DRASK.NAlignkY, ALIGNK_Center);

	SetF(DRASK.FFixedWidthFont, false);
	SetF(DRASK.FWordWrap, false);
	SetF(DRASK.FUseScissor, false);
	SetF(DRASK.FDrawSolid, true);
}

SetF :: (pDras: & SDrawState, drask: DRASK, f: bool)
{ 
	assert((drask>=DRASK.FMin)&(drask<DRASK.FMax), "bad drask(F)");
	pDras.m_aF[drask-DRASK.FMin] = f; 
}

SetN :: (pDras: & SDrawState, drask: DRASK, n s16)
{ 
	assert((drask>=DRASK.NMin)&(drask<DRASK.NMax), "bad drask(N)");
	pDras.m_aN[drask-DRASK.NMin] = n;
}

SetG :: (pDras: & SDrawState, drask: DRASK, g: f32)
{ 
	assert((drask>=DRASK.GMin)&(drask<DRASK.GMax), "bad drask(G)");
	pDras.m_aG[drask-DRASK.GMin] = g;
}

SetCol :: (drask: DRASK, CColor col)
{ 
	EWC_ASSERT((drask>=DRASK.ColMin)&(drask<DRASK.ColMax), "bad drask(Col)");
	pDras.m_aCol[drask-DRASK.ColMin] = col;
}

SetVec :: (drask: DRASK, CVec2Arg vec)
{ 
	EWC_ASSERT((drask>=DRASK.VecMin)&(drask<DRASK.VecMax), "bad drask(Vec)");
	pDras.m_aVec[drask-DRASK.VecMin] = vec;
}

SetRect :: (drask: DRASK, CRectArg rect)
{ 
	EWC_ASSERT((drask>=DRASK.RectMin)&(drask<DRASK.RectMax), "bad drask(Rect)");
	pDras.m_aRect[drask-DRASK.RectMin] = rect;
}

bool	FGet(DRASK drask) const
			{
				EWC_ASSERT((drask>=DRASK.FMin)&(drask<DRASK.FMax), "bad drask(F)");
				return m_aF[drask-DRASK.FMin];
			}
I16		NGet(DRASK drask) const
			{
				EWC_ASSERT((drask>=DRASK.NMin)&(drask<DRASK.NMax), "bad drask(N)");
				return m_aN[drask-DRASK.NMin];
			}
F32		GGet(DRASK drask) const
			{
				EWC_ASSERT((drask>=DRASK.GMin)&(drask<DRASK.GMax), "bad drask(G)");
				return m_aG[drask-DRASK.GMin];
			}
CColor	ColGet(DRASK drask) const
			{
				EWC_ASSERT((drask>=DRASK.ColMin)&(drask<DRASK.ColMax), "bad drask(Col)");
				return m_aCol[drask-DRASK.ColMin];
			}
CVec2	VecGet(DRASK drask) const
			{
				EWC_ASSERT((drask>=DRASK.VecMin)&(drask<DRASK.VecMax), "bad drask(Vec)");
				return m_aVec[drask-DRASK.VecMin];
			}
CRect	RectGet(DRASK drask) const
			{
				EWC_ASSERT((drask>=DRASK.RectMin)&(drask<DRASK.RectMax), "bad drask(Rect)");
				return m_aRect[drask-DRASK.RectMin];
			}

void	SetAlignk(ALIGNK alignkX, ALIGNK alignkY)
			{
				SetN(DRASK.NAlignkX, alignkX);
				SetN(DRASK.NAlignkY, alignkY);
			}

void	FlushIfChanged(const CDrawState & drasPrev)
			{ ; }

void	PreDraw() const;
void	PostDraw() const;
*/



DrawInt :: typedef s32; // tag=dri
DrawEnum :: typedef u32; // tag=dru
SHHAND :: enum  s16
{
	// just has nil
};
 
STextureMip :: struct // tag=texmip
{
	m_dX: DrawInt;
	m_dY: DrawInt;
	m_cB: u32; // data size
	m_aB: & u8; // actual texel data
};

STexture :: struct // tag=tex
{
	m_shashFilename: SStringHash;	// filename hash, for texture reuse
	m_cTexmip: u8;
	m_iTex: s16;					// index into our global texture array
	m_driId: gluint;				// GL id for this texture
	m_driComponents: DrawInt;		// number of components or GL-specific format	(GL_RGBA)
	m_druFormat: DrawEnum;			// format of color such as indexed or RGBA		(GL_RGBA)
	m_druType: DrawEnum;			// data type for each component					(GL_UNSIGNED_BYTE)
	m_druTarget: DrawEnum;			// gl target type (ie. GL_TEXTURE_2D)

	m_aTexmip: [1] STextureMip;
};

g_cTex : s32;
g_aTex : [50] STexture;

DXFromTex :: (pTex: & STexture)->DrawInt
{ 
	return pTex.m_aTexmip[0].m_dX;
}

DYFromTex :: (pTex: & STexture)->DrawInt
{
	return pTex.m_aTexmip[0].m_dY;
}
	
FONTK :: enum
{
	Regular,
	Bold,
};
		
FONTSHK :: enum
{
	Basic,
}

SFontGlyph :: struct // tag=glyph
{
	m_wch: s32;				// UCS2 Codepoint for this glyph
	m_dXPixels: f32;
	m_dYPixels: f32;
	m_xOffset: f32;				// offset from the glyph origin to the top-left of the bitmap
	m_yOffset: f32;
	m_dXKerningDefault: f32;	// offset between letters
	m_iDxKerningMin: u16;		// index into the kerning table 0xFFFF if none
	m_iDxKerningMax: u16;		// index into the kerning table 0xFFFF if none
	m_uMin: f32;
	m_uMax: f32;
	m_vMin: f32;
	m_vMax: f32;
}

SFontGlyphFile :: struct //tag=glyphf
{
	m_cGlyph: s16;
	m_iBaWchKerning: s32; 			// byte offset from the start of this structure to n^2 list of kerning glyph pairs (UCS2)
	m_iBaDxKerning: s32;			// byte offset from the start of this structure to the kerning values (U8)

	m_dYAscent: f32;				// y offset from the baseline to the height of tallest character
	m_dYDescent: f32;				// y offset from the baseline to the bottom of the lowest descender
	m_dYLineGap: f32;				// lineGap is the spacing between one row's descent and the next row's ascent...
									// you should advance the vertical position by "ascent - descent + lineGap"

	m_aGlyph: [1] SFontGlyph;		// sorted by UCS2 glyph (for binary search)
}

SFont :: struct // tag=font
{
	m_pTex: & STexture;
	m_pGlyphf: & SFontGlyphFile;
	m_aWchKerning: & s32;
	m_aDxKerning: & f32;
}

SFontManager :: struct // tag=fontman
{
	m_aFont: [FONTK.max] SFont;
	m_aShhand: [FONTSHK.max] SHHAND;
}
g_fontman: SFontManager;

SFontVertex :: struct // tag=fvert
{
	m_x, m_y: f32;
	m_u, m_v: f32;
	m_r, m_g, m_b, m_a: f32;
	m_uMin, m_vMin, m_uMax, m_vMax: f32; // glyph bounds for clamping texture filtering
}

SShader :: struct// tag=shad
{
	m_driProgram: gluint;
	m_driVertexShader: gluint;
	m_driFragmentShader: gluint;
}

CORESHK :: enum // core shader kind
{
	Sprite,
	Environment,	// like sprite, but with "perspective" distortion
}

SShaderManager  :: struct // tag=shman
{
	m_aShad: [16] SShader;
	m_mpCoreshkShhand : [CORESHK.max] SHHAND;
}

ShhandFindUnused :: inline (pShman: &SShaderManager) -> SHHAND
{
	iShad: SHHAND;
	pShadEnd := &pShman.m_aShad[pShman.m_aShad.count];
	pShadIt: &SShader = pShman.m_aShad; 
	while pShadIt != pShadEnd
	{
		if pShadIt.m_driProgram == 0
			return iShad;
		++pShadIt;
		++iShad;
	}
	return SHHAND.nil;
}

// BB - would pass in print procs, but can't currently pass stdcall procedures
PrintShaderInfoLog :: (object: gluint)
{
	cCh: glint;
	glGetShaderiv(object, GL_INFO_LOG_LENGTH, &cCh);

	aCh := cast(&u8) PVMalloc(cCh);
	glGetShaderInfoLog(object, cCh, null, aCh);
	printf("%s", aCh);
	FreeMalloc(aCh);
}

PrintProgramInfoLog :: (object: gluint)
{
	cCh: glint;
	glGetProgramiv(object, GL_INFO_LOG_LENGTH, &cCh);

	aCh := cast(&u8) PVMalloc(cCh);
	glGetProgramInfoLog(object, cCh, null, aCh);
	printf("%s", aCh);
	FreeMalloc(aCh);
}

ShhandLoad :: (pShman: &SShaderManager, pChzMaterialName: &u8, pChzVertexSource: &u8, pChzFragmentSource: &u8) -> SHHAND
{
	shhand := ShhandFindUnused(pShman);
	if(shhand == SHHAND.nil)
		return SHHAND.nil;

	pShad := &pShman.m_aShad[shhand];    
	
	glSuccess: glint;
	pShad.m_driProgram			= glCreateProgram();
	pShad.m_driVertexShader		= glCreateShader(GL_VERTEX_SHADER_ARB);
	pShad.m_driFragmentShader	= glCreateShader(GL_FRAGMENT_SHADER_ARB);

	glShaderSource(pShad.m_driVertexShader, 1, &pChzVertexSource, null);
	glShaderSource(pShad.m_driFragmentShader, 1, &pChzFragmentSource, null);

	glCompileShader(pShad.m_driVertexShader);
	// if(checkForErrors("glCompileShaderARB(sd.vertexShader)", sd.m_vertexShader))
	// 	return SHHAND_Nil;

	glGetShaderiv(pShad.m_driVertexShader, GL_COMPILE_STATUS, &glSuccess);
	if (!glSuccess)
	{
		printf("Failed to compile vertex shader %s:\n", pChzMaterialName);
		PrintShaderInfoLog(pShad.m_driVertexShader);
		glDeleteShader(pShad.m_driVertexShader);
		return SHHAND.nil;
	}

	glCompileShader(pShad.m_driFragmentShader);
	// if(checkForErrors("glCompileShaderARB(pShad.fragmentShader)", pShad.m_driFragmentShader))
	// 	return SHHAND_Nil;

	glGetShaderiv(pShad.m_driFragmentShader, GL_COMPILE_STATUS, &glSuccess);
	if (!glSuccess)
	{
		printf("Failed to compile fragment shader %s:\n", pChzMaterialName);
		PrintShaderInfoLog(pShad.m_driFragmentShader);
		glDeleteShader(pShad.m_driVertexShader);
		glDeleteShader(pShad.m_driFragmentShader);
		return SHHAND.nil;
	}

	glAttachShader(pShad.m_driProgram, pShad.m_driVertexShader);
	glAttachShader(pShad.m_driProgram, pShad.m_driFragmentShader);

	glLinkProgram(pShad.m_driProgram);
	glGetProgramiv(pShad.m_driProgram, GL_LINK_STATUS, &glSuccess);
	if (!glSuccess)
	{
		printf("Failed to link shader program: %s\n", pChzMaterialName);
		PrintProgramInfoLog(pShad.m_driProgram);
		glDeleteProgram(pShad.m_driProgram);
		return SHHAND.nil;
	}
	// if(checkForErrors("glLinkProgram(mat.program)", sd.m_program))
	// 	return SHHAND_Nil;

	return shhand;
}

/*
void BeginShader(const CShaderManager * pShman, ShaderHandle shhand)
{
	const SShader & pShad = pShman->m_aShad[shhand];
	glUseProgram(pShad.m_driProgram);
	//checkForErrors("glCompileShaderARB(sd.vertexShader)", &sd.m_program);
}

void EndShader()
{
	glUseProgram(0);
}

I32 IParamFind(const CShaderManager * pShman, ShaderHandle shhand, const char* pChzName)
{
	EWC_ASSERT(shhand != SHHAND_Nil, "Bad shader handle");
	return glGetUniformLocation(pShman->m_aShad[shhand].m_driProgram, pChzName);
}
*/

g_fontMainVertex :: "";
g_fontMainFragment :: "";

PFontmanStaticInit :: (procAlloc: ProcAlloc, pShman: & SShaderManager) -> & SFontManager
{
	iFont := 0;
	while (iFont < g_fontman.m_aFont.count)
	{
		g_fontman.m_aFont[iFont].m_pTex			= null;
		g_fontman.m_aFont[iFont].m_pGlyphf		= null;
		g_fontman.m_aFont[iFont].m_aWchKerning	= null;
		g_fontman.m_aFont[iFont].m_aDxKerning	= null;
		++iFont;
	}

	LoadFont(&g_fontman, FONTK.Regular, "Fonts/Calibri", procAlloc);

	g_fontman.m_aShhand[FONTSHK.Basic] = ShhandLoad(pShman, "BasicFontShader", g_fontMainVertex, g_fontMainFragment);
	return &g_fontman;
}

ConcatPChz :: 	(pChzA: & u8, pChzB: & u8, aCh: [] u8)
{
	iCh: s32;
	cChEnd := aCh.count -1; // leave room for terminator, BB doesn't support zero size array

	while ((@pChzA != '\0') && (iCh < cChEnd))
	{
		aCh[iCh] = @pChzA;
		++pChzA;
		++iCh;
	}

	while ((@pChzB != '\0') && (iCh < cChEnd))
	{
		aCh[iCh] = @pChzB;
		++pChzB;
		++iCh;
	}

	aCh[iCh] = '\0';
}

PTexLoad :: (pChzFilename: & u8, fFlipVertical: bool) -> & STexture
{
    // TODO - should replace this with a hash
    shashFilename:= ShashCreate(pChzFilename, 0);

    iTex: s16;
    //for (int iTex = 0, cTex = g_aTex.C(); iTex < cTex; ++iTex)
    while (iTex < g_cTex)
    {
        pTex := &g_aTex[iTex];
        if (FAreEqual(pTex.m_shashFilename, shashFilename))
            return pTex;
        ++iTex;
    }


    if ((!fverify(iTex == cast(s32) cast(s16)iTex, "iTex overflow", #file, #line)) |
        (!fverify(g_cTex < g_aTex.count, "s_aryTex overflow", #file, #line)))
        return null;

    //STexture * pTex = (STexture*)s_aryTex.AppendNew();
    pTex := &g_aTex[g_cTex];
    ++g_cTex;
    pTex.m_cTexmip = 1;
    pTex.m_shashFilename = shashFilename;

    dX, dY: s32;
    cComponents: s32;
    pB : &u8 = stbi_load(pChzFilename, &dX, &dY, &cComponents, 4);
    if (pB == null)
        return null;
    
    // we'll flip most of our images so the UV origin is in the lower left

    if (fFlipVertical)
    {
        bTemp: u32;
        cLine := dY / 2;
        //for (int iLine = 0, cLine = dY>>1; iLine < cLine; ++iLine)
        iLine: s32;
        while (iLine < cLine)
        {
            pB1 := &(cast(&u32)pB)[iLine * dX];
            pB2 := &(cast(&u32)pB)[(dY - 1 - iLine) * dX];
            //for (U32 * pB1End = &pB1[dX]; pB1 != pB1End; ++pB1, ++pB2)
            pB1End := &pB1[dX];
            while (pB1 != pB1End)
            {
                bTemp = @pB1;
                @pB1 = @pB2;
                @pB2 = bTemp;
                ++pB1;
                ++pB2;
            }
            ++iLine;
        }
    }

    pTex.m_iTex = iTex;
    pTex.m_aTexmip[0].m_aB = pB;
    pTex.m_aTexmip[0].m_dX = dX;
    pTex.m_aTexmip[0].m_dY = dY;
    pTex.m_driComponents   = GL_RGBA; //numComponents;
    pTex.m_druFormat       = GL_RGBA; //GL_TEXTURE_2D;
    pTex.m_druType         = GL_UNSIGNED_BYTE;
    pTex.m_druTarget       = GL_TEXTURE_2D;

    glGenTextures(1, cast(&gluint)&pTex.m_driId);
    glBindTexture(GL_TEXTURE_2D, pTex.m_driId);

    iTexmip: u32;
    texmipEnd := &pTex.m_aTexmip[pTex.m_cTexmip];
    texmipIt : &STextureMip = pTex.m_aTexmip;
    //for(TextureMip * texmipIt = pTex.m_aTexmip; texmipIt != texmipEnd; ++texmipIt, ++iTexmip)
    while (texmipIt != texmipEnd)
    {
        glTexImage2D(
            GL_TEXTURE_2D,
            iTexmip,
            pTex.m_driComponents,
            texmipIt.m_dX,
            texmipIt.m_dY,
            0,
            pTex.m_druFormat,
            pTex.m_druType,
            texmipIt.m_aB);
        ++texmipIt;
        ++iTexmip;
    }

    return pTex;
}

LoadFont :: (pFontman: & SFontManager, fontk: FONTK, pChzFilename: & u8, procAlloc: ProcAlloc)
{
	aCh: [1024] u8;

	ConcatPChz(pChzFilename, ".png", aCh);
	pFontman.m_aFont[fontk].m_pTex = PTexLoad(aCh, false);
	//assert(pFontman.m_aFont[fontk].m_pTex, "Failed to load font texture: %s", aCh);
	assert(pFontman.m_aFont[fontk].m_pTex, "Failed to load font texture", #file, #line);

	ConcatPChz(pChzFilename, ".font", aCh);

	cBRead: s64;
	pB := PBReadEntireFile(aCh, &cBRead);
	if (!pB)
	{
		assert(false, "failed to load glyph file", #file, #line);
	}
	else
	{
		pFont: & SFont = &pFontman.m_aFont[fontk];

		pGlyphf := cast (&SFontGlyphFile)pB;
		pFont.m_aWchKerning = cast(&s32)(pB + pGlyphf.m_iBaWchKerning);
		assert(cast(&void)pFont.m_aWchKerning == cast(&void)&pGlyphf.m_aGlyph[pGlyphf.m_cGlyph], "bad offsets", #file, #line);

		pFont.m_aDxKerning = cast(&f32)(pB + pGlyphf.m_iBaDxKerning);
	}
	/*
	FILE * pFile;
	fopen_s(&pFile, aCh, "rb");
	EWC_ASSERT(pFile, "Failed to load font glyph file: %s", aCh);

	if(pFile != 0)
	{
		fseek(pFile, 0L, SEEK_END);
		size_t cBFile = ftell(pFile);
		fseek(pFile, 0L, SEEK_SET);

		SFont * pFont = &pFontman->m_aFont[fontk];
		pFont->m_pGlyphf = (SFontGlyphFile *)pAlloc->EWC_ALLOC(cBFile, 16);
		fread(pFont->m_pGlyphf, 1, cBFile, pFile);
		fclose(pFile);

		SFontGlyphFile * pGlyphf = pFont->m_pGlyphf;
		pFont->m_aWchKerning = (WChar *)(reinterpret_cast<U8 *>(pGlyphf) + pGlyphf->m_iBaWchKerning);
		EWC_ASSERT((void *)pFont->m_aWchKerning == (void *)&pGlyphf->m_aGlyph[pGlyphf->m_cGlyph], "bad offsets");

		pFont->m_aDxKerning = (F32 *)(reinterpret_cast<U8 *>(pGlyphf) + pGlyphf->m_iBaDxKerning);
	}*/
}


FillOutVert :: inline (
					x: float, y: float, 
					u: float, v: float, 
					r: float, g: float, b: float, a: float, 
					pGlyph: & SFontGlyph, 
					pVert: & SFontVertex)
{
	pVert.m_x = x;
	pVert.m_y = y;

	pVert.m_u = u;
	pVert.m_v = v;

	pVert.m_r = r;
	pVert.m_g = g;
	pVert.m_b = b;
	pVert.m_a = a;

	pVert.m_uMin = pGlyph.m_uMin;
	pVert.m_vMin = pGlyph.m_vMin;
	pVert.m_uMax = pGlyph.m_uMax;
	pVert.m_vMax = pGlyph.m_vMax;
}

