#foreign_library "kernel32"

FFILEACCESS :: enum s32
{
	GenericRead:		0x80000000,
	GenericWrite:		0x40000000,
	GenericExecute:		0x20000000,
	GenericAll:			0x10000000
}
	
FFILECREATE :: enum s32
{
	CreateNew: 			1,
	CreateAlways: 		2,
	OpenExisting: 		3,
	OpenAlways: 		4,
	TruncateExisting: 	5
}

FFILESHARE :: enum s32
{
	None:	0x0,
	Read:	0x1,
	Write:	0x2,
	Delete:	0x4
}

SLargeInteger :: struct  // tag = lgint
{
    m_nQuadPart: s64;
}

Bool32 :: typedef s32;

CreateFileA :: (
	pChzFilename: &u8,
	ffileaccess: FFILEACCESS,
	ffileshare: FFILESHARE,
	pVSecurity: & void,
	ffilecreate: FFILECREATE,
	ffileattrib: s32,
	hndTemplate: HANDLE) -> HANDLE #foreign #stdcall;

CloseHandle  :: (handle: HANDLE) -> s32 #foreign #stdcall;

GetFileSizeEx :: (hndFile: HANDLE, pLgint: & SLargeInteger) -> Bool32 #foreign #stdcall;

ReadFile :: (hndFile: HANDLE, pVBuffer: & void, cBRead: s32, pCBWasRead: & s32, pVOverlapped: &void) -> Bool32 #foreign;

SFile :: struct // tag = file
{
    m_hnd: HANDLE;
};


FileOpen :: (pChzFilename: & u8, fIsWriteMode: bool) -> SFile 
{
    file: SFile;
    if fIsWriteMode 
    {
        file.m_hnd = CreateFileA(
        	pChzFilename,
        	FFILEACCESS.GenericWrite,
        	FFILESHARE.Read,
        	null,	// pvSecurity
            FFILECREATE.CreateAlways,
            0, 		// ffileattrib
            0);		// hndTemplate
    }
    else 
    {
        file.m_hnd = CreateFileA(
        	pChzFilename,
        	FFILEACCESS.GenericRead,
        	FFILESHARE.Read,
        	null,	// pvSecurity
            FFILECREATE.OpenExisting,
            0, 		// ffileattrib
            0);		// hndTemplate
    }

    return file;
}

CloseFile :: (pFile: &SFile)
{
    CloseHandle(pFile.m_hnd);
}

